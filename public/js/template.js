/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/perfect-scrollbar/css/perfect-scrollbar.css":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/src??ref--6-2!./node_modules/perfect-scrollbar/css/perfect-scrollbar.css ***!
  \**************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\n * Container style\n */\n.ps {\n  overflow: hidden !important;\n  overflow-anchor: none;\n  -ms-overflow-style: none;\n  touch-action: auto;\n  -ms-touch-action: auto;\n}\n\n/*\n * Scrollbar rail styles\n */\n.ps__rail-x {\n  display: none;\n  opacity: 0;\n  transition: background-color .2s linear, opacity .2s linear;\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\n  height: 15px;\n  /* there must be 'bottom' or 'top' for ps__rail-x */\n  bottom: 0px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__rail-y {\n  display: none;\n  opacity: 0;\n  transition: background-color .2s linear, opacity .2s linear;\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\n  width: 15px;\n  /* there must be 'right' or 'left' for ps__rail-y */\n  right: 0;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps--active-x > .ps__rail-x,\n.ps--active-y > .ps__rail-y {\n  display: block;\n  background-color: transparent;\n}\n\n.ps:hover > .ps__rail-x,\n.ps:hover > .ps__rail-y,\n.ps--focus > .ps__rail-x,\n.ps--focus > .ps__rail-y,\n.ps--scrolling-x > .ps__rail-x,\n.ps--scrolling-y > .ps__rail-y {\n  opacity: 0.6;\n}\n\n.ps .ps__rail-x:hover,\n.ps .ps__rail-y:hover,\n.ps .ps__rail-x:focus,\n.ps .ps__rail-y:focus,\n.ps .ps__rail-x.ps--clicking,\n.ps .ps__rail-y.ps--clicking {\n  background-color: #eee;\n  opacity: 0.9;\n}\n\n/*\n * Scrollbar thumb styles\n */\n.ps__thumb-x {\n  background-color: #aaa;\n  border-radius: 6px;\n  transition: background-color .2s linear, height .2s ease-in-out;\n  -webkit-transition: background-color .2s linear, height .2s ease-in-out;\n  height: 6px;\n  /* there must be 'bottom' for ps__thumb-x */\n  bottom: 2px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__thumb-y {\n  background-color: #aaa;\n  border-radius: 6px;\n  transition: background-color .2s linear, width .2s ease-in-out;\n  -webkit-transition: background-color .2s linear, width .2s ease-in-out;\n  width: 6px;\n  /* there must be 'right' for ps__thumb-y */\n  right: 2px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__rail-x:hover > .ps__thumb-x,\n.ps__rail-x:focus > .ps__thumb-x,\n.ps__rail-x.ps--clicking .ps__thumb-x {\n  background-color: #999;\n  height: 11px;\n}\n\n.ps__rail-y:hover > .ps__thumb-y,\n.ps__rail-y:focus > .ps__thumb-y,\n.ps__rail-y.ps--clicking .ps__thumb-y {\n  background-color: #999;\n  width: 11px;\n}\n\n/* MS supports */\n@supports (-ms-overflow-style: none) {\n  .ps {\n    overflow: auto !important;\n  }\n}\n\n@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {\n  .ps {\n    overflow: auto !important;\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/js-cookie/src/js.cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/js-cookie/src/js.cookie.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		registeredInModuleLoader = true;
	}
	if (true) {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));


/***/ }),

/***/ "./node_modules/perfect-scrollbar/css/perfect-scrollbar.css":
/*!******************************************************************!*\
  !*** ./node_modules/perfect-scrollbar/css/perfect-scrollbar.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../css-loader??ref--6-1!../../postcss-loader/src??ref--6-2!./perfect-scrollbar.css */ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/perfect-scrollbar/css/perfect-scrollbar.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/perfect-scrollbar/dist/perfect-scrollbar.js":
/*!******************************************************************!*\
  !*** ./node_modules/perfect-scrollbar/dist/perfect-scrollbar.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * perfect-scrollbar v1.4.0
 * (c) 2018 Hyunje Jun
 * @license MIT
 */
(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function get(element) {
  return getComputedStyle(element);
}

function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}

function div(className) {
  var div = document.createElement('div');
  div.className = className;
  return div;
}

var elMatches =
  typeof Element !== 'undefined' &&
  (Element.prototype.matches ||
    Element.prototype.webkitMatchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector);

function matches(element, query) {
  if (!elMatches) {
    throw new Error('No element matching method supported');
  }

  return elMatches.call(element, query);
}

function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}

function queryChildren(element, selector) {
  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }
  );
}

var cls = {
  main: 'ps',
  element: {
    thumb: function (x) { return ("ps__thumb-" + x); },
    rail: function (x) { return ("ps__rail-" + x); },
    consuming: 'ps__child--consume',
  },
  state: {
    focus: 'ps--focus',
    clicking: 'ps--clicking',
    active: function (x) { return ("ps--active-" + x); },
    scrolling: function (x) { return ("ps--scrolling-" + x); },
  },
};

/*
 * Helper methods
 */
var scrollingClassTimeout = { x: null, y: null };

function addScrollingClass(i, x) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x);

  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x]);
  } else {
    classList.add(className);
  }
}

function removeScrollingClass(i, x) {
  scrollingClassTimeout[x] = setTimeout(
    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },
    i.settings.scrollingThreshold
  );
}

function setScrollingClassInstantly(i, x) {
  addScrollingClass(i, x);
  removeScrollingClass(i, x);
}

var EventElement = function EventElement(element) {
  this.element = element;
  this.handlers = {};
};

var prototypeAccessors = { isEmpty: { configurable: true } };

EventElement.prototype.bind = function bind (eventName, handler) {
  if (typeof this.handlers[eventName] === 'undefined') {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function unbind (eventName, target) {
    var this$1 = this;

  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};

EventElement.prototype.unbindAll = function unbindAll () {
    var this$1 = this;

  for (var name in this$1.handlers) {
    this$1.unbind(name);
  }
};

prototypeAccessors.isEmpty.get = function () {
    var this$1 = this;

  return Object.keys(this.handlers).every(
    function (key) { return this$1.handlers[key].length === 0; }
  );
};

Object.defineProperties( EventElement.prototype, prototypeAccessors );

var EventManager = function EventManager() {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function eventElement (element) {
  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];
  if (!ee) {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function bind (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function unbind (element, eventName, handler) {
  var ee = this.eventElement(element);
  ee.unbind(eventName, handler);

  if (ee.isEmpty) {
    // remove
    this.eventElements.splice(this.eventElements.indexOf(ee), 1);
  }
};

EventManager.prototype.unbindAll = function unbindAll () {
  this.eventElements.forEach(function (e) { return e.unbindAll(); });
  this.eventElements = [];
};

EventManager.prototype.once = function once (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (evt) {
    ee.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee.bind(eventName, onceHandler);
};

function createEvent(name) {
  if (typeof window.CustomEvent === 'function') {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(name, false, false, undefined);
    return evt;
  }
}

var processScrollDiff = function(
  i,
  axis,
  diff,
  useScrollingClass,
  forceFireReachEvent
) {
  if ( useScrollingClass === void 0 ) useScrollingClass = true;
  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;

  var fields;
  if (axis === 'top') {
    fields = [
      'contentHeight',
      'containerHeight',
      'scrollTop',
      'y',
      'up',
      'down' ];
  } else if (axis === 'left') {
    fields = [
      'contentWidth',
      'containerWidth',
      'scrollLeft',
      'x',
      'left',
      'right' ];
  } else {
    throw new Error('A proper axis should be provided');
  }

  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
};

function processScrollDiff$1(
  i,
  diff,
  ref,
  useScrollingClass,
  forceFireReachEvent
) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y = ref[3];
  var up = ref[4];
  var down = ref[5];
  if ( useScrollingClass === void 0 ) useScrollingClass = true;
  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;

  var element = i.element;

  // reset reach
  i.reach[y] = null;

  // 1 for subpixel rounding
  if (element[scrollTop] < 1) {
    i.reach[y] = 'start';
  }

  // 1 for subpixel rounding
  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y] = 'end';
  }

  if (diff) {
    element.dispatchEvent(createEvent(("ps-scroll-" + y)));

    if (diff < 0) {
      element.dispatchEvent(createEvent(("ps-scroll-" + up)));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent(("ps-scroll-" + down)));
    }

    if (useScrollingClass) {
      setScrollingClassInstantly(i, y);
    }
  }

  if (i.reach[y] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent(("ps-" + y + "-reach-" + (i.reach[y]))));
  }
}

function toInt(x) {
  return parseInt(x, 10) || 0;
}

function isEditable(el) {
  return (
    matches(el, 'input,[contenteditable]') ||
    matches(el, 'select,[contenteditable]') ||
    matches(el, 'textarea,[contenteditable]') ||
    matches(el, 'button,[contenteditable]')
  );
}

function outerWidth(element) {
  var styles = get(element);
  return (
    toInt(styles.width) +
    toInt(styles.paddingLeft) +
    toInt(styles.paddingRight) +
    toInt(styles.borderLeftWidth) +
    toInt(styles.borderRightWidth)
  );
}

var env = {
  isWebKit:
    typeof document !== 'undefined' &&
    'WebkitAppearance' in document.documentElement.style,
  supportsTouch:
    typeof window !== 'undefined' &&
    ('ontouchstart' in window ||
      (window.DocumentTouch && document instanceof window.DocumentTouch)),
  supportsIePointer:
    typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,
  isChrome:
    typeof navigator !== 'undefined' &&
    /Chrome/i.test(navigator && navigator.userAgent),
};

var updateGeometry = function(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  if (!element.contains(i.scrollbarXRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }
    );
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }
    );
    element.appendChild(i.scrollbarYRail);
  }

  if (
    !i.settings.suppressScrollX &&
    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth
  ) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt(
      (i.negativeScrollAdjustment + element.scrollLeft) *
        (i.railXWidth - i.scrollbarXWidth) /
        (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }

  if (
    !i.settings.suppressScrollY &&
    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight
  ) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt(
      roundedScrollTop *
        (i.railYHeight - i.scrollbarYHeight) /
        (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active('x'));
  } else {
    element.classList.remove(cls.state.active('x'));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active('y'));
  } else {
    element.classList.remove(cls.state.active('y'));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
};

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);

  if (i.isRtl) {
    xRailOffset.left =
      i.negativeScrollAdjustment +
      element.scrollLeft +
      i.containerWidth -
      i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);

  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right =
        i.contentWidth -
        (i.negativeScrollAdjustment + element.scrollLeft) -
        i.scrollbarYRight -
        i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left =
        i.negativeScrollAdjustment +
        element.scrollLeft +
        i.containerWidth * 2 -
        i.contentWidth -
        i.scrollbarYLeft -
        i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);

  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth,
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth,
  });
}

var clickRail = function(i) {
  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });
  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {
    var positionTop =
      e.pageY -
      window.pageYOffset -
      i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;

    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);

    e.stopPropagation();
  });

  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });
  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {
    var positionLeft =
      e.pageX -
      window.pageXOffset -
      i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;

    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);

    e.stopPropagation();
  });
};

var dragThumb = function(i) {
  bindMouseScrollHandler(i, [
    'containerWidth',
    'contentWidth',
    'pageX',
    'railXWidth',
    'scrollbarX',
    'scrollbarXWidth',
    'scrollLeft',
    'x',
    'scrollbarXRail' ]);
  bindMouseScrollHandler(i, [
    'containerHeight',
    'contentHeight',
    'pageY',
    'railYHeight',
    'scrollbarY',
    'scrollbarYHeight',
    'scrollTop',
    'y',
    'scrollbarYRail' ]);
};

function bindMouseScrollHandler(
  i,
  ref
) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y = ref[7];
  var scrollbarYRail = ref[8];

  var element = i.element;

  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;

  function mouseMoveHandler(e) {
    element[scrollTop] =
      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y);
    updateGeometry(i);

    e.stopPropagation();
    e.preventDefault();
  }

  function mouseUpHandler() {
    removeScrollingClass(i, y);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  }

  i.event.bind(i[scrollbarY], 'mousedown', function (e) {
    startingScrollTop = element[scrollTop];
    startingMousePageY = e[pageY];
    scrollBy =
      (i[contentHeight] - i[containerHeight]) /
      (i[railYHeight] - i[scrollbarYHeight]);

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    i[scrollbarYRail].classList.add(cls.state.clicking);

    e.stopPropagation();
    e.preventDefault();
  });
}

var keyboard = function(i) {
  var element = i.element;

  var elementHovered = function () { return matches(element, ':hover'); };
  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (
        (scrollTop === 0 && deltaY > 0) ||
        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)
      ) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (
        (scrollLeft === 0 && deltaX < 0) ||
        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)
      ) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (
      (e.isDefaultPrevented && e.isDefaultPrevented()) ||
      e.defaultPrevented
    ) {
      return;
    }

    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }

    var activeElement = document.activeElement
      ? document.activeElement
      : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === 'IFRAME') {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        // go deeper if element is a webcomponent
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
      case 37: // left
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38: // up
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39: // right
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40: // down
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32: // space bar
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33: // page up
        deltaY = i.containerHeight;
        break;
      case 34: // page down
        deltaY = -i.containerHeight;
        break;
      case 36: // home
        deltaY = i.contentHeight;
        break;
      case 35: // end
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }

    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }

    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);

    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
};

var wheel = function(i) {
  var element = i.element;

  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom =
      roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight =
      element.scrollLeft + element.offsetWidth === element.scrollWidth;

    var hitsBound;

    // pick axis with primary direction
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }

    return hitsBound ? !i.settings.wheelPropagation : true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    if (e.shiftKey) {
      // reverse axis with shift key
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    // FIXME: this is a workaround for <select> issue in FF and IE #571
    if (!env.isWebKit && element.querySelector('select:focus')) {
      return true;
    }

    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor);
      var overflow = [style.overflow, style.overflowX, style.overflowY].join(
        ''
      );

      // if scrollable
      if (overflow.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (
            !(cursor.scrollTop === 0 && deltaY > 0) &&
            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
          ) {
            return true;
          }
        }
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (
            !(cursor.scrollLeft === 0 && deltaX < 0) &&
            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
          ) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function mousewheelHandler(e) {
    var ref = getDeltaFromEvent(e);
    var deltaX = ref[0];
    var deltaY = ref[1];

    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    }

    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }

    updateGeometry(i);

    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== 'undefined') {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== 'undefined') {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
};

var touch = function(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }

  var element = i.element;

  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (
        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||
        (deltaY > 0 && scrollTop === 0)
      ) {
        // set prevent for mobile Chrome refresh
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (
        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||
        (deltaX > 0 && scrollLeft === 0)
      ) {
        return true;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;

    updateGeometry(i);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }

  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {
      return false;
    }
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (
      e.pointerType &&
      e.pointerType !== 'mouse' &&
      e.pointerType !== e.MSPOINTER_TYPE_MOUSE
    ) {
      return true;
    }
    return false;
  }

  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }

    var touch = getTouch(e);

    startOffset.pageX = touch.pageX;
    startOffset.pageY = touch.pageY;

    startTime = new Date().getTime();

    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor);
      var overflow = [style.overflow, style.overflowX, style.overflowY].join(
        ''
      );

      // if scrollable
      if (overflow.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (
            !(cursor.scrollTop === 0 && deltaY > 0) &&
            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
          ) {
            return true;
          }
        }
        var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (
            !(cursor.scrollLeft === 0 && deltaX < 0) &&
            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
          ) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = new Date().getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }

        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (env.supportsTouch) {
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
};

var defaultSettings = function () { return ({
  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollingThreshold: 1000,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  suppressScrollX: false,
  suppressScrollY: false,
  swipeEasing: true,
  useBothWheelAxes: false,
  wheelPropagation: true,
  wheelSpeed: 1,
}); };

var handlers = {
  'click-rail': clickRail,
  'drag-thumb': dragThumb,
  keyboard: keyboard,
  wheel: wheel,
  touch: touch,
};

var PerfectScrollbar = function PerfectScrollbar(element, userSettings) {
  var this$1 = this;
  if ( userSettings === void 0 ) userSettings = {};

  if (typeof element === 'string') {
    element = document.querySelector(element);
  }

  if (!element || !element.nodeName) {
    throw new Error('no element is specified to initialize PerfectScrollbar');
  }

  this.element = element;

  element.classList.add(cls.main);

  this.settings = defaultSettings();
  for (var key in userSettings) {
    this$1.settings[key] = userSettings[key];
  }

  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;

  var focus = function () { return element.classList.add(cls.state.focus); };
  var blur = function () { return element.classList.remove(cls.state.focus); };

  this.isRtl = get(element).direction === 'rtl';
  this.isNegativeScroll = (function () {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  })();
  this.negativeScrollAdjustment = this.isNegativeScroll
    ? element.scrollWidth - element.clientWidth
    : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;

  this.scrollbarXRail = div(cls.element.rail('x'));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb('x'));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute('tabindex', 0);
  this.event.bind(this.scrollbarX, 'focus', focus);
  this.event.bind(this.scrollbarX, 'blur', blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth =
    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  // Set rail to display:block to calculate margins
  set(this.scrollbarXRail, { display: 'block' });
  this.railXMarginWidth =
    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, { display: '' });
  this.railXWidth = null;
  this.railXRatio = null;

  this.scrollbarYRail = div(cls.element.rail('y'));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb('y'));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute('tabindex', 0);
  this.event.bind(this.scrollbarY, 'focus', focus);
  this.event.bind(this.scrollbarY, 'blur', blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth =
    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, { display: 'block' });
  this.railYMarginHeight =
    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, { display: '' });
  this.railYHeight = null;
  this.railYRatio = null;

  this.reach = {
    x:
      element.scrollLeft <= 0
        ? 'start'
        : element.scrollLeft >= this.contentWidth - this.containerWidth
          ? 'end'
          : null,
    y:
      element.scrollTop <= 0
        ? 'start'
        : element.scrollTop >= this.contentHeight - this.containerHeight
          ? 'end'
          : null,
  };

  this.isAlive = true;

  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });

  this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only
  this.lastScrollLeft = element.scrollLeft; // for onScroll only
  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });
  updateGeometry(this);
};

PerfectScrollbar.prototype.update = function update () {
  if (!this.isAlive) {
    return;
  }

  // Recalcuate negative scrollLeft adjustment
  this.negativeScrollAdjustment = this.isNegativeScroll
    ? this.element.scrollWidth - this.element.clientWidth
    : 0;

  // Recalculate rail margins
  set(this.scrollbarXRail, { display: 'block' });
  set(this.scrollbarYRail, { display: 'block' });
  this.railXMarginWidth =
    toInt(get(this.scrollbarXRail).marginLeft) +
    toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight =
    toInt(get(this.scrollbarYRail).marginTop) +
    toInt(get(this.scrollbarYRail).marginBottom);

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  set(this.scrollbarXRail, { display: 'none' });
  set(this.scrollbarYRail, { display: 'none' });

  updateGeometry(this);

  processScrollDiff(this, 'top', 0, false, true);
  processScrollDiff(this, 'left', 0, false, true);

  set(this.scrollbarXRail, { display: '' });
  set(this.scrollbarYRail, { display: '' });
};

PerfectScrollbar.prototype.onScroll = function onScroll (e) {
  if (!this.isAlive) {
    return;
  }

  updateGeometry(this);
  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    'left',
    this.element.scrollLeft - this.lastScrollLeft
  );

  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};

PerfectScrollbar.prototype.destroy = function destroy () {
  if (!this.isAlive) {
    return;
  }

  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();

  // unset elements
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;

  this.isAlive = false;
};

PerfectScrollbar.prototype.removePsClasses = function removePsClasses () {
  this.element.className = this.element.className
    .split(' ')
    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })
    .join(' ');
};

return PerfectScrollbar;

})));


/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/sticky-js/dist/sticky.compile.js":
/*!*******************************************************!*\
  !*** ./node_modules/sticky-js/dist/sticky.compile.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Sticky.js
 * Library for sticky elements written in vanilla javascript. With this library you can easily set sticky elements on your website. It's also responsive.
 *
 * @version 1.2.0
 * @author Rafal Galus <biuro@rafalgalus.pl>
 * @website https://rgalus.github.io/sticky-js/
 * @repo https://github.com/rgalus/sticky-js
 * @license https://github.com/rgalus/sticky-js/blob/master/LICENSE
 */

var Sticky = function () {
  /**
   * Sticky instance constructor
   * @constructor
   * @param {string} selector - Selector which we can find elements
   * @param {string} options - Global options for sticky elements (could be overwritten by data-{option}="" attributes)
   */
  function Sticky() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Sticky);

    this.selector = selector;
    this.elements = [];

    this.version = '1.2.0';

    this.vp = this.getViewportSize();
    this.body = document.querySelector('body');

    this.options = {
      wrap: options.wrap || false,
      marginTop: options.marginTop || 0,
      stickyFor: options.stickyFor || 0,
      stickyClass: options.stickyClass || null,
      stickyContainer: options.stickyContainer || 'body'
    };

    this.updateScrollTopPosition = this.updateScrollTopPosition.bind(this);

    this.updateScrollTopPosition();
    window.addEventListener('load', this.updateScrollTopPosition);
    window.addEventListener('scroll', this.updateScrollTopPosition);

    this.run();
  }

  /**
   * Function that waits for page to be fully loaded and then renders & activates every sticky element found with specified selector
   * @function
   */


  Sticky.prototype.run = function run() {
    var _this = this;

    // wait for page to be fully loaded
    var pageLoaded = setInterval(function () {
      if (document.readyState === 'complete') {
        clearInterval(pageLoaded);

        var elements = document.querySelectorAll(_this.selector);
        _this.forEach(elements, function (element) {
          return _this.renderElement(element);
        });
      }
    }, 10);
  };

  /**
   * Function that assign needed variables for sticky element, that are used in future for calculations and other
   * @function
   * @param {node} element - Element to be rendered
   */


  Sticky.prototype.renderElement = function renderElement(element) {
    var _this2 = this;

    // create container for variables needed in future
    element.sticky = {};

    // set default variables
    element.sticky.active = false;

    element.sticky.marginTop = parseInt(element.getAttribute('data-margin-top')) || this.options.marginTop;
    element.sticky.stickyFor = parseInt(element.getAttribute('data-sticky-for')) || this.options.stickyFor;
    element.sticky.stickyClass = element.getAttribute('data-sticky-class') || this.options.stickyClass;
    element.sticky.wrap = element.hasAttribute('data-sticky-wrap') ? true : this.options.wrap;
    // @todo attribute for stickyContainer
    // element.sticky.stickyContainer = element.getAttribute('data-sticky-container') || this.options.stickyContainer;
    element.sticky.stickyContainer = this.options.stickyContainer;

    element.sticky.container = this.getStickyContainer(element);
    element.sticky.container.rect = this.getRectangle(element.sticky.container);

    element.sticky.rect = this.getRectangle(element);

    // fix when element is image that has not yet loaded and width, height = 0
    if (element.tagName.toLowerCase() === 'img') {
      element.onload = function () {
        return element.sticky.rect = _this2.getRectangle(element);
      };
    }

    if (element.sticky.wrap) {
      this.wrapElement(element);
    }

    // activate rendered element
    this.activate(element);
  };

  /**
   * Wraps element into placeholder element
   * @function
   * @param {node} element - Element to be wrapped
   */


  Sticky.prototype.wrapElement = function wrapElement(element) {
    element.insertAdjacentHTML('beforebegin', '<span></span>');
    element.previousSibling.appendChild(element);
  };

  /**
   * Function that activates element when specified conditions are met and then initalise events
   * @function
   * @param {node} element - Element to be activated
   */


  Sticky.prototype.activate = function activate(element) {
    if (element.sticky.rect.top + element.sticky.rect.height < element.sticky.container.rect.top + element.sticky.container.rect.height && element.sticky.stickyFor < this.vp.width && !element.sticky.active) {
      element.sticky.active = true;
    }

    if (this.elements.indexOf(element) < 0) {
      this.elements.push(element);
    }

    if (!element.sticky.resizeEvent) {
      this.initResizeEvents(element);
      element.sticky.resizeEvent = true;
    }

    if (!element.sticky.scrollEvent) {
      this.initScrollEvents(element);
      element.sticky.scrollEvent = true;
    }

    this.setPosition(element);
  };

  /**
   * Function which is adding onResizeEvents to window listener and assigns function to element as resizeListener
   * @function
   * @param {node} element - Element for which resize events are initialised
   */


  Sticky.prototype.initResizeEvents = function initResizeEvents(element) {
    var _this3 = this;

    element.sticky.resizeListener = function () {
      return _this3.onResizeEvents(element);
    };
    window.addEventListener('resize', element.sticky.resizeListener);
  };

  /**
   * Removes element listener from resize event
   * @function
   * @param {node} element - Element from which listener is deleted
   */


  Sticky.prototype.destroyResizeEvents = function destroyResizeEvents(element) {
    window.removeEventListener('resize', element.sticky.resizeListener);
  };

  /**
   * Function which is fired when user resize window. It checks if element should be activated or deactivated and then run setPosition function
   * @function
   * @param {node} element - Element for which event function is fired
   */


  Sticky.prototype.onResizeEvents = function onResizeEvents(element) {
    this.vp = this.getViewportSize();

    element.sticky.rect = this.getRectangle(element);
    element.sticky.container.rect = this.getRectangle(element.sticky.container);

    if (element.sticky.rect.top + element.sticky.rect.height < element.sticky.container.rect.top + element.sticky.container.rect.height && element.sticky.stickyFor < this.vp.width && !element.sticky.active) {
      element.sticky.active = true;
    } else if (element.sticky.rect.top + element.sticky.rect.height >= element.sticky.container.rect.top + element.sticky.container.rect.height || element.sticky.stickyFor >= this.vp.width && element.sticky.active) {
      element.sticky.active = false;
    }

    this.setPosition(element);
  };

  /**
   * Function which is adding onScrollEvents to window listener and assigns function to element as scrollListener
   * @function
   * @param {node} element - Element for which scroll events are initialised
   */


  Sticky.prototype.initScrollEvents = function initScrollEvents(element) {
    var _this4 = this;

    element.sticky.scrollListener = function () {
      return _this4.onScrollEvents(element);
    };
    window.addEventListener('scroll', element.sticky.scrollListener);
  };

  /**
   * Removes element listener from scroll event
   * @function
   * @param {node} element - Element from which listener is deleted
   */


  Sticky.prototype.destroyScrollEvents = function destroyScrollEvents(element) {
    window.removeEventListener('scroll', element.sticky.scrollListener);
  };

  /**
   * Function which is fired when user scroll window. If element is active, function is invoking setPosition function
   * @function
   * @param {node} element - Element for which event function is fired
   */


  Sticky.prototype.onScrollEvents = function onScrollEvents(element) {
    if (element.sticky.active) {
      this.setPosition(element);
    }
  };

  /**
   * Main function for the library. Here are some condition calculations and css appending for sticky element when user scroll window
   * @function
   * @param {node} element - Element that will be positioned if it's active
   */


  Sticky.prototype.setPosition = function setPosition(element) {
    this.css(element, { position: '', width: '', top: '', left: '' });

    if (this.vp.height < element.sticky.rect.height || !element.sticky.active) {
      return;
    }

    if (!element.sticky.rect.width) {
      element.sticky.rect = this.getRectangle(element);
    }

    if (element.sticky.wrap) {
      this.css(element.parentNode, {
        display: 'block',
        width: element.sticky.rect.width + 'px',
        height: element.sticky.rect.height + 'px'
      });
    }

    if (element.sticky.rect.top === 0 && element.sticky.container === this.body) {
      this.css(element, {
        position: 'fixed',
        top: element.sticky.rect.top + 'px',
        left: element.sticky.rect.left + 'px',
        width: element.sticky.rect.width + 'px'
      });
    } else if (this.scrollTop > element.sticky.rect.top - element.sticky.marginTop) {
      this.css(element, {
        position: 'fixed',
        width: element.sticky.rect.width + 'px',
        left: element.sticky.rect.left + 'px'
      });

      if (this.scrollTop + element.sticky.rect.height + element.sticky.marginTop > element.sticky.container.rect.top + element.sticky.container.offsetHeight) {

        if (element.sticky.stickyClass) {
          element.classList.remove(element.sticky.stickyClass);
        }

        this.css(element, {
          top: element.sticky.container.rect.top + element.sticky.container.offsetHeight - (this.scrollTop + element.sticky.rect.height) + 'px' });
      } else {
        if (element.sticky.stickyClass) {
          element.classList.add(element.sticky.stickyClass);
        }

        this.css(element, { top: element.sticky.marginTop + 'px' });
      }
    } else {
      if (element.sticky.stickyClass) {
        element.classList.remove(element.sticky.stickyClass);
      }

      this.css(element, { position: '', width: '', top: '', left: '' });

      if (element.sticky.wrap) {
        this.css(element.parentNode, { display: '', width: '', height: '' });
      }
    }
  };

  /**
   * Function that updates element sticky rectangle (with sticky container), then activate or deactivate element, then update position if it's active
   * @function
   */


  Sticky.prototype.update = function update() {
    var _this5 = this;

    this.forEach(this.elements, function (element) {
      element.sticky.rect = _this5.getRectangle(element);
      element.sticky.container.rect = _this5.getRectangle(element.sticky.container);

      _this5.activate(element);
      _this5.setPosition(element);
    });
  };

  /**
   * Destroys sticky element, remove listeners
   * @function
   */


  Sticky.prototype.destroy = function destroy() {
    var _this6 = this;

    this.forEach(this.elements, function (element) {
      _this6.destroyResizeEvents(element);
      _this6.destroyScrollEvents(element);
      delete element.sticky;
    });
  };

  /**
   * Function that returns container element in which sticky element is stuck (if is not specified, then it's stuck to body)
   * @function
   * @param {node} element - Element which sticky container are looked for
   * @return {node} element - Sticky container
   */


  Sticky.prototype.getStickyContainer = function getStickyContainer(element) {
    var container = element.parentNode;

    while (!container.hasAttribute('data-sticky-container') && !container.parentNode.querySelector(element.sticky.stickyContainer) && container !== this.body) {
      container = container.parentNode;
    }

    return container;
  };

  /**
   * Function that returns element rectangle & position (width, height, top, left)
   * @function
   * @param {node} element - Element which position & rectangle are returned
   * @return {object}
   */


  Sticky.prototype.getRectangle = function getRectangle(element) {
    this.css(element, { position: '', width: '', top: '', left: '' });

    var width = Math.max(element.offsetWidth, element.clientWidth, element.scrollWidth);
    var height = Math.max(element.offsetHeight, element.clientHeight, element.scrollHeight);

    var top = 0;
    var left = 0;

    do {
      top += element.offsetTop || 0;
      left += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);

    return { top: top, left: left, width: width, height: height };
  };

  /**
   * Function that returns viewport dimensions
   * @function
   * @return {object}
   */


  Sticky.prototype.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };

  /**
   * Function that updates window scroll position
   * @function
   * @return {number}
   */


  Sticky.prototype.updateScrollTopPosition = function updateScrollTopPosition() {
    this.scrollTop = (window.pageYOffset || document.scrollTop) - (document.clientTop || 0) || 0;
  };

  /**
   * Helper function for loops
   * @helper
   * @param {array}
   * @param {function} callback - Callback function (no need for explanation)
   */


  Sticky.prototype.forEach = function forEach(array, callback) {
    for (var i = 0, len = array.length; i < len; i++) {
      callback(array[i]);
    }
  };

  /**
   * Helper function to add/remove css properties for specified element.
   * @helper
   * @param {node} element - DOM element
   * @param {object} properties - CSS properties that will be added/removed from specified element
   */


  Sticky.prototype.css = function css(element, properties) {
    for (var property in properties) {
      if (properties.hasOwnProperty(property)) {
        element.style[property] = properties[property];
      }
    }
  };

  return Sticky;
}();

/**
 * Export function that supports AMD, CommonJS and Plain Browser.
 */


(function (root, factory) {
  if (true) {
    module.exports = factory;
  } else {}
})(this, Sticky);

/***/ }),

/***/ "./node_modules/sticky-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sticky-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var Sticky = __webpack_require__(/*! ./dist/sticky.compile.js */ "./node_modules/sticky-js/dist/sticky.compile.js");

module.exports = Sticky;


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/tooltip.js/dist/esm/tooltip.js":
/*!*****************************************************!*\
  !*** ./node_modules/tooltip.js/dist/esm/tooltip.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.3.3
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var DEFAULT_OPTIONS = {
  container: false,
  delay: 0,
  html: false,
  placement: 'top',
  title: '',
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  trigger: 'hover focus',
  offset: 0,
  arrowSelector: '.tooltip-arrow, .tooltip__arrow',
  innerSelector: '.tooltip-inner, .tooltip__inner'
};

var Tooltip = function () {
  /**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement='top'
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {String} [options.arrowSelector='.tooltip-arrow, .tooltip__arrow'] - className used to locate the DOM arrow element in the tooltip.
   * @param {String} [options.innerSelector='.tooltip-inner, .tooltip__inner'] - className used to locate the DOM inner element in the tooltip.
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `textContent`.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {Boolean} options.closeOnClickOutside=false - Close a popper on click outside of the popper and reference element. This has effect only when options.trigger is 'click'.
   * @param {String|HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @return {Object} instance - The generated tooltip instance
   */
  function Tooltip(reference, options) {
    classCallCheck(this, Tooltip);

    _initialiseProps.call(this);

    // apply user options over default ones
    options = _extends({}, DEFAULT_OPTIONS, options);

    reference.jquery && (reference = reference[0]);

    // cache reference and options
    this.reference = reference;
    this.options = options;

    // get events list
    var events = typeof options.trigger === 'string' ? options.trigger.split(' ').filter(function (trigger) {
      return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;
    }) : [];

    // set initial state
    this._isOpen = false;
    this._popperOptions = {};

    // set event listeners
    this._setEventListeners(reference, events, options);
  }

  //
  // Public methods
  //

  /**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */


  /**
   * Hides an elements tooltip. This is considered a manual triggering of the tooltip.
   * @method Tooltip#hide
   * @memberof Tooltip
   */


  /**
   * Hides and destroys an elements tooltip.
   * @method Tooltip#dispose
   * @memberof Tooltip
   */


  /**
   * Toggles an elements tooltip. This is considered a manual triggering of the tooltip.
   * @method Tooltip#toggle
   * @memberof Tooltip
   */


  /**
   * Updates the tooltip's title content
   * @method Tooltip#updateTitleContent
   * @memberof Tooltip
   * @param {String|HTMLElement} title - The new content to use for the title
   */


  //
  // Private methods
  //

  createClass(Tooltip, [{
    key: '_create',


    /**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLElement} tooltipNode
     */
    value: function _create(reference, template, title, allowHtml) {
      // create tooltip element
      var tooltipGenerator = window.document.createElement('div');
      tooltipGenerator.innerHTML = template.trim();
      var tooltipNode = tooltipGenerator.childNodes[0];

      // add unique ID to our tooltip (needed for accessibility reasons)
      tooltipNode.id = 'tooltip_' + Math.random().toString(36).substr(2, 10);

      // set initial `aria-hidden` state to `false` (it's visible!)
      tooltipNode.setAttribute('aria-hidden', 'false');

      // add title to tooltip
      var titleNode = tooltipGenerator.querySelector(this.options.innerSelector);
      this._addTitleContent(reference, title, allowHtml, titleNode);

      // return the generated tooltip node
      return tooltipNode;
    }
  }, {
    key: '_addTitleContent',
    value: function _addTitleContent(reference, title, allowHtml, titleNode) {
      if (title.nodeType === 1 || title.nodeType === 11) {
        // if title is a element node or document fragment, append it only if allowHtml is true
        allowHtml && titleNode.appendChild(title);
      } else if (isFunction(title)) {
        // Recursively call ourself so that the return value of the function gets handled appropriately - either
        // as a dom node, a string, or even as another function.
        this._addTitleContent(reference, title.call(reference), allowHtml, titleNode);
      } else {
        // if it's just a simple text, set textContent or innerHtml depending by `allowHtml` value
        allowHtml ? titleNode.innerHTML = title : titleNode.textContent = title;
      }
    }
  }, {
    key: '_show',
    value: function _show(reference, options) {
      // don't show if it's already visible
      // or if it's not being showed
      if (this._isOpen && !this._isOpening) {
        return this;
      }
      this._isOpen = true;

      // if the tooltipNode already exists, just show it
      if (this._tooltipNode) {
        this._tooltipNode.style.visibility = 'visible';
        this._tooltipNode.setAttribute('aria-hidden', 'false');
        this.popperInstance.update();
        return this;
      }

      // get title
      var title = reference.getAttribute('title') || options.title;

      // don't show tooltip if no title is defined
      if (!title) {
        return this;
      }

      // create tooltip node
      var tooltipNode = this._create(reference, options.template, title, options.html);

      // Add `aria-describedby` to our reference element for accessibility reasons
      reference.setAttribute('aria-describedby', tooltipNode.id);

      // append tooltip to container
      var container = this._findContainer(options.container, reference);

      this._append(tooltipNode, container);

      this._popperOptions = _extends({}, options.popperOptions, {
        placement: options.placement
      });

      this._popperOptions.modifiers = _extends({}, this._popperOptions.modifiers, {
        arrow: _extends({}, this._popperOptions.modifiers && this._popperOptions.modifiers.arrow, {
          element: options.arrowSelector
        }),
        offset: _extends({}, this._popperOptions.modifiers && this._popperOptions.modifiers.offset, {
          offset: options.offset || this._popperOptions.modifiers && this._popperOptions.modifiers.offset && this._popperOptions.modifiers.offset.offset || options.offset
        })
      });

      if (options.boundariesElement) {
        this._popperOptions.modifiers.preventOverflow = {
          boundariesElement: options.boundariesElement
        };
      }

      this.popperInstance = new popper_js__WEBPACK_IMPORTED_MODULE_0__["default"](reference, tooltipNode, this._popperOptions);

      this._tooltipNode = tooltipNode;

      return this;
    }
  }, {
    key: '_hide',
    value: function _hide() /*reference, options*/{
      // don't hide if it's already hidden
      if (!this._isOpen) {
        return this;
      }

      this._isOpen = false;

      // hide tooltipNode
      this._tooltipNode.style.visibility = 'hidden';
      this._tooltipNode.setAttribute('aria-hidden', 'true');

      return this;
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      var _this = this;

      // remove event listeners first to prevent any unexpected behaviour
      this._events.forEach(function (_ref) {
        var func = _ref.func,
            event = _ref.event;

        _this.reference.removeEventListener(event, func);
      });
      this._events = [];

      if (this._tooltipNode) {
        this._hide();

        // destroy instance
        this.popperInstance.destroy();

        // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
        if (!this.popperInstance.options.removeOnDestroy) {
          this._tooltipNode.parentNode.removeChild(this._tooltipNode);
          this._tooltipNode = null;
        }
      }
      return this;
    }
  }, {
    key: '_findContainer',
    value: function _findContainer(container, reference) {
      // if container is a query, get the relative element
      if (typeof container === 'string') {
        container = window.document.querySelector(container);
      } else if (container === false) {
        // if container is `false`, set it to reference parent
        container = reference.parentNode;
      }
      return container;
    }

    /**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltipNode
     * @param {HTMLElement|String|false} container
     */

  }, {
    key: '_append',
    value: function _append(tooltipNode, container) {
      container.appendChild(tooltipNode);
    }
  }, {
    key: '_setEventListeners',
    value: function _setEventListeners(reference, events, options) {
      var _this2 = this;

      var directEvents = [];
      var oppositeEvents = [];

      events.forEach(function (event) {
        switch (event) {
          case 'hover':
            directEvents.push('mouseenter');
            oppositeEvents.push('mouseleave');
            break;
          case 'focus':
            directEvents.push('focus');
            oppositeEvents.push('blur');
            break;
          case 'click':
            directEvents.push('click');
            oppositeEvents.push('click');
            break;
        }
      });

      // schedule show tooltip
      directEvents.forEach(function (event) {
        var func = function func(evt) {
          if (_this2._isOpening === true) {
            return;
          }
          evt.usedByTooltip = true;
          _this2._scheduleShow(reference, options.delay, options, evt);
        };
        _this2._events.push({ event: event, func: func });
        reference.addEventListener(event, func);
      });

      // schedule hide tooltip
      oppositeEvents.forEach(function (event) {
        var func = function func(evt) {
          if (evt.usedByTooltip === true) {
            return;
          }
          _this2._scheduleHide(reference, options.delay, options, evt);
        };
        _this2._events.push({ event: event, func: func });
        reference.addEventListener(event, func);
        if (event === 'click' && options.closeOnClickOutside) {
          document.addEventListener('mousedown', function (e) {
            if (!_this2._isOpening) {
              return;
            }
            var popper = _this2.popperInstance.popper;
            if (reference.contains(e.target) || popper.contains(e.target)) {
              return;
            }
            func(e);
          }, true);
        }
      });
    }
  }, {
    key: '_scheduleShow',
    value: function _scheduleShow(reference, delay, options /*, evt */) {
      var _this3 = this;

      this._isOpening = true;
      // defaults to 0
      var computedDelay = delay && delay.show || delay || 0;
      this._showTimeout = window.setTimeout(function () {
        return _this3._show(reference, options);
      }, computedDelay);
    }
  }, {
    key: '_scheduleHide',
    value: function _scheduleHide(reference, delay, options, evt) {
      var _this4 = this;

      this._isOpening = false;
      // defaults to 0
      var computedDelay = delay && delay.hide || delay || 0;
      window.clearTimeout(this._showTimeout);
      window.setTimeout(function () {
        if (_this4._isOpen === false) {
          return;
        }
        if (!document.body.contains(_this4._tooltipNode)) {
          return;
        }

        // if we are hiding because of a mouseleave, we must check that the new
        // reference isn't the tooltip, because in this case we don't want to hide it
        if (evt.type === 'mouseleave') {
          var isSet = _this4._setTooltipNodeEvent(evt, reference, delay, options);

          // if we set the new event, don't hide the tooltip yet
          // the new event will take care to hide it if necessary
          if (isSet) {
            return;
          }
        }

        _this4._hide(reference, options);
      }, computedDelay);
    }
  }, {
    key: '_updateTitleContent',
    value: function _updateTitleContent(title) {
      if (typeof this._tooltipNode === 'undefined') {
        if (typeof this.options.title !== 'undefined') {
          this.options.title = title;
        }
        return;
      }
      var titleNode = this._tooltipNode.querySelector(this.options.innerSelector);
      this._clearTitleContent(titleNode, this.options.html, this.reference.getAttribute('title') || this.options.title);
      this._addTitleContent(this.reference, title, this.options.html, titleNode);
      this.options.title = title;
      this.popperInstance.update();
    }
  }, {
    key: '_clearTitleContent',
    value: function _clearTitleContent(titleNode, allowHtml, lastTitle) {
      if (lastTitle.nodeType === 1 || lastTitle.nodeType === 11) {
        allowHtml && titleNode.removeChild(lastTitle);
      } else {
        allowHtml ? titleNode.innerHTML = '' : titleNode.textContent = '';
      }
    }
  }]);
  return Tooltip;
}();

/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */


var _initialiseProps = function _initialiseProps() {
  var _this5 = this;

  this.show = function () {
    return _this5._show(_this5.reference, _this5.options);
  };

  this.hide = function () {
    return _this5._hide();
  };

  this.dispose = function () {
    return _this5._dispose();
  };

  this.toggle = function () {
    if (_this5._isOpen) {
      return _this5.hide();
    } else {
      return _this5.show();
    }
  };

  this.updateTitleContent = function (title) {
    return _this5._updateTitleContent(title);
  };

  this._events = [];

  this._setTooltipNodeEvent = function (evt, reference, delay, options) {
    var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget;

    var callback = function callback(evt2) {
      var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget;

      // Remove event listener after call
      _this5._tooltipNode.removeEventListener(evt.type, callback);

      // If the new reference is not the reference element
      if (!reference.contains(relatedreference2)) {
        // Schedule to hide tooltip
        _this5._scheduleHide(reference, options.delay, options, evt2);
      }
    };

    if (_this5._tooltipNode.contains(relatedreference)) {
      // listen to mouseleave on the tooltip element to be able to hide the tooltip
      _this5._tooltipNode.addEventListener(evt.type, callback);
      return true;
    }

    return false;
  };
};

/* harmony default export */ __webpack_exports__["default"] = (Tooltip);
//# sourceMappingURL=tooltip.js.map


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/wnumb/wNumb.js":
/*!*************************************!*\
  !*** ./node_modules/wnumb/wNumb.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function() {
  "use strict";

  var FormatOptions = [
    "decimals",
    "thousand",
    "mark",
    "prefix",
    "suffix",
    "encoder",
    "decoder",
    "negativeBefore",
    "negative",
    "edit",
    "undo"
  ];

  // General

  // Reverse a string
  function strReverse(a) {
    return a
      .split("")
      .reverse()
      .join("");
  }

  // Check if a string starts with a specified prefix.
  function strStartsWith(input, match) {
    return input.substring(0, match.length) === match;
  }

  // Check is a string ends in a specified suffix.
  function strEndsWith(input, match) {
    return input.slice(-1 * match.length) === match;
  }

  // Throw an error if formatting options are incompatible.
  function throwEqualError(F, a, b) {
    if ((F[a] || F[b]) && F[a] === F[b]) {
      throw new Error(a);
    }
  }

  // Check if a number is finite and not NaN
  function isValidNumber(input) {
    return typeof input === "number" && isFinite(input);
  }

  // Provide rounding-accurate toFixed method.
  // Borrowed: http://stackoverflow.com/a/21323330/775265
  function toFixed(value, exp) {
    value = value.toString().split("e");
    value = Math.round(+(value[0] + "e" + (value[1] ? +value[1] + exp : exp)));
    value = value.toString().split("e");
    return (+(value[0] + "e" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);
  }

  // Formatting

  // Accept a number as input, output formatted string.
  function formatTo(
    decimals,
    thousand,
    mark,
    prefix,
    suffix,
    encoder,
    decoder,
    negativeBefore,
    negative,
    edit,
    undo,
    input
  ) {
    var originalInput = input,
      inputIsNegative,
      inputPieces,
      inputBase,
      inputDecimals = "",
      output = "";

    // Apply user encoder to the input.
    // Expected outcome: number.
    if (encoder) {
      input = encoder(input);
    }

    // Stop if no valid number was provided, the number is infinite or NaN.
    if (!isValidNumber(input)) {
      return false;
    }

    // Rounding away decimals might cause a value of -0
    // when using very small ranges. Remove those cases.
    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {
      input = 0;
    }

    // Formatting is done on absolute numbers,
    // decorated by an optional negative symbol.
    if (input < 0) {
      inputIsNegative = true;
      input = Math.abs(input);
    }

    // Reduce the number of decimals to the specified option.
    if (decimals !== false) {
      input = toFixed(input, decimals);
    }

    // Transform the number into a string, so it can be split.
    input = input.toString();

    // Break the number on the decimal separator.
    if (input.indexOf(".") !== -1) {
      inputPieces = input.split(".");

      inputBase = inputPieces[0];

      if (mark) {
        inputDecimals = mark + inputPieces[1];
      }
    } else {
      // If it isn't split, the entire number will do.
      inputBase = input;
    }

    // Group numbers in sets of three.
    if (thousand) {
      inputBase = strReverse(inputBase).match(/.{1,3}/g);
      inputBase = strReverse(inputBase.join(strReverse(thousand)));
    }

    // If the number is negative, prefix with negation symbol.
    if (inputIsNegative && negativeBefore) {
      output += negativeBefore;
    }

    // Prefix the number
    if (prefix) {
      output += prefix;
    }

    // Normal negative option comes after the prefix. Defaults to '-'.
    if (inputIsNegative && negative) {
      output += negative;
    }

    // Append the actual number.
    output += inputBase;
    output += inputDecimals;

    // Apply the suffix.
    if (suffix) {
      output += suffix;
    }

    // Run the output through a user-specified post-formatter.
    if (edit) {
      output = edit(output, originalInput);
    }

    // All done.
    return output;
  }

  // Accept a sting as input, output decoded number.
  function formatFrom(
    decimals,
    thousand,
    mark,
    prefix,
    suffix,
    encoder,
    decoder,
    negativeBefore,
    negative,
    edit,
    undo,
    input
  ) {
    var originalInput = input,
      inputIsNegative,
      output = "";

    // User defined pre-decoder. Result must be a non empty string.
    if (undo) {
      input = undo(input);
    }

    // Test the input. Can't be empty.
    if (!input || typeof input !== "string") {
      return false;
    }

    // If the string starts with the negativeBefore value: remove it.
    // Remember is was there, the number is negative.
    if (negativeBefore && strStartsWith(input, negativeBefore)) {
      input = input.replace(negativeBefore, "");
      inputIsNegative = true;
    }

    // Repeat the same procedure for the prefix.
    if (prefix && strStartsWith(input, prefix)) {
      input = input.replace(prefix, "");
    }

    // And again for negative.
    if (negative && strStartsWith(input, negative)) {
      input = input.replace(negative, "");
      inputIsNegative = true;
    }

    // Remove the suffix.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice
    if (suffix && strEndsWith(input, suffix)) {
      input = input.slice(0, -1 * suffix.length);
    }

    // Remove the thousand grouping.
    if (thousand) {
      input = input.split(thousand).join("");
    }

    // Set the decimal separator back to period.
    if (mark) {
      input = input.replace(mark, ".");
    }

    // Prepend the negative symbol.
    if (inputIsNegative) {
      output += "-";
    }

    // Add the number
    output += input;

    // Trim all non-numeric characters (allow '.' and '-');
    output = output.replace(/[^0-9\.\-.]/g, "");

    // The value contains no parse-able number.
    if (output === "") {
      return false;
    }

    // Covert to number.
    output = Number(output);

    // Run the user-specified post-decoder.
    if (decoder) {
      output = decoder(output);
    }

    // Check is the output is valid, otherwise: return false.
    if (!isValidNumber(output)) {
      return false;
    }

    return output;
  }

  // Framework

  // Validate formatting options
  function validate(inputOptions) {
    var i,
      optionName,
      optionValue,
      filteredOptions = {};

    if (inputOptions["suffix"] === undefined) {
      inputOptions["suffix"] = inputOptions["postfix"];
    }

    for (i = 0; i < FormatOptions.length; i += 1) {
      optionName = FormatOptions[i];
      optionValue = inputOptions[optionName];

      if (optionValue === undefined) {
        // Only default if negativeBefore isn't set.
        if (optionName === "negative" && !filteredOptions.negativeBefore) {
          filteredOptions[optionName] = "-";
          // Don't set a default for mark when 'thousand' is set.
        } else if (optionName === "mark" && filteredOptions.thousand !== ".") {
          filteredOptions[optionName] = ".";
        } else {
          filteredOptions[optionName] = false;
        }

        // Floating points in JS are stable up to 7 decimals.
      } else if (optionName === "decimals") {
        if (optionValue >= 0 && optionValue < 8) {
          filteredOptions[optionName] = optionValue;
        } else {
          throw new Error(optionName);
        }

        // These options, when provided, must be functions.
      } else if (
        optionName === "encoder" ||
        optionName === "decoder" ||
        optionName === "edit" ||
        optionName === "undo"
      ) {
        if (typeof optionValue === "function") {
          filteredOptions[optionName] = optionValue;
        } else {
          throw new Error(optionName);
        }

        // Other options are strings.
      } else {
        if (typeof optionValue === "string") {
          filteredOptions[optionName] = optionValue;
        } else {
          throw new Error(optionName);
        }
      }
    }

    // Some values can't be extracted from a
    // string if certain combinations are present.
    throwEqualError(filteredOptions, "mark", "thousand");
    throwEqualError(filteredOptions, "prefix", "negative");
    throwEqualError(filteredOptions, "prefix", "negativeBefore");

    return filteredOptions;
  }

  // Pass all options as function arguments
  function passAll(options, method, input) {
    var i,
      args = [];

    // Add all options in order of FormatOptions
    for (i = 0; i < FormatOptions.length; i += 1) {
      args.push(options[FormatOptions[i]]);
    }

    // Append the input, then call the method, presenting all
    // options as arguments.
    args.push(input);
    return method.apply("", args);
  }

  function wNumb(options) {
    if (!(this instanceof wNumb)) {
      return new wNumb(options);
    }

    if (typeof options !== "object") {
      return;
    }

    options = validate(options);

    // Call 'formatTo' with proper arguments.
    this.to = function(input) {
      return passAll(options, formatTo, input);
    };

    // Call 'formatFrom' with proper arguments.
    this.from = function(input) {
      return passAll(options, formatFrom, input);
    };
  }

  return wNumb;
});


/***/ }),

/***/ "./resources/assets/js/global/components/base/app.js":
/*!***********************************************************!*\
  !*** ./resources/assets/js/global/components/base/app.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @class KApp
 */

var KTApp = function () {
  /** @type {object} colors State colors **/
  var colors = {};

  var _initTooltip = function initTooltip(el) {
    var skin = el.data('skin') ? 'tooltip-' + el.data('skin') : '';
    var width = el.data('width') === 'auto' ? 'tooltop-auto-width' : '';
    var triggerValue = el.data('trigger') ? el.data('trigger') : 'hover';
    var placement = el.data('placement') ? el.data('placement') : 'left';
    el.tooltip({
      trigger: triggerValue,
      template: '<div class="tooltip ' + skin + ' ' + width + '" role="tooltip">\
                <div class="arrow"></div>\
                <div class="tooltip-inner"></div>\
            </div>'
    });
  };

  var _initTooltips = function initTooltips() {
    // init bootstrap tooltips
    $('[data-toggle="tooltip"]').each(function () {
      _initTooltip($(this));
    });
  };

  var _initPopover = function initPopover(el) {
    var skin = el.data('skin') ? 'popover-' + el.data('skin') : '';
    var triggerValue = el.data('trigger') ? el.data('trigger') : 'hover';
    el.popover({
      trigger: triggerValue,
      template: '\
            <div class="popover ' + skin + '" role="tooltip">\
                <div class="arrow"></div>\
                <h3 class="popover-header"></h3>\
                <div class="popover-body"></div>\
            </div>'
    });
  };

  var _initPopovers = function initPopovers() {
    // init bootstrap popover
    $('[data-toggle="popover"]').each(function () {
      _initPopover($(this));
    });
  };

  var initFileInput = function initFileInput() {
    // init bootstrap popover
    $('.custom-file-input').on('change', function () {
      var fileName = $(this).val();
      $(this).next('.custom-file-label').addClass("selected").html(fileName);
    });
  };

  var _initPortlet = function initPortlet(el, options) {
    // init portlet tools
    var el = $(el);
    var portlet = new KTPortlet(el[0], options);
  };

  var _initPortlets = function initPortlets() {
    // init portlet tools
    $('[data-ktportlet="true"]').each(function () {
      var el = $(this);

      if (el.data('data-ktportlet-initialized') !== true) {
        _initPortlet(el, {});

        el.data('data-ktportlet-initialized', true);
      }
    });
  };

  var initScroll = function initScroll() {
    $('[data-scroll="true"]').each(function () {
      var el = $(this);
      KTUtil.scrollInit(this, {
        mobileNativeScroll: true,
        handleWindowResize: true,
        rememberPosition: el.data('remember-position') == 'true' ? true : false,
        height: function height() {
          if (KTUtil.isInResponsiveRange('tablet-and-mobile') && el.data('mobile-height')) {
            return el.data('mobile-height');
          } else {
            return el.data('height');
          }
        }
      });
    });
  };

  var initAlerts = function initAlerts() {
    // init bootstrap popover
    $('body').on('click', '[data-close=alert]', function () {
      $(this).closest('.alert').hide();
    });
  };

  var _initSticky = function initSticky() {
    var sticky = new Sticky('[data-sticky="true"]');
  };

  var _initAbsoluteDropdown = function initAbsoluteDropdown(context) {
    var dropdownMenu;

    if (!context) {
      return;
    }

    $('body').on('show.bs.dropdown', context, function (e) {
      dropdownMenu = $(e.target).find('.dropdown-menu');
      $('body').append(dropdownMenu.detach());
      dropdownMenu.css('display', 'block');
      dropdownMenu.position({
        'my': 'right top',
        'at': 'right bottom',
        'of': $(e.relatedTarget)
      });
    }).on('hide.bs.dropdown', context, function (e) {
      $(e.target).append(dropdownMenu.detach());
      dropdownMenu.hide();
    });
  };

  var initAbsoluteDropdowns = function initAbsoluteDropdowns() {
    $('body').on('show.bs.dropdown', function (e) {
      if ($(e.target).find("[data-attach='body']").length === 0) {
        return;
      }

      var dropdownMenu = $(e.target).find('.dropdown-menu');
      $('body').append(dropdownMenu.detach());
      dropdownMenu.css('display', 'block');
      dropdownMenu.position({
        'my': 'right top',
        'at': 'right bottom',
        'of': $(e.relatedTarget)
      });
    });
    $('body').on('hide.bs.dropdown', function (e) {
      if ($(e.target).find("[data-attach='body']").length === 0) {
        return;
      }

      var dropdownMenu = $(e.target).find('.dropdown-menu');
      $(e.target).append(dropdownMenu.detach());
      dropdownMenu.hide();
    });
  };

  return {
    init: function init(options) {
      if (options && options.colors) {
        colors = options.colors;
      }

      KTApp.initComponents();
    },
    initComponents: function initComponents() {
      initScroll();

      _initTooltips();

      _initPopovers();

      initAlerts();

      _initPortlets();

      initFileInput();

      _initSticky();

      initAbsoluteDropdowns();
    },
    initTooltips: function initTooltips() {
      _initTooltips();
    },
    initTooltip: function initTooltip(el) {
      _initTooltip(el);
    },
    initPopovers: function initPopovers() {
      _initPopovers();
    },
    initPopover: function initPopover(el) {
      _initPopover(el);
    },
    initPortlet: function initPortlet(el, options) {
      _initPortlet(el, options);
    },
    initPortlets: function initPortlets() {
      _initPortlets();
    },
    initSticky: function initSticky() {
      _initSticky();
    },
    initAbsoluteDropdown: function initAbsoluteDropdown(context) {
      _initAbsoluteDropdown(context);
    },
    block: function block(target, options) {
      var el = $(target);
      options = $.extend(true, {
        opacity: 0.05,
        overlayColor: '#000000',
        type: '',
        size: '',
        state: 'brand',
        centerX: true,
        centerY: true,
        message: '',
        shadow: true,
        width: 'auto'
      }, options);
      var html;
      var version = options.type ? 'spinner--' + options.type : '';
      var state = options.state ? 'spinner--' + options.state : '';
      var size = options.size ? 'spinner--' + options.size : '';
      var spinner = '<div class="spinner ' + version + ' ' + state + ' ' + size + '"></div';

      if (options.message && options.message.length > 0) {
        var classes = 'blockui ' + (options.shadow === false ? 'blockui' : '');
        html = '<div class="' + classes + '"><span>' + options.message + '</span><span>' + spinner + '</span></div>';
        var el = document.createElement('div');
        KTUtil.get('body').prepend(el);
        KTUtil.addClass(el, classes);
        el.innerHTML = '<span>' + options.message + '</span><span>' + spinner + '</span>';
        options.width = KTUtil.actualWidth(el) + 10;
        KTUtil.remove(el);

        if (target == 'body') {
          html = '<div class="' + classes + '" style="margin-left:-' + options.width / 2 + 'px;"><span>' + options.message + '</span><span>' + spinner + '</span></div>';
        }
      } else {
        html = spinner;
      }

      var params = {
        message: html,
        centerY: options.centerY,
        centerX: options.centerX,
        css: {
          top: '30%',
          left: '50%',
          border: '0',
          padding: '0',
          backgroundColor: 'none',
          width: options.width
        },
        overlayCSS: {
          backgroundColor: options.overlayColor,
          opacity: options.opacity,
          cursor: 'wait',
          zIndex: '10'
        },
        onUnblock: function onUnblock() {
          if (el && el[0]) {
            KTUtil.css(el[0], 'position', '');
            KTUtil.css(el[0], 'zoom', '');
          }
        }
      };

      if (target == 'body') {
        params.css.top = '50%';
        $.blockUI(params);
      } else {
        var el = $(target);
        el.block(params);
      }
    },
    unblock: function unblock(target) {
      if (target && target != 'body') {
        $(target).unblock();
      } else {
        $.unblockUI();
      }
    },
    blockPage: function blockPage(options) {
      return KTApp.block('body', options);
    },
    unblockPage: function unblockPage() {
      return KTApp.unblock('body');
    },
    progress: function progress(target, options) {
      var skin = options && options.skin ? options.skin : 'light';
      var alignment = options && options.alignment ? options.alignment : 'right';
      var size = options && options.size ? ' spinner--' + options.size : '';
      var classes = 'spinner ' + 'spinner--' + skin + ' spinner--' + alignment + size;
      KTApp.unprogress(target);
      KTUtil.attr(target, 'disabled', true);
      $(target).addClass(classes);
      $(target).data('progress-classes', classes);
    },
    unprogress: function unprogress(target) {
      $(target).removeClass($(target).data('progress-classes'));
      KTUtil.removeAttr(target, 'disabled');
    },
    getStateColor: function getStateColor(name) {
      return colors["state"][name];
    },
    getBaseColor: function getBaseColor(type, level) {
      return colors["base"][type][level - 1];
    }
  };
}(); // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTApp;
}

var KTAppOptions = {
  "colors": {
    "state": {
      "brand": "#007cc3",
      "metal": "#c4c5d6",
      "light": "#ffffff",
      "accent": "#00c5dc",
      "primary": "#007cc3",
      "success": "#34bfa3",
      "info": "#36a3f7",
      "warning": "#ffb822",
      "danger": "#fd3995",
      "focus": "#1d4670"
    },
    "base": {
      "label": ["#c5cbe3", "#a1a8c3", "#3d4465", "#3e4466"],
      "shape": ["#f0f3ff", "#d9dffa", "#afb4d4", "#646c9a"]
    }
  }
}; // Initialize KTApp class on document ready

$(document).ready(function () {
  KTApp.init(KTAppOptions);
});

/***/ }),

/***/ "./resources/assets/js/global/components/base/avatar.js":
/*!**************************************************************!*\
  !*** ./resources/assets/js/global/components/base/avatar.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// plugin setup
var KTAvatar = function KTAvatar(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (!element) {
    return;
  } // Default options


  var defaultOptions = {}; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Construct
     */
    construct: function construct(options) {
      if (KTUtil.data(element).has('avatar')) {
        the = KTUtil.data(element).get('avatar');
      } else {
        // reset menu
        Plugin.init(options); // build menu

        Plugin.build();
        KTUtil.data(element).set('avatar', the);
      }

      return the;
    },

    /**
     * Init avatar
     */
    init: function init(options) {
      the.element = element;
      the.events = [];
      the.input = KTUtil.find(element, 'input[type="file"]');
      the.holder = KTUtil.find(element, '.avatar__holder');
      the.cancel = KTUtil.find(element, '.avatar__cancel');
      the.src = KTUtil.css(the.holder, 'backgroundImage'); // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
    },

    /**
     * Build Form Wizard
     */
    build: function build() {
      // Handle avatar change
      KTUtil.addEvent(the.input, 'change', function (e) {
        e.preventDefault();

        if (the.input && the.input.files && the.input.files[0]) {
          var reader = new FileReader();

          reader.onload = function (e) {
            KTUtil.css(the.holder, 'background-image', 'url(' + e.target.result + ')');
          };

          reader.readAsDataURL(the.input.files[0]);
          KTUtil.addClass(the.element, 'avatar--changed');
        }
      }); // Handle avatar cancel

      KTUtil.addEvent(the.cancel, 'click', function (e) {
        e.preventDefault();
        KTUtil.removeClass(the.element, 'avatar--changed');
        KTUtil.css(the.holder, 'background-image', the.src);
        the.input.value = "";
      });
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name) {
      //KTUtil.triggerCustomEvent(name);
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the);
            }
          } else {
            return event.handler.call(this, the);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
      return the;
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Attach event
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };
  /**
   * Attach event that will be fired once
   */


  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; // Construct plugin


  Plugin.construct.apply(the, [options]);
  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTAvatar;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/dialog.js":
/*!**************************************************************!*\
  !*** ./resources/assets/js/global/components/base/dialog.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // plugin setup

var KTDialog = function KTDialog(options) {
  // Main object
  var the = this; // Get element object

  var element;
  var body = KTUtil.get('body'); // Default options

  var defaultOptions = {
    'placement': 'top center',
    'type': 'loader',
    'width': 100,
    'state': 'default',
    'message': 'Loading...'
  }; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Construct
     */
    construct: function construct(options) {
      Plugin.init(options);
      return the;
    },

    /**
     * Handles subtoggle click toggle
     */
    init: function init(options) {
      the.events = []; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
      the.state = false;
    },

    /**
     * Show dialog
     */
    show: function show() {
      Plugin.eventTrigger('show');
      element = document.createElement("DIV");
      KTUtil.setHTML(element, the.options.message);
      KTUtil.addClass(element, 'dialog dialog--shown');
      KTUtil.addClass(element, 'dialog--' + the.options.state);
      KTUtil.addClass(element, 'dialog--' + the.options.type);

      if (the.options.placement === 'top center') {
        KTUtil.addClass(element, 'dialog--top-center');
      }

      body.appendChild(element);
      the.state = 'shown';
      Plugin.eventTrigger('shown');
      return the;
    },

    /**
     * Hide dialog
     */
    hide: function hide() {
      if (element) {
        Plugin.eventTrigger('hide');
        element.remove();
        the.state = 'hidden';
        Plugin.eventTrigger('hidden');
      }

      return the;
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name) {
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the);
            }
          } else {
            return event.handler.call(this, the);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
      return the;
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Check shown state
   */


  the.shown = function () {
    return the.state == 'shown';
  };
  /**
   * Check hidden state
   */


  the.hidden = function () {
    return the.state == 'hidden';
  };
  /**
   * Show dialog
   */


  the.show = function () {
    return Plugin.show();
  };
  /**
   * Hide dialog
   */


  the.hide = function () {
    return Plugin.hide();
  };
  /**
   * Attach event
   * @returns {KTToggle}
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };
  /**
   * Attach event that will be fired once
   * @returns {KTToggle}
   */


  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; // Construct plugin


  Plugin.construct.apply(the, [options]);
  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTDialog;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/header.js":
/*!**************************************************************!*\
  !*** ./resources/assets/js/global/components/base/header.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTHeader = function KTHeader(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (element === undefined) {
    return;
  } // Default options


  var defaultOptions = {
    classic: false,
    offset: {
      mobile: 150,
      desktop: 200
    },
    minimize: {
      mobile: false,
      desktop: false
    }
  }; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Run plugin
     * @returns {KTHeader}
     */
    construct: function construct(options) {
      if (KTUtil.data(element).has('header')) {
        the = KTUtil.data(element).get('header');
      } else {
        // reset header
        Plugin.init(options); // build header

        Plugin.build();
        KTUtil.data(element).set('header', the);
      }

      return the;
    },

    /**
     * Handles subheader click toggle
     * @returns {KTHeader}
     */
    init: function init(options) {
      the.events = []; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
    },

    /**
     * Reset header
     * @returns {KTHeader}
     */
    build: function build() {
      var lastScrollTop = 0;
      var eventTriggerState = true;
      var viewportHeight = KTUtil.getViewPort().height;
      var documentHeight = KTUtil.getDocumentHeight();

      if (the.options.minimize.mobile === false && the.options.minimize.desktop === false) {
        return;
      }

      window.addEventListener('scroll', function () {
        var offset = 0,
            on,
            off,
            st;

        if (KTUtil.isInResponsiveRange('desktop')) {
          offset = the.options.offset.desktop;
          on = the.options.minimize.desktop.on;
          off = the.options.minimize.desktop.off;
        } else if (KTUtil.isInResponsiveRange('tablet-and-mobile')) {
          offset = the.options.offset.mobile;
          on = the.options.minimize.mobile.on;
          off = the.options.minimize.mobile.off;
        }

        st = KTUtil.getScrollTop();

        if (KTUtil.isInResponsiveRange('tablet-and-mobile') && the.options.classic && the.options.classic.mobile || KTUtil.isInResponsiveRange('desktop') && the.options.classic && the.options.classic.desktop) {
          if (st > offset) {
            // down scroll mode
            KTUtil.addClass(body, on);
            KTUtil.removeClass(body, off);

            if (eventTriggerState) {
              Plugin.eventTrigger('minimizeOn', the);
              eventTriggerState = false;
            }
          } else {
            // back scroll mode
            KTUtil.addClass(body, off);
            KTUtil.removeClass(body, on);

            if (eventTriggerState == false) {
              Plugin.eventTrigger('minimizeOff', the);
              eventTriggerState = true;
            }
          }
        } else {
          if (st > offset && lastScrollTop < st) {
            // down scroll mode
            KTUtil.addClass(body, on);
            KTUtil.removeClass(body, off);

            if (eventTriggerState) {
              Plugin.eventTrigger('minimizeOn', the);
              eventTriggerState = false;
            }
          } else {
            // back scroll mode
            KTUtil.addClass(body, off);
            KTUtil.removeClass(body, on);

            if (eventTriggerState == false) {
              Plugin.eventTrigger('minimizeOff', the);
              eventTriggerState = true;
            }
          }

          lastScrollTop = st;
        }
      });
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name, args) {
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the, args);
            }
          } else {
            return event.handler.call(this, the, args);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Register event
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  }; ///////////////////////////////
  // ** Plugin Construction ** //
  ///////////////////////////////
  // Run plugin


  Plugin.construct.apply(the, [options]); // Init done

  init = true; // Return plugin instance

  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTHeader;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/menu.js":
/*!************************************************************!*\
  !*** ./resources/assets/js/global/components/base/menu.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTMenu = function KTMenu(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (!element) {
    return;
  } // Default options


  var defaultOptions = {
    // scrollable area with Perfect Scroll
    scroll: {
      rememberPosition: false
    },
    // accordion submenu mode
    accordion: {
      slideSpeed: 200,
      // accordion toggle slide speed in milliseconds
      autoScroll: false,
      // enable auto scrolling(focus) to the clicked menu item
      autoScrollSpeed: 1200,
      expandAll: true // allow having multiple expanded accordions in the menu

    },
    // dropdown submenu mode
    dropdown: {
      timeout: 500 // timeout in milliseconds to show and hide the hoverable submenu dropdown

    }
  }; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Run plugin
     * @returns {KTMenu}
     */
    construct: function construct(options) {
      if (KTUtil.data(element).has('menu')) {
        the = KTUtil.data(element).get('menu');
      } else {
        // reset menu
        Plugin.init(options); // reset menu

        Plugin.reset(); // build menu

        Plugin.build();
        KTUtil.data(element).set('menu', the);
      }

      return the;
    },

    /**
     * Handles submenu click toggle
     * @returns {KTMenu}
     */
    init: function init(options) {
      the.events = [];
      the.eventHandlers = {}; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options); // pause menu

      the.pauseDropdownHoverTime = 0;
      the.uid = KTUtil.getUniqueID();
    },
    update: function update(options) {
      // merge default and user defined options
      the.options = KTUtil.deepExtend({}, defaultOptions, options); // pause menu

      the.pauseDropdownHoverTime = 0; // reset menu

      Plugin.reset();
      the.eventHandlers = {}; // build menu

      Plugin.build();
      KTUtil.data(element).set('menu', the);
    },
    reload: function reload() {
      // reset menu
      Plugin.reset(); // build menu

      Plugin.build(); // reset submenu props

      Plugin.resetSubmenuProps();
    },

    /**
     * Reset menu
     * @returns {KTMenu}
     */
    build: function build() {
      // General accordion submenu toggle
      the.eventHandlers['event_1'] = KTUtil.on(element, '.menu__toggle', 'click', Plugin.handleSubmenuAccordion); // Dropdown mode(hoverable)

      if (Plugin.getSubmenuMode() === 'dropdown' || Plugin.isConditionalSubmenuDropdown()) {
        // dropdown submenu - hover toggle
        the.eventHandlers['event_2'] = KTUtil.on(element, '[data-ktmenu-submenu-toggle="hover"]', 'mouseover', Plugin.handleSubmenuDrodownHoverEnter);
        the.eventHandlers['event_3'] = KTUtil.on(element, '[data-ktmenu-submenu-toggle="hover"]', 'mouseout', Plugin.handleSubmenuDrodownHoverExit); // dropdown submenu - click toggle

        the.eventHandlers['event_4'] = KTUtil.on(element, '[data-ktmenu-submenu-toggle="click"] > .menu__toggle, [data-ktmenu-submenu-toggle="click"] > .menu__link .menu__toggle', 'click', Plugin.handleSubmenuDropdownClick);
        the.eventHandlers['event_5'] = KTUtil.on(element, '[data-ktmenu-submenu-toggle="tab"] > .menu__toggle, [data-ktmenu-submenu-toggle="tab"] > .menu__link .menu__toggle', 'click', Plugin.handleSubmenuDropdownTabClick);
      } // handle link click


      the.eventHandlers['event_6'] = KTUtil.on(element, '.menu__item > .menu__link:not(.menu__toggle):not(.menu__link--toggle-skip)', 'click', Plugin.handleLinkClick); // Init scrollable menu

      if (the.options.scroll && the.options.scroll.height) {
        Plugin.scrollInit();
      }
    },

    /**
     * Reset menu
     * @returns {KTMenu}
     */
    reset: function reset() {
      KTUtil.off(element, 'click', the.eventHandlers['event_1']); // dropdown submenu - hover toggle

      KTUtil.off(element, 'mouseover', the.eventHandlers['event_2']);
      KTUtil.off(element, 'mouseout', the.eventHandlers['event_3']); // dropdown submenu - click toggle

      KTUtil.off(element, 'click', the.eventHandlers['event_4']);
      KTUtil.off(element, 'click', the.eventHandlers['event_5']); // handle link click

      KTUtil.off(element, 'click', the.eventHandlers['event_6']);
    },

    /**
     * Init scroll menu
     *
    */
    scrollInit: function scrollInit() {
      if (the.options.scroll && the.options.scroll.height) {
        KTUtil.scrollDestroy(element);
        KTUtil.scrollInit(element, {
          mobileNativeScroll: true,
          windowScroll: false,
          resetHeightOnDestroy: true,
          handleWindowResize: true,
          height: the.options.scroll.height,
          rememberPosition: the.options.scroll.rememberPosition
        });
      } else {
        KTUtil.scrollDestroy(element);
      }
    },

    /**
     * Update scroll menu
    */
    scrollUpdate: function scrollUpdate() {
      if (the.options.scroll && the.options.scroll.height) {
        KTUtil.scrollUpdate(element);
      }
    },

    /**
     * Scroll top
    */
    scrollTop: function scrollTop() {
      if (the.options.scroll && the.options.scroll.height) {
        KTUtil.scrollTop(element);
      }
    },

    /**
     * Get submenu mode for current breakpoint and menu state
     * @returns {KTMenu}
     */
    getSubmenuMode: function getSubmenuMode(el) {
      if (KTUtil.isInResponsiveRange('desktop')) {
        if (el && KTUtil.hasAttr(el, 'data-ktmenu-submenu-toggle') && KTUtil.attr(el, 'data-ktmenu-submenu-toggle') == 'hover') {
          return 'dropdown';
        }

        if (KTUtil.isset(the.options.submenu, 'desktop.state.body')) {
          if (KTUtil.hasClasses(body, the.options.submenu.desktop.state.body)) {
            return the.options.submenu.desktop.state.mode;
          } else {
            return the.options.submenu.desktop["default"];
          }
        } else if (KTUtil.isset(the.options.submenu, 'desktop')) {
          return the.options.submenu.desktop;
        }
      } else if (KTUtil.isInResponsiveRange('tablet') && KTUtil.isset(the.options.submenu, 'tablet')) {
        return the.options.submenu.tablet;
      } else if (KTUtil.isInResponsiveRange('mobile') && KTUtil.isset(the.options.submenu, 'mobile')) {
        return the.options.submenu.mobile;
      } else {
        return false;
      }
    },

    /**
     * Get submenu mode for current breakpoint and menu state
     * @returns {KTMenu}
     */
    isConditionalSubmenuDropdown: function isConditionalSubmenuDropdown() {
      if (KTUtil.isInResponsiveRange('desktop') && KTUtil.isset(the.options.submenu, 'desktop.state.body')) {
        return true;
      } else {
        return false;
      }
    },

    /**
     * Reset submenu attributes
     * @returns {KTMenu}
     */
    resetSubmenuProps: function resetSubmenuProps(e) {
      var submenus = KTUtil.findAll(element, '.menu__submenu');

      if (submenus) {
        for (var i = 0, len = submenus.length; i < len; i++) {
          KTUtil.css(submenus[0], 'display', '');
          KTUtil.css(submenus[0], 'overflow', '');
        }
      }
    },

    /**
     * Handles submenu hover toggle
     * @returns {KTMenu}
     */
    handleSubmenuDrodownHoverEnter: function handleSubmenuDrodownHoverEnter(e) {
      if (Plugin.getSubmenuMode(this) === 'accordion') {
        return;
      }

      if (the.resumeDropdownHover() === false) {
        return;
      }

      var item = this;

      if (item.getAttribute('data-hover') == '1') {
        item.removeAttribute('data-hover');
        clearTimeout(item.getAttribute('data-timeout'));
        item.removeAttribute('data-timeout');
      }

      Plugin.showSubmenuDropdown(item);
    },

    /**
     * Handles submenu hover toggle
     * @returns {KTMenu}
     */
    handleSubmenuDrodownHoverExit: function handleSubmenuDrodownHoverExit(e) {
      if (the.resumeDropdownHover() === false) {
        return;
      }

      if (Plugin.getSubmenuMode(this) === 'accordion') {
        return;
      }

      var item = this;
      var time = the.options.dropdown.timeout;
      var timeout = setTimeout(function () {
        if (item.getAttribute('data-hover') == '1') {
          Plugin.hideSubmenuDropdown(item, true);
        }
      }, time);
      item.setAttribute('data-hover', '1');
      item.setAttribute('data-timeout', timeout);
    },

    /**
     * Handles submenu click toggle
     * @returns {KTMenu}
     */
    handleSubmenuDropdownClick: function handleSubmenuDropdownClick(e) {
      if (Plugin.getSubmenuMode(this) === 'accordion') {
        return;
      }

      var item = this.closest('.menu__item');

      if (item.getAttribute('data-ktmenu-submenu-mode') == 'accordion') {
        return;
      }

      if (KTUtil.hasClass(item, 'menu__item--hover') === false) {
        KTUtil.addClass(item, 'menu__item--open-dropdown');
        Plugin.showSubmenuDropdown(item);
      } else {
        KTUtil.removeClass(item, 'menu__item--open-dropdown');
        Plugin.hideSubmenuDropdown(item, true);
      }

      e.preventDefault();
    },

    /**
     * Handles tab click toggle
     * @returns {KTMenu}
     */
    handleSubmenuDropdownTabClick: function handleSubmenuDropdownTabClick(e) {
      if (Plugin.getSubmenuMode(this) === 'accordion') {
        return;
      }

      var item = this.closest('.menu__item');

      if (item.getAttribute('data-ktmenu-submenu-mode') == 'accordion') {
        return;
      }

      if (KTUtil.hasClass(item, 'menu__item--hover') == false) {
        KTUtil.addClass(item, 'menu__item--open-dropdown');
        Plugin.showSubmenuDropdown(item);
      }

      e.preventDefault();
    },

    /**
     * Handles link click
     * @returns {KTMenu}
     */
    handleLinkClick: function handleLinkClick(e) {
      var submenu = this.closest('.menu__item.menu__item--submenu'); //

      var result = Plugin.eventTrigger('linkClick', this, e);

      if (result === false) {
        return;
      }

      if (submenu && Plugin.getSubmenuMode(submenu) === 'dropdown') {
        Plugin.hideSubmenuDropdowns();
      }
    },

    /**
     * Handles submenu dropdown close on link click
     * @returns {KTMenu}
     */
    handleSubmenuDropdownClose: function handleSubmenuDropdownClose(e, el) {
      // exit if its not submenu dropdown mode
      if (Plugin.getSubmenuMode(el) === 'accordion') {
        return;
      }

      var shown = element.querySelectorAll('.menu__item.menu__item--submenu.menu__item--hover:not(.menu__item--tabs)'); // check if currently clicked link's parent item ha

      if (shown.length > 0 && KTUtil.hasClass(el, 'menu__toggle') === false && el.querySelectorAll('.menu__toggle').length === 0) {
        // close opened dropdown menus
        for (var i = 0, len = shown.length; i < len; i++) {
          Plugin.hideSubmenuDropdown(shown[0], true);
        }
      }
    },

    /**
     * helper functions
     * @returns {KTMenu}
     */
    handleSubmenuAccordion: function handleSubmenuAccordion(e, el) {
      var query;
      var item = el ? el : this;

      if (Plugin.getSubmenuMode(el) === 'dropdown' && (query = item.closest('.menu__item'))) {
        if (query.getAttribute('data-ktmenu-submenu-mode') != 'accordion') {
          e.preventDefault();
          return;
        }
      }

      var li = item.closest('.menu__item');
      var submenu = KTUtil.child(li, '.menu__submenu, .menu__inner');

      if (KTUtil.hasClass(item.closest('.menu__item'), 'menu__item--open-always')) {
        return;
      }

      if (li && submenu) {
        e.preventDefault();
        var speed = the.options.accordion.slideSpeed;
        var hasClosables = false;

        if (KTUtil.hasClass(li, 'menu__item--open') === false) {
          // hide other accordions
          if (the.options.accordion.expandAll === false) {
            var subnav = item.closest('.menu__nav, .menu__subnav');
            var closables = KTUtil.children(subnav, '.menu__item.menu__item--open.menu__item--submenu:not(.menu__item--here):not(.menu__item--open-always)');

            if (subnav && closables) {
              for (var i = 0, len = closables.length; i < len; i++) {
                var el_ = closables[0];
                var submenu_ = KTUtil.child(el_, '.menu__submenu');

                if (submenu_) {
                  KTUtil.slideUp(submenu_, speed, function () {
                    Plugin.scrollUpdate();
                    KTUtil.removeClass(el_, 'menu__item--open');
                  });
                }
              }
            }
          }

          KTUtil.slideDown(submenu, speed, function () {
            Plugin.scrollToItem(item);
            Plugin.scrollUpdate();
            Plugin.eventTrigger('submenuToggle', submenu, e);
          });
          KTUtil.addClass(li, 'menu__item--open');
        } else {
          KTUtil.slideUp(submenu, speed, function () {
            Plugin.scrollToItem(item);
            Plugin.eventTrigger('submenuToggle', submenu, e);
          });
          KTUtil.removeClass(li, 'menu__item--open');
        }
      }
    },

    /**
     * scroll to item function
     * @returns {KTMenu}
     */
    scrollToItem: function scrollToItem(item) {
      // handle auto scroll for accordion submenus
      if (KTUtil.isInResponsiveRange('desktop') && the.options.accordion.autoScroll && element.getAttribute('data-ktmenu-scroll') !== '1') {
        KTUtil.scrollTo(item, the.options.accordion.autoScrollSpeed);
      }
    },

    /**
     * Hide submenu dropdown
     * @returns {KTMenu}
     */
    hideSubmenuDropdown: function hideSubmenuDropdown(item, classAlso) {
      // remove submenu activation class
      if (classAlso) {
        KTUtil.removeClass(item, 'menu__item--hover');
        KTUtil.removeClass(item, 'menu__item--active-tab');
      } // clear timeout


      item.removeAttribute('data-hover');

      if (item.getAttribute('data-ktmenu-dropdown-toggle-class')) {
        KTUtil.removeClass(body, item.getAttribute('data-ktmenu-dropdown-toggle-class'));
      }

      var timeout = item.getAttribute('data-timeout');
      item.removeAttribute('data-timeout');
      clearTimeout(timeout);
    },

    /**
     * Hide submenu dropdowns
     * @returns {KTMenu}
     */
    hideSubmenuDropdowns: function hideSubmenuDropdowns() {
      var items;

      if (items = element.querySelectorAll('.menu__item--submenu.menu__item--hover:not(.menu__item--tabs):not([data-ktmenu-submenu-toggle="tab"])')) {
        for (var j = 0, cnt = items.length; j < cnt; j++) {
          Plugin.hideSubmenuDropdown(items[j], true);
        }
      }
    },

    /**
     * helper functions
     * @returns {KTMenu}
     */
    showSubmenuDropdown: function showSubmenuDropdown(item) {
      // close active submenus
      var list = element.querySelectorAll('.menu__item--submenu.menu__item--hover, .menu__item--submenu.menu__item--active-tab');

      if (list) {
        for (var i = 0, len = list.length; i < len; i++) {
          var el = list[i];

          if (item !== el && el.contains(item) === false && item.contains(el) === false) {
            Plugin.hideSubmenuDropdown(el, true);
          }
        }
      } // add submenu activation class


      KTUtil.addClass(item, 'menu__item--hover');

      if (item.getAttribute('data-ktmenu-dropdown-toggle-class')) {
        KTUtil.addClass(body, item.getAttribute('data-ktmenu-dropdown-toggle-class'));
      }
    },

    /**
     * Handles submenu slide toggle
     * @returns {KTMenu}
     */
    createSubmenuDropdownClickDropoff: function createSubmenuDropdownClickDropoff(el) {
      var query;
      var zIndex = (query = KTUtil.child(el, '.menu__submenu') ? KTUtil.css(query, 'z-index') : 0) - 1;
      var dropoff = document.createElement('<div class="menu__dropoff" style="background: transparent; position: fixed; top: 0; bottom: 0; left: 0; right: 0; z-index: ' + zIndex + '"></div>');
      body.appendChild(dropoff);
      KTUtil.addEvent(dropoff, 'click', function (e) {
        e.stopPropagation();
        e.preventDefault();
        KTUtil.remove(this);
        Plugin.hideSubmenuDropdown(el, true);
      });
    },

    /**
     * Handles submenu hover toggle
     * @returns {KTMenu}
     */
    pauseDropdownHover: function pauseDropdownHover(time) {
      var date = new Date();
      the.pauseDropdownHoverTime = date.getTime() + time;
    },

    /**
     * Handles submenu hover toggle
     * @returns {KTMenu}
     */
    resumeDropdownHover: function resumeDropdownHover() {
      var date = new Date();
      return date.getTime() > the.pauseDropdownHoverTime ? true : false;
    },

    /**
     * Reset menu's current active item
     * @returns {KTMenu}
     */
    resetActiveItem: function resetActiveItem(item) {
      var list;
      var parents;
      list = element.querySelectorAll('.menu__item--active');

      for (var i = 0, len = list.length; i < len; i++) {
        var el = list[0];
        KTUtil.removeClass(el, 'menu__item--active');
        KTUtil.hide(KTUtil.child(el, '.menu__submenu'));
        parents = KTUtil.parents(el, '.menu__item--submenu') || [];

        for (var i_ = 0, len_ = parents.length; i_ < len_; i_++) {
          var el_ = parents[i];
          KTUtil.removeClass(el_, 'menu__item--open');
          KTUtil.hide(KTUtil.child(el_, '.menu__submenu'));
        }
      } // close open submenus


      if (the.options.accordion.expandAll === false) {
        if (list = element.querySelectorAll('.menu__item--open')) {
          for (var i = 0, len = list.length; i < len; i++) {
            KTUtil.removeClass(parents[0], 'menu__item--open');
          }
        }
      }
    },

    /**
     * Sets menu's active item
     * @returns {KTMenu}
     */
    setActiveItem: function setActiveItem(item) {
      // reset current active item
      Plugin.resetActiveItem();
      var parents = KTUtil.parents(item, '.menu__item--submenu') || [];

      for (var i = 0, len = parents.length; i < len; i++) {
        KTUtil.addClass(KTUtil.get(parents[i]), 'menu__item--open');
      }

      KTUtil.addClass(KTUtil.get(item), 'menu__item--active');
    },

    /**
     * Returns page breadcrumbs for the menu's active item
     * @returns {KTMenu}
     */
    getBreadcrumbs: function getBreadcrumbs(item) {
      var query;
      var breadcrumbs = [];
      var link = KTUtil.child(item, '.menu__link');
      breadcrumbs.push({
        text: query = KTUtil.child(link, '.menu__link-text') ? query.innerHTML : '',
        title: link.getAttribute('title'),
        href: link.getAttribute('href')
      });
      var parents = KTUtil.parents(item, '.menu__item--submenu');

      for (var i = 0, len = parents.length; i < len; i++) {
        var submenuLink = KTUtil.child(parents[i], '.menu__link');
        breadcrumbs.push({
          text: query = KTUtil.child(submenuLink, '.menu__link-text') ? query.innerHTML : '',
          title: submenuLink.getAttribute('title'),
          href: submenuLink.getAttribute('href')
        });
      }

      return breadcrumbs.reverse();
    },

    /**
     * Returns page title for the menu's active item
     * @returns {KTMenu}
     */
    getPageTitle: function getPageTitle(item) {
      var query;
      return query = KTUtil.child(item, '.menu__link-text') ? query.innerHTML : '';
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name, target, e) {
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, target, e);
            }
          } else {
            return event.handler.call(this, target, e);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
    },
    removeEvent: function removeEvent(name) {
      if (the.events[name]) {
        delete the.events[name];
      }
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Update scroll
   */


  the.scrollUpdate = function () {
    return Plugin.scrollUpdate();
  };
  /**
   * Re-init scroll
   */


  the.scrollReInit = function () {
    return Plugin.scrollInit();
  };
  /**
   * Scroll top
   */


  the.scrollTop = function () {
    return Plugin.scrollTop();
  };
  /**
   * Set active menu item
   */


  the.setActiveItem = function (item) {
    return Plugin.setActiveItem(item);
  };

  the.reload = function () {
    return Plugin.reload();
  };

  the.update = function (options) {
    return Plugin.update(options);
  };
  /**
   * Set breadcrumb for menu item
   */


  the.getBreadcrumbs = function (item) {
    return Plugin.getBreadcrumbs(item);
  };
  /**
   * Set page title for menu item
   */


  the.getPageTitle = function (item) {
    return Plugin.getPageTitle(item);
  };
  /**
   * Get submenu mode
   */


  the.getSubmenuMode = function (el) {
    return Plugin.getSubmenuMode(el);
  };
  /**
   * Hide dropdown
   * @returns {Object}
   */


  the.hideDropdown = function (item) {
    Plugin.hideSubmenuDropdown(item, true);
  };
  /**
   * Hide dropdowns
   * @returns {Object}
   */


  the.hideDropdowns = function () {
    Plugin.hideSubmenuDropdowns();
  };
  /**
   * Disable menu for given time
   * @returns {Object}
   */


  the.pauseDropdownHover = function (time) {
    Plugin.pauseDropdownHover(time);
  };
  /**
   * Disable menu for given time
   * @returns {Object}
   */


  the.resumeDropdownHover = function () {
    return Plugin.resumeDropdownHover();
  };
  /**
   * Register event
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };

  the.off = function (name) {
    return Plugin.removeEvent(name);
  };

  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; ///////////////////////////////
  // ** Plugin Construction ** //
  ///////////////////////////////
  // Run plugin


  Plugin.construct.apply(the, [options]); // Handle plugin on window resize

  KTUtil.addResizeHandler(function () {
    if (init) {
      the.reload();
    }
  }); // Init done

  init = true; // Return plugin instance

  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTMenu;
} // Plugin global lazy initialization


document.addEventListener("click", function (e) {
  var body = KTUtil.get('body');
  var query;

  if (query = body.querySelectorAll('.menu__nav .menu__item.menu__item--submenu.menu__item--hover:not(.menu__item--tabs)[data-ktmenu-submenu-toggle="click"]')) {
    for (var i = 0, len = query.length; i < len; i++) {
      var element = query[i].closest('.menu__nav').parentNode;

      if (element) {
        var the = KTUtil.data(element).get('menu');

        if (!the) {
          break;
        }

        if (!the || the.getSubmenuMode() !== 'dropdown') {
          break;
        }

        if (e.target !== element && element.contains(e.target) === false) {
          the.hideDropdowns();
        }
      }
    }
  }
});

/***/ }),

/***/ "./resources/assets/js/global/components/base/offcanvas.js":
/*!*****************************************************************!*\
  !*** ./resources/assets/js/global/components/base/offcanvas.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTOffcanvas = function KTOffcanvas(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (!element) {
    return;
  } // Default options


  var defaultOptions = {}; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    construct: function construct(options) {
      if (KTUtil.data(element).has('offcanvas')) {
        the = KTUtil.data(element).get('offcanvas');
      } else {
        // reset offcanvas
        Plugin.init(options); // build offcanvas

        Plugin.build();
        KTUtil.data(element).set('offcanvas', the);
      }

      return the;
    },
    init: function init(options) {
      the.events = []; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
      the.overlay;
      the.classBase = the.options.baseClass;
      the.classShown = the.classBase + '--on';
      the.classOverlay = the.classBase + '-overlay';
      the.state = KTUtil.hasClass(element, the.classShown) ? 'shown' : 'hidden';
    },
    build: function build() {
      // offcanvas toggle
      if (the.options.toggleBy) {
        if (typeof the.options.toggleBy === 'string') {
          KTUtil.addEvent(the.options.toggleBy, 'click', function (e) {
            e.preventDefault();
            Plugin.toggle();
          });
        } else if (the.options.toggleBy && the.options.toggleBy[0]) {
          if (the.options.toggleBy[0].target) {
            for (var i in the.options.toggleBy) {
              KTUtil.addEvent(the.options.toggleBy[i].target, 'click', function (e) {
                e.preventDefault();
                Plugin.toggle();
              });
            }
          } else {
            for (var i in the.options.toggleBy) {
              KTUtil.addEvent(the.options.toggleBy[i], 'click', function (e) {
                e.preventDefault();
                Plugin.toggle();
              });
            }
          }
        } else if (the.options.toggleBy && the.options.toggleBy.target) {
          KTUtil.addEvent(the.options.toggleBy.target, 'click', function (e) {
            e.preventDefault();
            Plugin.toggle();
          });
        }
      } // offcanvas close


      var closeBy = KTUtil.get(the.options.closeBy);

      if (closeBy) {
        KTUtil.addEvent(closeBy, 'click', function (e) {
          e.preventDefault();
          Plugin.hide();
        });
      } // Window resize


      KTUtil.addResizeHandler(function () {
        if (parseInt(KTUtil.css(element, 'left')) >= 0 || parseInt(KTUtil.css(element, 'right') >= 0) || KTUtil.css(element, 'position') != 'fixed') {
          KTUtil.css(element, 'opacity', '1');
        }
      });
    },
    isShown: function isShown(target) {
      return the.state == 'shown' ? true : false;
    },
    toggle: function toggle() {
      ;
      Plugin.eventTrigger('toggle');

      if (the.state == 'shown') {
        Plugin.hide(this);
      } else {
        Plugin.show(this);
      }
    },
    show: function show(target) {
      if (the.state == 'shown') {
        return;
      }

      Plugin.eventTrigger('beforeShow');
      Plugin.togglerClass(target, 'show'); // Offcanvas panel

      KTUtil.addClass(body, the.classShown);
      KTUtil.addClass(element, the.classShown);
      KTUtil.css(element, 'opacity', '1');
      the.state = 'shown';

      if (the.options.overlay) {
        the.overlay = KTUtil.insertAfter(document.createElement('DIV'), element);
        KTUtil.addClass(the.overlay, the.classOverlay);
        KTUtil.addEvent(the.overlay, 'click', function (e) {
          e.stopPropagation();
          e.preventDefault();
          Plugin.hide(target);
        });
      }

      Plugin.eventTrigger('afterShow');
    },
    hide: function hide(target) {
      if (the.state == 'hidden') {
        return;
      }

      Plugin.eventTrigger('beforeHide');
      Plugin.togglerClass(target, 'hide');
      KTUtil.removeClass(body, the.classShown);
      KTUtil.removeClass(element, the.classShown);
      the.state = 'hidden';

      if (the.options.overlay && the.overlay) {
        KTUtil.remove(the.overlay);
      }

      KTUtil.transitionEnd(element, function () {
        KTUtil.css(element, 'opacity', '0');
      });
      Plugin.eventTrigger('afterHide');
    },
    togglerClass: function togglerClass(target, mode) {
      // Toggler
      var id = KTUtil.attr(target, 'id');
      var toggleBy;

      if (the.options.toggleBy && the.options.toggleBy[0] && the.options.toggleBy[0].target) {
        for (var i in the.options.toggleBy) {
          if (the.options.toggleBy[i].target === id) {
            toggleBy = the.options.toggleBy[i];
          }
        }
      } else if (the.options.toggleBy && the.options.toggleBy.target) {
        toggleBy = the.options.toggleBy;
      }

      if (toggleBy) {
        var el = KTUtil.get(toggleBy.target);

        if (mode === 'show') {
          KTUtil.addClass(el, toggleBy.state);
        }

        if (mode === 'hide') {
          KTUtil.removeClass(el, toggleBy.state);
        }
      }
    },
    eventTrigger: function eventTrigger(name, args) {
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the, args);
            }
          } else {
            return event.handler.call(this, the, args);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  the.setDefaults = function (options) {
    defaultOptions = options;
  };

  the.isShown = function () {
    return Plugin.isShown();
  };

  the.hide = function () {
    return Plugin.hide();
  };

  the.show = function () {
    return Plugin.show();
  };

  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };

  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; ///////////////////////////////
  // ** Plugin Construction ** //
  ///////////////////////////////
  // Run plugin


  Plugin.construct.apply(the, [options]); // Init done

  init = true; // Return plugin instance

  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTOffcanvas;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/portlet.js":
/*!***************************************************************!*\
  !*** ./resources/assets/js/global/components/base/portlet.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // plugin setup

var KTPortlet = function KTPortlet(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (!element) {
    return;
  } // Default options


  var defaultOptions = {
    bodyToggleSpeed: 400,
    tooltips: true,
    tools: {
      toggle: {
        collapse: 'Collapse',
        expand: 'Expand'
      },
      reload: 'Reload',
      remove: 'Remove',
      fullscreen: {
        on: 'Fullscreen',
        off: 'Exit Fullscreen'
      }
    },
    sticky: {
      offset: 300,
      zIndex: 101
    }
  }; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Construct
     */
    construct: function construct(options) {
      if (KTUtil.data(element).has('portlet')) {
        the = KTUtil.data(element).get('portlet');
      } else {
        // reset menu
        Plugin.init(options); // build menu

        Plugin.build();
        KTUtil.data(element).set('portlet', the);
      }

      return the;
    },

    /**
     * Init portlet
     */
    init: function init(options) {
      the.element = element;
      the.events = []; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
      the.head = KTUtil.child(element, '.portlet__head');
      the.foot = KTUtil.child(element, '.portlet__foot');

      if (KTUtil.child(element, '.portlet__body')) {
        the.body = KTUtil.child(element, '.portlet__body');
      } else if (KTUtil.child(element, '.form')) {
        the.body = KTUtil.child(element, '.form');
      }
    },

    /**
     * Build Form Wizard
     */
    build: function build() {
      // Remove
      var remove = KTUtil.find(the.head, '[data-ktportlet-tool=remove]');

      if (remove) {
        KTUtil.addEvent(remove, 'click', function (e) {
          e.preventDefault();
          Plugin.remove();
        });
      } // Reload


      var reload = KTUtil.find(the.head, '[data-ktportlet-tool=reload]');

      if (reload) {
        KTUtil.addEvent(reload, 'click', function (e) {
          e.preventDefault();
          Plugin.reload();
        });
      } // Toggle


      var toggle = KTUtil.find(the.head, '[data-ktportlet-tool=toggle]');

      if (toggle) {
        KTUtil.addEvent(toggle, 'click', function (e) {
          e.preventDefault();
          Plugin.toggle();
        });
      } //== Fullscreen


      var fullscreen = KTUtil.find(the.head, '[data-ktportlet-tool=fullscreen]');

      if (fullscreen) {
        KTUtil.addEvent(fullscreen, 'click', function (e) {
          e.preventDefault();
          Plugin.fullscreen();
        });
      }

      Plugin.setupTooltips();
    },

    /**
     * Enable stickt mode
     */
    initSticky: function initSticky() {
      var lastScrollTop = 0;
      var offset = the.options.sticky.offset;

      if (!the.head) {
        return;
      }

      window.addEventListener('scroll', Plugin.onScrollSticky);
    },

    /**
     * Window scroll handle event for sticky portlet
     */
    onScrollSticky: function onScrollSticky(e) {
      var offset = the.options.sticky.offset;
      if (isNaN(offset)) return;
      var st = KTUtil.getScrollTop();

      if (st >= offset && KTUtil.hasClass(body, 'portlet--sticky') === false) {
        Plugin.eventTrigger('stickyOn');
        KTUtil.addClass(body, 'portlet--sticky');
        KTUtil.addClass(element, 'portlet--sticky');
        Plugin.updateSticky();
      } else if (st * 1.5 <= offset && KTUtil.hasClass(body, 'portlet--sticky')) {
        // back scroll mode
        Plugin.eventTrigger('stickyOff');
        KTUtil.removeClass(body, 'portlet--sticky');
        KTUtil.removeClass(element, 'portlet--sticky');
        Plugin.resetSticky();
      }
    },
    updateSticky: function updateSticky() {
      if (!the.head) {
        return;
      }

      var top;

      if (KTUtil.hasClass(body, 'portlet--sticky')) {
        if (the.options.sticky.position.top instanceof Function) {
          top = parseInt(the.options.sticky.position.top.call(this, the));
        } else {
          top = parseInt(the.options.sticky.position.top);
        }

        var left;

        if (the.options.sticky.position.left instanceof Function) {
          left = parseInt(the.options.sticky.position.left.call(this, the));
        } else {
          left = parseInt(the.options.sticky.position.left);
        }

        var right;

        if (the.options.sticky.position.right instanceof Function) {
          right = parseInt(the.options.sticky.position.right.call(this, the));
        } else {
          right = parseInt(the.options.sticky.position.right);
        }

        KTUtil.css(the.head, 'z-index', the.options.sticky.zIndex);
        KTUtil.css(the.head, 'top', top + 'px');
        KTUtil.css(the.head, 'left', left + 'px');
        KTUtil.css(the.head, 'right', right + 'px');
      }
    },
    resetSticky: function resetSticky() {
      if (!the.head) {
        return;
      }

      if (KTUtil.hasClass(body, 'portlet--sticky') === false) {
        KTUtil.css(the.head, 'z-index', '');
        KTUtil.css(the.head, 'top', '');
        KTUtil.css(the.head, 'left', '');
        KTUtil.css(the.head, 'right', '');
      }
    },

    /**
     * Remove portlet
     */
    remove: function remove() {
      if (Plugin.eventTrigger('beforeRemove') === false) {
        return;
      }

      if (KTUtil.hasClass(body, 'portlet--fullscreen') && KTUtil.hasClass(element, 'portlet--fullscreen')) {
        Plugin.fullscreen('off');
      }

      Plugin.removeTooltips();
      KTUtil.remove(element);
      Plugin.eventTrigger('afterRemove');
    },

    /**
     * Set content
     */
    setContent: function setContent(html) {
      if (html) {
        the.body.innerHTML = html;
      }
    },

    /**
     * Get body
     */
    getBody: function getBody() {
      return the.body;
    },

    /**
     * Get self
     */
    getSelf: function getSelf() {
      return element;
    },

    /**
     * Setup tooltips
     */
    setupTooltips: function setupTooltips() {
      if (the.options.tooltips) {
        var collapsed = KTUtil.hasClass(element, 'portlet--collapse') || KTUtil.hasClass(element, 'portlet--collapsed');
        var fullscreenOn = KTUtil.hasClass(body, 'portlet--fullscreen') && KTUtil.hasClass(element, 'portlet--fullscreen'); //== Remove

        var remove = KTUtil.find(the.head, '[data-ktportlet-tool=remove]');

        if (remove) {
          var placement = fullscreenOn ? 'bottom' : 'top';
          var tip = new Tooltip(remove, {
            title: the.options.tools.remove,
            placement: placement,
            offset: fullscreenOn ? '0,10px,0,0' : '0,5px',
            trigger: 'hover',
            template: '<div class="tooltip tooltip-portlet tooltip bs-tooltip-' + placement + '" role="tooltip">\
                            <div class="tooltip-arrow arrow"></div>\
                            <div class="tooltip-inner"></div>\
                        </div>'
          });
          KTUtil.data(remove).set('tooltip', tip);
        } //== Reload


        var reload = KTUtil.find(the.head, '[data-ktportlet-tool=reload]');

        if (reload) {
          var placement = fullscreenOn ? 'bottom' : 'top';
          var tip = new Tooltip(reload, {
            title: the.options.tools.reload,
            placement: placement,
            offset: fullscreenOn ? '0,10px,0,0' : '0,5px',
            trigger: 'hover',
            template: '<div class="tooltip tooltip-portlet tooltip bs-tooltip-' + placement + '" role="tooltip">\
                            <div class="tooltip-arrow arrow"></div>\
                            <div class="tooltip-inner"></div>\
                        </div>'
          });
          KTUtil.data(reload).set('tooltip', tip);
        } //== Toggle


        var toggle = KTUtil.find(the.head, '[data-ktportlet-tool=toggle]');

        if (toggle) {
          var placement = fullscreenOn ? 'bottom' : 'top';
          var tip = new Tooltip(toggle, {
            title: collapsed ? the.options.tools.toggle.expand : the.options.tools.toggle.collapse,
            placement: placement,
            offset: fullscreenOn ? '0,10px,0,0' : '0,5px',
            trigger: 'hover',
            template: '<div class="tooltip tooltip-portlet tooltip bs-tooltip-' + placement + '" role="tooltip">\
                            <div class="tooltip-arrow arrow"></div>\
                            <div class="tooltip-inner"></div>\
                        </div>'
          });
          KTUtil.data(toggle).set('tooltip', tip);
        } //== Fullscreen


        var fullscreen = KTUtil.find(the.head, '[data-ktportlet-tool=fullscreen]');

        if (fullscreen) {
          var placement = fullscreenOn ? 'bottom' : 'top';
          var tip = new Tooltip(fullscreen, {
            title: fullscreenOn ? the.options.tools.fullscreen.off : the.options.tools.fullscreen.on,
            placement: placement,
            offset: fullscreenOn ? '0,10px,0,0' : '0,5px',
            trigger: 'hover',
            template: '<div class="tooltip tooltip-portlet tooltip bs-tooltip-' + placement + '" role="tooltip">\
                            <div class="tooltip-arrow arrow"></div>\
                            <div class="tooltip-inner"></div>\
                        </div>'
          });
          KTUtil.data(fullscreen).set('tooltip', tip);
        }
      }
    },

    /**
     * Setup tooltips
     */
    removeTooltips: function removeTooltips() {
      if (the.options.tooltips) {
        //== Remove
        var remove = KTUtil.find(the.head, '[data-ktportlet-tool=remove]');

        if (remove && KTUtil.data(remove).has('tooltip')) {
          KTUtil.data(remove).get('tooltip').dispose();
        } //== Reload


        var reload = KTUtil.find(the.head, '[data-ktportlet-tool=reload]');

        if (reload && KTUtil.data(reload).has('tooltip')) {
          KTUtil.data(reload).get('tooltip').dispose();
        } //== Toggle


        var toggle = KTUtil.find(the.head, '[data-ktportlet-tool=toggle]');

        if (toggle && KTUtil.data(toggle).has('tooltip')) {
          KTUtil.data(toggle).get('tooltip').dispose();
        } //== Fullscreen


        var fullscreen = KTUtil.find(the.head, '[data-ktportlet-tool=fullscreen]');

        if (fullscreen && KTUtil.data(fullscreen).has('tooltip')) {
          KTUtil.data(fullscreen).get('tooltip').dispose();
        }
      }
    },

    /**
     * Reload
     */
    reload: function reload() {
      Plugin.eventTrigger('reload');
    },

    /**
     * Toggle
     */
    toggle: function toggle() {
      if (KTUtil.hasClass(element, 'portlet--collapse') || KTUtil.hasClass(element, 'portlet--collapsed')) {
        Plugin.expand();
      } else {
        Plugin.collapse();
      }
    },

    /**
     * Collapse
     */
    collapse: function collapse() {
      if (Plugin.eventTrigger('beforeCollapse') === false) {
        return;
      }

      KTUtil.slideUp(the.body, the.options.bodyToggleSpeed, function () {
        Plugin.eventTrigger('afterCollapse');
      });
      KTUtil.addClass(element, 'portlet--collapse');
      var toggle = KTUtil.find(the.head, '[data-ktportlet-tool=toggle]');

      if (toggle && KTUtil.data(toggle).has('tooltip')) {
        KTUtil.data(toggle).get('tooltip').updateTitleContent(the.options.tools.toggle.expand);
      }
    },

    /**
     * Expand
     */
    expand: function expand() {
      if (Plugin.eventTrigger('beforeExpand') === false) {
        return;
      }

      KTUtil.slideDown(the.body, the.options.bodyToggleSpeed, function () {
        Plugin.eventTrigger('afterExpand');
      });
      KTUtil.removeClass(element, 'portlet--collapse');
      KTUtil.removeClass(element, 'portlet--collapsed');
      var toggle = KTUtil.find(the.head, '[data-ktportlet-tool=toggle]');

      if (toggle && KTUtil.data(toggle).has('tooltip')) {
        KTUtil.data(toggle).get('tooltip').updateTitleContent(the.options.tools.toggle.collapse);
      }
    },

    /**
     * fullscreen
     */
    fullscreen: function fullscreen(mode) {
      var d = {};
      var speed = 300;

      if (mode === 'off' || KTUtil.hasClass(body, 'portlet--fullscreen') && KTUtil.hasClass(element, 'portlet--fullscreen')) {
        Plugin.eventTrigger('beforeFullscreenOff');
        KTUtil.removeClass(body, 'portlet--fullscreen');
        KTUtil.removeClass(element, 'portlet--fullscreen');
        Plugin.removeTooltips();
        Plugin.setupTooltips();

        if (the.foot) {
          KTUtil.css(the.body, 'margin-bottom', '');
          KTUtil.css(the.foot, 'margin-top', '');
        }

        Plugin.eventTrigger('afterFullscreenOff');
      } else {
        Plugin.eventTrigger('beforeFullscreenOn');
        KTUtil.addClass(element, 'portlet--fullscreen');
        KTUtil.addClass(body, 'portlet--fullscreen');
        Plugin.removeTooltips();
        Plugin.setupTooltips();

        if (the.foot) {
          var height1 = parseInt(KTUtil.css(the.foot, 'height'));
          var height2 = parseInt(KTUtil.css(the.foot, 'height')) + parseInt(KTUtil.css(the.head, 'height'));
          KTUtil.css(the.body, 'margin-bottom', height1 + 'px');
          KTUtil.css(the.foot, 'margin-top', '-' + height2 + 'px');
        }

        Plugin.eventTrigger('afterFullscreenOn');
      }
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name) {
      //KTUtil.triggerCustomEvent(name);
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the);
            }
          } else {
            return event.handler.call(this, the);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
      return the;
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Remove portlet
   * @returns {KTPortlet}
   */


  the.remove = function () {
    return Plugin.remove(html);
  };
  /**
   * Remove portlet
   * @returns {KTPortlet}
   */


  the.initSticky = function () {
    return Plugin.initSticky();
  };
  /**
   * Remove portlet
   * @returns {KTPortlet}
   */


  the.updateSticky = function () {
    return Plugin.updateSticky();
  };
  /**
   * Remove portlet
   * @returns {KTPortlet}
   */


  the.resetSticky = function () {
    return Plugin.resetSticky();
  };
  /**
   * Destroy sticky portlet
   */


  the.destroySticky = function () {
    Plugin.resetSticky();
    window.removeEventListener('scroll', Plugin.onScrollSticky);
  };
  /**
   * Reload portlet
   * @returns {KTPortlet}
   */


  the.reload = function () {
    return Plugin.reload();
  };
  /**
   * Set portlet content
   * @returns {KTPortlet}
   */


  the.setContent = function (html) {
    return Plugin.setContent(html);
  };
  /**
   * Toggle portlet
   * @returns {KTPortlet}
   */


  the.toggle = function () {
    return Plugin.toggle();
  };
  /**
   * Collapse portlet
   * @returns {KTPortlet}
   */


  the.collapse = function () {
    return Plugin.collapse();
  };
  /**
   * Expand portlet
   * @returns {KTPortlet}
   */


  the.expand = function () {
    return Plugin.expand();
  };
  /**
   * Fullscreen portlet
   * @returns {MPortlet}
   */


  the.fullscreen = function () {
    return Plugin.fullscreen('on');
  };
  /**
   * Fullscreen portlet
   * @returns {MPortlet}
   */


  the.unFullscreen = function () {
    return Plugin.fullscreen('off');
  };
  /**
   * Get portletbody
   * @returns {jQuery}
   */


  the.getBody = function () {
    return Plugin.getBody();
  };
  /**
   * Get portletbody
   * @returns {jQuery}
   */


  the.getSelf = function () {
    return Plugin.getSelf();
  };
  /**
   * Attach event
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };
  /**
   * Attach event that will be fired once
   */


  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; // Construct plugin


  Plugin.construct.apply(the, [options]);
  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTPortlet;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/scrolltop.js":
/*!*****************************************************************!*\
  !*** ./resources/assets/js/global/components/base/scrolltop.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTScrolltop = function KTScrolltop(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (!element) {
    return;
  } // Default options


  var defaultOptions = {
    offset: 300,
    speed: 600,
    toggleClass: 'scrolltop--on'
  }; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Run plugin
     * @returns {mscrolltop}
     */
    construct: function construct(options) {
      if (KTUtil.data(element).has('scrolltop')) {
        the = KTUtil.data(element).get('scrolltop');
      } else {
        // reset scrolltop
        Plugin.init(options); // build scrolltop

        Plugin.build();
        KTUtil.data(element).set('scrolltop', the);
      }

      return the;
    },

    /**
     * Handles subscrolltop click toggle
     * @returns {mscrolltop}
     */
    init: function init(options) {
      the.events = []; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
    },
    build: function build() {
      // handle window scroll
      if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
        window.addEventListener('touchend', function () {
          Plugin.handle();
        });
        window.addEventListener('touchcancel', function () {
          Plugin.handle();
        });
        window.addEventListener('touchleave', function () {
          Plugin.handle();
        });
      } else {
        window.addEventListener('scroll', function () {
          Plugin.handle();
        });
      } // handle button click


      KTUtil.addEvent(element, 'click', Plugin.scroll);
    },

    /**
     * Handles scrolltop click scrollTop
     */
    handle: function handle() {
      var pos = window.pageYOffset; // current vertical position

      if (pos > the.options.offset) {
        KTUtil.addClass(body, the.options.toggleClass);
      } else {
        KTUtil.removeClass(body, the.options.toggleClass);
      }
    },

    /**
     * Handles scrolltop click scrollTop
     */
    scroll: function scroll(e) {
      e.preventDefault();
      KTUtil.scrollTop(0, the.options.speed);
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name, args) {
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the, args);
            }
          } else {
            return event.handler.call(this, the, args);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Get subscrolltop mode
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };
  /**
   * Set scrolltop content
   * @returns {mscrolltop}
   */


  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; ///////////////////////////////
  // ** Plugin Construction ** //
  ///////////////////////////////
  // Run plugin


  Plugin.construct.apply(the, [options]); // Init done

  init = true; // Return plugin instance

  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTScrolltop;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/toggle.js":
/*!**************************************************************!*\
  !*** ./resources/assets/js/global/components/base/toggle.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // plugin setup

var KTToggle = function KTToggle(elementId, options) {
  // Main object
  var the = this;
  var init = false; // Get element object

  var element = KTUtil.get(elementId);
  var body = KTUtil.get('body');

  if (!element) {
    return;
  } // Default options


  var defaultOptions = {
    togglerState: '',
    targetState: ''
  }; ////////////////////////////
  // ** Private Methods  ** //
  ////////////////////////////

  var Plugin = {
    /**
     * Construct
     */
    construct: function construct(options) {
      if (KTUtil.data(element).has('toggle')) {
        the = KTUtil.data(element).get('toggle');
      } else {
        // reset menu
        Plugin.init(options); // build menu

        Plugin.build();
        KTUtil.data(element).set('toggle', the);
      }

      return the;
    },

    /**
     * Handles subtoggle click toggle
     */
    init: function init(options) {
      the.element = element;
      the.events = []; // merge default and user defined options

      the.options = KTUtil.deepExtend({}, defaultOptions, options);
      the.target = KTUtil.get(the.options.target);
      the.targetState = the.options.targetState;
      the.togglerState = the.options.togglerState;
      the.state = KTUtil.hasClasses(the.target, the.targetState) ? 'on' : 'off';
    },

    /**
     * Setup toggle
     */
    build: function build() {
      KTUtil.addEvent(element, 'mouseup', Plugin.toggle);
    },

    /**
     * Handles offcanvas click toggle
     */
    toggle: function toggle(e) {
      Plugin.eventTrigger('beforeToggle');

      if (the.state == 'off') {
        Plugin.toggleOn();
      } else {
        Plugin.toggleOff();
      }

      Plugin.eventTrigger('afterToggle');
      e.preventDefault();
      return the;
    },

    /**
     * Handles toggle click toggle
     */
    toggleOn: function toggleOn() {
      Plugin.eventTrigger('beforeOn');
      KTUtil.addClass(the.target, the.targetState);

      if (the.togglerState) {
        KTUtil.addClass(element, the.togglerState);
      }

      the.state = 'on';
      Plugin.eventTrigger('afterOn');
      Plugin.eventTrigger('toggle');
      return the;
    },

    /**
     * Handles toggle click toggle
     */
    toggleOff: function toggleOff() {
      Plugin.eventTrigger('beforeOff');
      KTUtil.removeClass(the.target, the.targetState);

      if (the.togglerState) {
        KTUtil.removeClass(element, the.togglerState);
      }

      the.state = 'off';
      Plugin.eventTrigger('afterOff');
      Plugin.eventTrigger('toggle');
      return the;
    },

    /**
     * Trigger events
     */
    eventTrigger: function eventTrigger(name) {
      for (var i = 0; i < the.events.length; i++) {
        var event = the.events[i];

        if (event.name == name) {
          if (event.one == true) {
            if (event.fired == false) {
              the.events[i].fired = true;
              return event.handler.call(this, the);
            }
          } else {
            return event.handler.call(this, the);
          }
        }
      }
    },
    addEvent: function addEvent(name, handler, one) {
      the.events.push({
        name: name,
        handler: handler,
        one: one,
        fired: false
      });
      return the;
    }
  }; //////////////////////////
  // ** Public Methods ** //
  //////////////////////////

  /**
   * Set default options 
   */

  the.setDefaults = function (options) {
    defaultOptions = options;
  };
  /**
   * Get toggle state 
   */


  the.getState = function () {
    return the.state;
  };
  /**
   * Toggle 
   */


  the.toggle = function () {
    return Plugin.toggle();
  };
  /**
   * Toggle on 
   */


  the.toggleOn = function () {
    return Plugin.toggleOn();
  };
  /**
   * Toggle off 
   */


  the.toggleOff = function () {
    return Plugin.toggleOff();
  };
  /**
   * Attach event
   * @returns {KTToggle}
   */


  the.on = function (name, handler) {
    return Plugin.addEvent(name, handler);
  };
  /**
   * Attach event that will be fired once
   * @returns {KTToggle}
   */


  the.one = function (name, handler) {
    return Plugin.addEvent(name, handler, true);
  }; // Construct plugin


  Plugin.construct.apply(the, [options]);
  return the;
}; // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTToggle;
}

/***/ }),

/***/ "./resources/assets/js/global/components/base/util.js":
/*!************************************************************!*\
  !*** ./resources/assets/js/global/components/base/util.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @class KTUtil  base utilize class that privides helper functions
 */
// Polyfills

/**
 * Element.matches() polyfill (simple version)
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
/**
 * Element.closest() polyfill
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
 */


if (!Element.prototype.closest) {
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }

  Element.prototype.closest = function (s) {
    var el = this;
    var ancestor = this;
    if (!document.documentElement.contains(el)) return null;

    do {
      if (ancestor.matches(s)) return ancestor;
      ancestor = ancestor.parentElement;
    } while (ancestor !== null);

    return null;
  };
}
/**
 * ChildNode.remove() polyfill
 * https://gomakethings.com/removing-an-element-from-the-dom-the-es6-way/
 * @author Chris Ferdinandi
 * @license MIT
 */


(function (elem) {
  for (var i = 0; i < elem.length; i++) {
    if (!window[elem[i]] || 'remove' in window[elem[i]].prototype) continue;

    window[elem[i]].prototype.remove = function () {
      this.parentNode.removeChild(this);
    };
  }
})(['Element', 'CharacterData', 'DocumentType']); //
// requestAnimationFrame polyfill by Erik Mller.
//  With fixes from Paul Irish and Tino Zijdel
//
//  http://paulirish.com/2011/requestanimationframe-for-smart-animating/
//  http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
//
//  MIT license
//


(function () {
  var lastTime = 0;
  var vendors = ['webkit', 'moz'];

  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
})(); // Source: https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/prepend()/prepend().md


(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty('prepend')) {
      return;
    }

    Object.defineProperty(item, 'prepend', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function prepend() {
        var argArr = Array.prototype.slice.call(arguments),
            docFrag = document.createDocumentFragment();
        argArr.forEach(function (argItem) {
          var isNode = argItem instanceof Node;
          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
        });
        this.insertBefore(docFrag, this.firstChild);
      }
    });
  });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]); // Global variables


window.KTUtilElementDataStore = {};
window.KTUtilElementDataStoreID = 0;
window.KTUtilDelegatedEventHandlers = {};

var KTUtil = function () {
  var resizeHandlers = [];
  /** @type {object} breakpoints The device width breakpoints **/

  var breakpoints = {
    sm: 544,
    // Small screen / phone
    md: 768,
    // Medium screen / tablet
    lg: 1024,
    // Large screen / desktop
    xl: 1200 // Extra large screen / wide desktop

  };
  /**
   * Handle window resize event with some
   * delay to attach event handlers upon resize complete
   */

  var _windowResizeHandler = function _windowResizeHandler() {
    var _runResizeHandlers = function _runResizeHandlers() {
      // reinitialize other subscribed elements
      for (var i = 0; i < resizeHandlers.length; i++) {
        var each = resizeHandlers[i];
        each.call();
      }
    };

    var timeout = false; // holder for timeout id

    var delay = 250; // delay after event is "complete" to run callback

    window.addEventListener('resize', function () {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        _runResizeHandlers();
      }, delay); // wait 50ms until window resize finishes.
    });
  };

  return {
    /**
     * Class main initializer.
     * @param {object} options.
     * @returns null
     */
    //main function to initiate the theme
    init: function init(options) {
      if (options && options.breakpoints) {
        breakpoints = options.breakpoints;
      }

      _windowResizeHandler();
    },

    /**
     * Adds window resize event handler.
     * @param {function} callback function.
     */
    addResizeHandler: function addResizeHandler(callback) {
      resizeHandlers.push(callback);
    },

    /**
     * Removes window resize event handler.
     * @param {function} callback function.
     */
    removeResizeHandler: function removeResizeHandler(callback) {
      for (var i = 0; i < resizeHandlers.length; i++) {
        if (callback === resizeHandlers[i]) {
          delete resizeHandlers[i];
        }
      }
    },

    /**
     * Trigger window resize handlers.
     */
    runResizeHandlers: function runResizeHandlers() {
      _runResizeHandlers();
    },
    resize: function resize() {
      if (typeof Event === 'function') {
        // modern browsers
        window.dispatchEvent(new Event('resize'));
      } else {
        // for IE and other old browsers
        // causes deprecation warning on modern browsers
        var evt = window.document.createEvent('UIEvents');
        evt.initUIEvent('resize', true, false, window, 0);
        window.dispatchEvent(evt);
      }
    },

    /**
     * Get GET parameter value from URL.
     * @param {string} paramName Parameter name.
     * @returns {string}
     */
    getURLParam: function getURLParam(paramName) {
      var searchString = window.location.search.substring(1),
          i,
          val,
          params = searchString.split("&");

      for (i = 0; i < params.length; i++) {
        val = params[i].split("=");

        if (val[0] == paramName) {
          return unescape(val[1]);
        }
      }

      return null;
    },

    /**
     * Checks whether current device is mobile touch.
     * @returns {boolean}
     */
    isMobileDevice: function isMobileDevice() {
      return this.getViewPort().width < this.getBreakpoint('lg') ? true : false;
    },

    /**
     * Checks whether current device is desktop.
     * @returns {boolean}
     */
    isDesktopDevice: function isDesktopDevice() {
      return KTUtil.isMobileDevice() ? false : true;
    },

    /**
     * Gets browser window viewport size. Ref:
     * http://andylangton.co.uk/articles/javascript/get-viewport-size-javascript/
     * @returns {object}
     */
    getViewPort: function getViewPort() {
      var e = window,
          a = 'inner';

      if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
      }

      return {
        width: e[a + 'Width'],
        height: e[a + 'Height']
      };
    },

    /**
     * Checks whether given device mode is currently activated.
     * @param {string} mode Responsive mode name(e.g: desktop,
     *     desktop-and-tablet, tablet, tablet-and-mobile, mobile)
     * @returns {boolean}
     */
    isInResponsiveRange: function isInResponsiveRange(mode) {
      var breakpoint = this.getViewPort().width;

      if (mode == 'general') {
        return true;
      } else if (mode == 'desktop' && breakpoint >= this.getBreakpoint('lg') + 1) {
        return true;
      } else if (mode == 'tablet' && breakpoint >= this.getBreakpoint('md') + 1 && breakpoint < this.getBreakpoint('lg')) {
        return true;
      } else if (mode == 'mobile' && breakpoint <= this.getBreakpoint('md')) {
        return true;
      } else if (mode == 'desktop-and-tablet' && breakpoint >= this.getBreakpoint('md') + 1) {
        return true;
      } else if (mode == 'tablet-and-mobile' && breakpoint <= this.getBreakpoint('lg')) {
        return true;
      } else if (mode == 'minimal-desktop-and-below' && breakpoint <= this.getBreakpoint('xl')) {
        return true;
      }

      return false;
    },

    /**
     * Generates unique ID for give prefix.
     * @param {string} prefix Prefix for generated ID
     * @returns {boolean}
     */
    getUniqueID: function getUniqueID(prefix) {
      return prefix + Math.floor(Math.random() * new Date().getTime());
    },

    /**
     * Gets window width for give breakpoint mode.
     * @param {string} mode Responsive mode name(e.g: xl, lg, md, sm)
     * @returns {number}
     */
    getBreakpoint: function getBreakpoint(mode) {
      return breakpoints[mode];
    },

    /**
     * Checks whether object has property matchs given key path.
     * @param {object} obj Object contains values paired with given key path
     * @param {string} keys Keys path seperated with dots
     * @returns {object}
     */
    isset: function isset(obj, keys) {
      var stone;
      keys = keys || '';

      if (keys.indexOf('[') !== -1) {
        throw new Error('Unsupported object path notation.');
      }

      keys = keys.split('.');

      do {
        if (obj === undefined) {
          return false;
        }

        stone = keys.shift();

        if (!obj.hasOwnProperty(stone)) {
          return false;
        }

        obj = obj[stone];
      } while (keys.length);

      return true;
    },

    /**
     * Gets highest z-index of the given element parents
     * @param {object} el jQuery element object
     * @returns {number}
     */
    getHighestZindex: function getHighestZindex(el) {
      var elem = KTUtil.get(el),
          position,
          value;

      while (elem && elem !== document) {
        // Ignore z-index if position is set to a value where z-index is ignored by the browser
        // This makes behavior of this function consistent across browsers
        // WebKit always returns auto if the element is positioned
        position = KTUtil.css(elem, 'position');

        if (position === "absolute" || position === "relative" || position === "fixed") {
          // IE returns 0 when zIndex is not specified
          // other browsers return a string
          // we ignore the case of nested elements with an explicit value of 0
          // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
          value = parseInt(KTUtil.css(elem, 'z-index'));

          if (!isNaN(value) && value !== 0) {
            return value;
          }
        }

        elem = elem.parentNode;
      }

      return null;
    },

    /**
     * Checks whether the element has any parent with fixed positionfreg
     * @param {object} el jQuery element object
     * @returns {boolean}
     */
    hasFixedPositionedParent: function hasFixedPositionedParent(el) {
      var position;

      while (el && el !== document) {
        position = KTUtil.css(el, 'position');

        if (position === "fixed") {
          return true;
        }

        el = el.parentNode;
      }

      return false;
    },

    /**
     * Simulates delay
     */
    sleep: function sleep(milliseconds) {
      var start = new Date().getTime();

      for (var i = 0; i < 1e7; i++) {
        if (new Date().getTime() - start > milliseconds) {
          break;
        }
      }
    },

    /**
     * Gets randomly generated integer value within given min and max range
     * @param {number} min Range start value
     * @param {number} max Range end value
     * @returns {number}
     */
    getRandomInt: function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Checks whether Angular library is included
     * @returns {boolean}
     */
    isAngularVersion: function isAngularVersion() {
      return window.Zone !== undefined ? true : false;
    },
    // jQuery Workarounds
    // Deep extend:  $.extend(true, {}, objA, objB);
    deepExtend: function deepExtend(out) {
      out = out || {};

      for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        if (!obj) continue;

        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (_typeof(obj[key]) === 'object') out[key] = KTUtil.deepExtend(out[key], obj[key]);else out[key] = obj[key];
          }
        }
      }

      return out;
    },
    // extend:  $.extend({}, objA, objB);
    extend: function extend(out) {
      out = out || {};

      for (var i = 1; i < arguments.length; i++) {
        if (!arguments[i]) continue;

        for (var key in arguments[i]) {
          if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key];
        }
      }

      return out;
    },
    get: function get(query) {
      var el;

      if (query === document) {
        return document;
      }

      if (!!(query && query.nodeType === 1)) {
        return query;
      }

      if (el = document.getElementById(query)) {
        return el;
      } else if (el = document.getElementsByTagName(query)) {
        return el[0];
      } else if (el = document.getElementsByClassName(query)) {
        return el[0];
      } else {
        return null;
      }
    },
    getByID: function getByID(query) {
      if (!!(query && query.nodeType === 1)) {
        return query;
      }

      return document.getElementById(query);
    },
    getByTag: function getByTag(query) {
      var el;

      if (el = document.getElementsByTagName(query)) {
        return el[0];
      } else {
        return null;
      }
    },
    getByClass: function getByClass(query) {
      var el;

      if (el = document.getElementsByClassName(query)) {
        return el[0];
      } else {
        return null;
      }
    },

    /**
     * Checks whether the element has given classes
     * @param {object} el jQuery element object
     * @param {string} Classes string
     * @returns {boolean}
     */
    hasClasses: function hasClasses(el, classes) {
      if (!el) {
        return;
      }

      var classesArr = classes.split(" ");

      for (var i = 0; i < classesArr.length; i++) {
        if (KTUtil.hasClass(el, KTUtil.trim(classesArr[i])) == false) {
          return false;
        }
      }

      return true;
    },
    hasClass: function hasClass(el, className) {
      if (!el) {
        return;
      }

      return el.classList ? el.classList.contains(className) : new RegExp('\\b' + className + '\\b').test(el.className);
    },
    addClass: function addClass(el, className) {
      if (!el || typeof className === 'undefined') {
        return;
      }

      var classNames = className.split(' ');

      if (el.classList) {
        for (var i = 0; i < classNames.length; i++) {
          if (classNames[i] && classNames[i].length > 0) {
            el.classList.add(KTUtil.trim(classNames[i]));
          }
        }
      } else if (!KTUtil.hasClass(el, className)) {
        for (var x = 0; x < classNames.length; x++) {
          el.className += ' ' + KTUtil.trim(classNames[x]);
        }
      }
    },
    removeClass: function removeClass(el, className) {
      if (!el || typeof className === 'undefined') {
        return;
      }

      var classNames = className.split(' ');

      if (el.classList) {
        for (var i = 0; i < classNames.length; i++) {
          el.classList.remove(KTUtil.trim(classNames[i]));
        }
      } else if (KTUtil.hasClass(el, className)) {
        for (var x = 0; x < classNames.length; x++) {
          el.className = el.className.replace(new RegExp('\\b' + KTUtil.trim(classNames[x]) + '\\b', 'g'), '');
        }
      }
    },
    triggerCustomEvent: function triggerCustomEvent(el, eventName, data) {
      var event;

      if (window.CustomEvent) {
        event = new CustomEvent(eventName, {
          detail: data
        });
      } else {
        event = document.createEvent('CustomEvent');
        event.initCustomEvent(eventName, true, true, data);
      }

      el.dispatchEvent(event);
    },
    triggerEvent: function triggerEvent(node, eventName) {
      // Make sure we use the ownerDocument from the provided node to avoid cross-window problems
      var doc;

      if (node.ownerDocument) {
        doc = node.ownerDocument;
      } else if (node.nodeType == 9) {
        // the node may be the document itself, nodeType 9 = DOCUMENT_NODE
        doc = node;
      } else {
        throw new Error("Invalid node passed to fireEvent: " + node.id);
      }

      if (node.dispatchEvent) {
        // Gecko-style approach (now the standard) takes more work
        var eventClass = ""; // Different events have different event classes.
        // If this switch statement can't map an eventName to an eventClass,
        // the event firing is going to fail.

        switch (eventName) {
          case "click": // Dispatching of 'click' appears to not work correctly in Safari. Use 'mousedown' or 'mouseup' instead.

          case "mouseenter":
          case "mouseleave":
          case "mousedown":
          case "mouseup":
            eventClass = "MouseEvents";
            break;

          case "focus":
          case "change":
          case "blur":
          case "select":
            eventClass = "HTMLEvents";
            break;

          default:
            throw "fireEvent: Couldn't find an event class for event '" + eventName + "'.";
            break;
        }

        var event = doc.createEvent(eventClass);
        var bubbles = eventName == "change" ? false : true;
        event.initEvent(eventName, bubbles, true); // All events created as bubbling and cancelable.

        event.synthetic = true; // allow detection of synthetic events
        // The second parameter says go ahead with the default action

        node.dispatchEvent(event, true);
      } else if (node.fireEvent) {
        // IE-old school style
        var event = doc.createEventObject();
        event.synthetic = true; // allow detection of synthetic events

        node.fireEvent("on" + eventName, event);
      }
    },
    index: function index(elm) {
      elm = KTUtil.get(elm);
      var c = elm.parentNode.children,
          i = 0;

      for (; i < c.length; i++) {
        if (c[i] == elm) return i;
      }
    },
    trim: function trim(string) {
      return string.trim();
    },
    eventTriggered: function eventTriggered(e) {
      if (e.currentTarget.dataset.triggered) {
        return true;
      } else {
        e.currentTarget.dataset.triggered = true;
        return false;
      }
    },
    remove: function remove(el) {
      if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    },
    find: function find(parent, query) {
      parent = KTUtil.get(parent);

      if (parent) {
        return parent.querySelector(query);
      }
    },
    findAll: function findAll(parent, query) {
      parent = KTUtil.get(parent);

      if (parent) {
        return parent.querySelectorAll(query);
      }
    },
    insertAfter: function insertAfter(el, referenceNode) {
      return referenceNode.parentNode.insertBefore(el, referenceNode.nextSibling);
    },
    parents: function parents(elem, selector) {
      // Element.matches() polyfill
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
          var matches = (this.document || this.ownerDocument).querySelectorAll(s),
              i = matches.length;

          while (--i >= 0 && matches.item(i) !== this) {}

          return i > -1;
        };
      } // Set up a parent array


      var parents = []; // Push each parent element to the array

      for (; elem && elem !== document; elem = elem.parentNode) {
        if (selector) {
          if (elem.matches(selector)) {
            parents.push(elem);
          }

          continue;
        }

        parents.push(elem);
      } // Return our parent array


      return parents;
    },
    children: function children(el, selector, log) {
      if (!el || !el.childNodes) {
        return;
      }

      var result = [],
          i = 0,
          l = el.childNodes.length;

      for (var i; i < l; ++i) {
        if (el.childNodes[i].nodeType == 1 && KTUtil.matches(el.childNodes[i], selector, log)) {
          result.push(el.childNodes[i]);
        }
      }

      return result;
    },
    child: function child(el, selector, log) {
      var children = KTUtil.children(el, selector, log);
      return children ? children[0] : null;
    },
    matches: function matches(el, selector, log) {
      var p = Element.prototype;

      var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
        return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
      };

      if (el && el.tagName) {
        return f.call(el, selector);
      } else {
        return false;
      }
    },
    data: function data(element) {
      element = KTUtil.get(element);
      return {
        set: function set(name, data) {
          if (element === undefined) {
            return;
          }

          if (element.customDataTag === undefined) {
            window.KTUtilElementDataStoreID++;
            element.customDataTag = window.KTUtilElementDataStoreID;
          }

          if (window.KTUtilElementDataStore[element.customDataTag] === undefined) {
            window.KTUtilElementDataStore[element.customDataTag] = {};
          }

          window.KTUtilElementDataStore[element.customDataTag][name] = data;
        },
        get: function get(name) {
          if (element === undefined) {
            return;
          }

          if (element.customDataTag === undefined) {
            return null;
          }

          return this.has(name) ? window.KTUtilElementDataStore[element.customDataTag][name] : null;
        },
        has: function has(name) {
          if (element === undefined) {
            return false;
          }

          if (element.customDataTag === undefined) {
            return false;
          }

          return window.KTUtilElementDataStore[element.customDataTag] && window.KTUtilElementDataStore[element.customDataTag][name] ? true : false;
        },
        remove: function remove(name) {
          if (element && this.has(name)) {
            delete window.KTUtilElementDataStore[element.customDataTag][name];
          }
        }
      };
    },
    outerWidth: function outerWidth(el, margin) {
      var width;

      if (margin === true) {
        width = parseFloat(el.offsetWidth);
        width += parseFloat(KTUtil.css(el, 'margin-left')) + parseFloat(KTUtil.css(el, 'margin-right'));
        return parseFloat(width);
      } else {
        width = parseFloat(el.offsetWidth);
        return width;
      }
    },
    offset: function offset(elem) {
      var rect, win;
      elem = KTUtil.get(elem);

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    height: function height(el) {
      return KTUtil.css(el, 'height');
    },
    visible: function visible(el) {
      return !(el.offsetWidth === 0 && el.offsetHeight === 0);
    },
    attr: function attr(el, name, value) {
      el = KTUtil.get(el);

      if (el == undefined) {
        return;
      }

      if (value !== undefined) {
        el.setAttribute(name, value);
      } else {
        return el.getAttribute(name);
      }
    },
    hasAttr: function hasAttr(el, name) {
      el = KTUtil.get(el);

      if (el == undefined) {
        return;
      }

      return el.getAttribute(name) ? true : false;
    },
    removeAttr: function removeAttr(el, name) {
      el = KTUtil.get(el);

      if (el == undefined) {
        return;
      }

      el.removeAttribute(name);
    },
    animate: function animate(from, to, duration, update, easing, done) {
      /**
       * TinyAnimate.easings
       *  Adapted from jQuery Easing
       */
      var easings = {};
      var easing;

      easings.linear = function (t, b, c, d) {
        return c * t / d + b;
      };

      easing = easings.linear; // Early bail out if called incorrectly

      if (typeof from !== 'number' || typeof to !== 'number' || typeof duration !== 'number' || typeof update !== 'function') {
        return;
      } // Create mock done() function if necessary


      if (typeof done !== 'function') {
        done = function done() {};
      } // Pick implementation (requestAnimationFrame | setTimeout)


      var rAF = window.requestAnimationFrame || function (callback) {
        window.setTimeout(callback, 1000 / 50);
      }; // Animation loop


      var canceled = false;
      var change = to - from;

      function loop(timestamp) {
        var time = (timestamp || +new Date()) - start;

        if (time >= 0) {
          update(easing(time, from, change, duration));
        }

        if (time >= 0 && time >= duration) {
          update(to);
          done();
        } else {
          rAF(loop);
        }
      }

      update(from); // Start animation loop

      var start = window.performance && window.performance.now ? window.performance.now() : +new Date();
      rAF(loop);
    },
    actualCss: function actualCss(el, prop, cache) {
      el = KTUtil.get(el);
      var css = '';

      if (el instanceof HTMLElement === false) {
        return;
      }

      if (!el.getAttribute('hidden-' + prop) || cache === false) {
        var value; // the element is hidden so:
        // making the el block so we can meassure its height but still be hidden

        css = el.style.cssText;
        el.style.cssText = 'position: absolute; visibility: hidden; display: block;';

        if (prop == 'width') {
          value = el.offsetWidth;
        } else if (prop == 'height') {
          value = el.offsetHeight;
        }

        el.style.cssText = css; // store it in cache

        el.setAttribute('hidden-' + prop, value);
        return parseFloat(value);
      } else {
        // store it in cache
        return parseFloat(el.getAttribute('hidden-' + prop));
      }
    },
    actualHeight: function actualHeight(el, cache) {
      return KTUtil.actualCss(el, 'height', cache);
    },
    actualWidth: function actualWidth(el, cache) {
      return KTUtil.actualCss(el, 'width', cache);
    },
    getScroll: function getScroll(element, method) {
      // The passed in `method` value should be 'Top' or 'Left'
      method = 'scroll' + method;
      return element == window || element == document ? self[method == 'scrollTop' ? 'pageYOffset' : 'pageXOffset'] || browserSupportsBoxModel && document.documentElement[method] || document.body[method] : element[method];
    },
    css: function css(el, styleProp, value) {
      el = KTUtil.get(el);

      if (!el) {
        return;
      }

      if (value !== undefined) {
        el.style[styleProp] = value;
      } else {
        var defaultView = (el.ownerDocument || document).defaultView; // W3C standard way:

        if (defaultView && defaultView.getComputedStyle) {
          // sanitize property name to css notation
          // (hyphen separated words eg. font-Size)
          styleProp = styleProp.replace(/([A-Z])/g, "-$1").toLowerCase();
          return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        } else if (el.currentStyle) {
          // IE
          // sanitize property name to camelCase
          styleProp = styleProp.replace(/\-(\w)/g, function (str, letter) {
            return letter.toUpperCase();
          });
          value = el.currentStyle[styleProp]; // convert other units to pixels on IE

          if (/^\d+(em|pt|%|ex)?$/i.test(value)) {
            return function (value) {
              var oldLeft = el.style.left,
                  oldRsLeft = el.runtimeStyle.left;
              el.runtimeStyle.left = el.currentStyle.left;
              el.style.left = value || 0;
              value = el.style.pixelLeft + "px";
              el.style.left = oldLeft;
              el.runtimeStyle.left = oldRsLeft;
              return value;
            }(value);
          }

          return value;
        }
      }
    },
    slide: function slide(el, dir, speed, callback, recalcMaxHeight) {
      if (!el || dir == 'up' && KTUtil.visible(el) === false || dir == 'down' && KTUtil.visible(el) === true) {
        return;
      }

      speed = speed ? speed : 600;
      var calcHeight = KTUtil.actualHeight(el);
      var calcPaddingTop = false;
      var calcPaddingBottom = false;

      if (KTUtil.css(el, 'padding-top') && KTUtil.data(el).has('slide-padding-top') !== true) {
        KTUtil.data(el).set('slide-padding-top', KTUtil.css(el, 'padding-top'));
      }

      if (KTUtil.css(el, 'padding-bottom') && KTUtil.data(el).has('slide-padding-bottom') !== true) {
        KTUtil.data(el).set('slide-padding-bottom', KTUtil.css(el, 'padding-bottom'));
      }

      if (KTUtil.data(el).has('slide-padding-top')) {
        calcPaddingTop = parseInt(KTUtil.data(el).get('slide-padding-top'));
      }

      if (KTUtil.data(el).has('slide-padding-bottom')) {
        calcPaddingBottom = parseInt(KTUtil.data(el).get('slide-padding-bottom'));
      }

      if (dir == 'up') {
        // up
        el.style.cssText = 'display: block; overflow: hidden;';

        if (calcPaddingTop) {
          KTUtil.animate(0, calcPaddingTop, speed, function (value) {
            el.style.paddingTop = calcPaddingTop - value + 'px';
          }, 'linear');
        }

        if (calcPaddingBottom) {
          KTUtil.animate(0, calcPaddingBottom, speed, function (value) {
            el.style.paddingBottom = calcPaddingBottom - value + 'px';
          }, 'linear');
        }

        KTUtil.animate(0, calcHeight, speed, function (value) {
          el.style.height = calcHeight - value + 'px';
        }, 'linear', function () {
          callback();
          el.style.height = '';
          el.style.display = 'none';
        });
      } else if (dir == 'down') {
        // down
        el.style.cssText = 'display: block; overflow: hidden;';

        if (calcPaddingTop) {
          KTUtil.animate(0, calcPaddingTop, speed, function (value) {
            el.style.paddingTop = value + 'px';
          }, 'linear', function () {
            el.style.paddingTop = '';
          });
        }

        if (calcPaddingBottom) {
          KTUtil.animate(0, calcPaddingBottom, speed, function (value) {
            el.style.paddingBottom = value + 'px';
          }, 'linear', function () {
            el.style.paddingBottom = '';
          });
        }

        KTUtil.animate(0, calcHeight, speed, function (value) {
          el.style.height = value + 'px';
        }, 'linear', function () {
          callback();
          el.style.height = '';
          el.style.display = '';
          el.style.overflow = '';
        });
      }
    },
    slideUp: function slideUp(el, speed, callback) {
      KTUtil.slide(el, 'up', speed, callback);
    },
    slideDown: function slideDown(el, speed, callback) {
      KTUtil.slide(el, 'down', speed, callback);
    },
    show: function show(el, display) {
      if (typeof el !== 'undefined') {
        el.style.display = display ? display : 'block';
      }
    },
    hide: function hide(el) {
      if (typeof el !== 'undefined') {
        el.style.display = 'none';
      }
    },
    addEvent: function addEvent(el, type, handler, one) {
      el = KTUtil.get(el);

      if (typeof el !== 'undefined') {
        el.addEventListener(type, handler);
      }
    },
    removeEvent: function removeEvent(el, type, handler) {
      el = KTUtil.get(el);
      el.removeEventListener(type, handler);
    },
    on: function on(element, selector, event, handler) {
      if (!selector) {
        return;
      }

      var eventId = KTUtil.getUniqueID('event');

      window.KTUtilDelegatedEventHandlers[eventId] = function (e) {
        var targets = element.querySelectorAll(selector);
        var target = e.target;

        while (target && target !== element) {
          for (var i = 0, j = targets.length; i < j; i++) {
            if (target === targets[i]) {
              handler.call(target, e);
            }
          }

          target = target.parentNode;
        }
      };

      KTUtil.addEvent(element, event, window.KTUtilDelegatedEventHandlers[eventId]);
      return eventId;
    },
    off: function off(element, event, eventId) {
      if (!element || !window.KTUtilDelegatedEventHandlers[eventId]) {
        return;
      }

      KTUtil.removeEvent(element, event, window.KTUtilDelegatedEventHandlers[eventId]);
      delete window.KTUtilDelegatedEventHandlers[eventId];
    },
    one: function onetime(el, type, callback) {
      el = KTUtil.get(el);
      el.addEventListener(type, function callee(e) {
        // remove event
        if (e.target && e.target.removeEventListener) {
          e.target.removeEventListener(e.type, callee);
        } // call handler


        return callback(e);
      });
    },
    hash: function hash(str) {
      var hash = 0,
          i,
          chr;
      if (str.length === 0) return hash;

      for (i = 0; i < str.length; i++) {
        chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
      }

      return hash;
    },
    animateClass: function animateClass(el, animationName, callback) {
      var animation;
      var animations = {
        animation: 'animationend',
        OAnimation: 'oAnimationEnd',
        MozAnimation: 'mozAnimationEnd',
        WebkitAnimation: 'webkitAnimationEnd',
        msAnimation: 'msAnimationEnd'
      };

      for (var t in animations) {
        if (el.style[t] !== undefined) {
          animation = animations[t];
        }
      }

      KTUtil.addClass(el, 'animated ' + animationName);
      KTUtil.one(el, animation, function () {
        KTUtil.removeClass(el, 'animated ' + animationName);
      });

      if (callback) {
        KTUtil.one(el, animation, callback);
      }
    },
    transitionEnd: function transitionEnd(el, callback) {
      var transition;
      var transitions = {
        transition: 'transitionend',
        OTransition: 'oTransitionEnd',
        MozTransition: 'mozTransitionEnd',
        WebkitTransition: 'webkitTransitionEnd',
        msTransition: 'msTransitionEnd'
      };

      for (var t in transitions) {
        if (el.style[t] !== undefined) {
          transition = transitions[t];
        }
      }

      KTUtil.one(el, transition, callback);
    },
    animationEnd: function animationEnd(el, callback) {
      var animation;
      var animations = {
        animation: 'animationend',
        OAnimation: 'oAnimationEnd',
        MozAnimation: 'mozAnimationEnd',
        WebkitAnimation: 'webkitAnimationEnd',
        msAnimation: 'msAnimationEnd'
      };

      for (var t in animations) {
        if (el.style[t] !== undefined) {
          animation = animations[t];
        }
      }

      KTUtil.one(el, animation, callback);
    },
    animateDelay: function animateDelay(el, value) {
      var vendors = ['webkit-', 'moz-', 'ms-', 'o-', ''];

      for (var i = 0; i < vendors.length; i++) {
        KTUtil.css(el, vendors[i] + 'animation-delay', value);
      }
    },
    animateDuration: function animateDuration(el, value) {
      var vendors = ['webkit-', 'moz-', 'ms-', 'o-', ''];

      for (var i = 0; i < vendors.length; i++) {
        KTUtil.css(el, vendors[i] + 'animation-duration', value);
      }
    },
    scrollTo: function scrollTo(target, offset, duration) {
      var duration = duration ? duration : 500;
      var target = KTUtil.get(target);
      var targetPos = target ? KTUtil.offset(target).top : 0;
      var scrollPos = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      var from, to;

      if (targetPos > scrollPos) {
        from = targetPos;
        to = scrollPos;
      } else {
        from = scrollPos;
        to = targetPos;
      }

      if (offset) {
        to += offset;
      }

      KTUtil.animate(from, to, duration, function (value) {
        document.documentElement.scrollTop = value;
        document.body.parentNode.scrollTop = value;
        document.body.scrollTop = value;
      }); //, easing, done
    },
    scrollTop: function scrollTop(offset, duration) {
      KTUtil.scrollTo(null, offset, duration);
    },
    isArray: function isArray(obj) {
      return obj && Array.isArray(obj);
    },
    ready: function ready(callback) {
      if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        callback();
      } else {
        document.addEventListener('DOMContentLoaded', callback);
      }
    },
    isEmpty: function isEmpty(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }

      return true;
    },
    numberString: function numberString(nStr) {
      nStr += '';
      var x = nStr.split('.');
      var x1 = x[0];
      var x2 = x.length > 1 ? '.' + x[1] : '';
      var rgx = /(\d+)(\d{3})/;

      while (rgx.test(x1)) {
        x1 = x1.replace(rgx, '$1' + ',' + '$2');
      }

      return x1 + x2;
    },
    detectIE: function detectIE() {
      var ua = window.navigator.userAgent; // Test values; Uncomment to check result 
      // IE 10
      // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';
      // IE 11
      // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';
      // Edge 12 (Spartan)
      // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';
      // Edge 13
      // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';

      var msie = ua.indexOf('MSIE ');

      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('Trident/');

      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('Edge/');

      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      } // other browser


      return false;
    },
    isRTL: function isRTL() {
      return KTUtil.attr(KTUtil.get('html'), 'direction') == 'rtl';
    },
    //
    // Scroller
    scrollInit: function scrollInit(element, options) {
      if (!element) return; // Define init function

      function init() {
        var ps;
        var height;

        if (options.height instanceof Function) {
          height = parseInt(options.height.call());
        } else {
          height = parseInt(options.height);
        } // Destroy scroll on table and mobile modes


        if ((options.mobileNativeScroll || options.disableForMobile) && KTUtil.isInResponsiveRange('tablet-and-mobile')) {
          ps = KTUtil.data(element).get('ps');

          if (ps) {
            if (options.resetHeightOnDestroy) {
              KTUtil.css(element, 'height', 'auto');
            } else {
              KTUtil.css(element, 'overflow', 'auto');

              if (height > 0) {
                KTUtil.css(element, 'height', height + 'px');
              }
            }

            ps.destroy();
            ps = KTUtil.data(element).remove('ps');
          } else if (height > 0) {
            KTUtil.css(element, 'overflow', 'auto');
            KTUtil.css(element, 'height', height + 'px');
          }

          return;
        }

        if (height > 0) {
          KTUtil.css(element, 'height', height + 'px');
        }

        if (options.desktopNativeScroll) {
          KTUtil.css(element, 'overflow', 'auto');
          return;
        } // Init scroll


        KTUtil.css(element, 'overflow', 'hidden');
        ps = KTUtil.data(element).get('ps');

        if (ps) {
          ps.update();
        } else {
          KTUtil.addClass(element, 'scroll');
          ps = new PerfectScrollbar(element, {
            wheelSpeed: 0.5,
            swipeEasing: true,
            wheelPropagation: options.windowScroll === false ? false : true,
            minScrollbarLength: 40,
            maxScrollbarLength: 300,
            suppressScrollX: KTUtil.attr(element, 'data-scroll-x') != 'true' ? true : false
          });
          KTUtil.data(element).set('ps', ps);
        } // Remember scroll position in cookie


        var uid = KTUtil.attr(element, 'id');

        if (options.rememberPosition === true && Cookies && uid) {
          if (Cookies.get(uid)) {
            var pos = parseInt(Cookies.get(uid));

            if (pos > 0) {
              element.scrollTop = pos;
            }
          }

          element.addEventListener('ps-scroll-y', function () {
            Cookies.set(uid, element.scrollTop);
          });
        }
      } // Init


      init(); // Handle window resize

      if (options.handleWindowResize) {
        KTUtil.addResizeHandler(function () {
          init();
        });
      }
    },
    scrollUpdate: function scrollUpdate(element) {
      var ps = KTUtil.data(element).get('ps');

      if (ps) {
        ps.update();
      }
    },
    scrollUpdateAll: function scrollUpdateAll(parent) {
      var scrollers = KTUtil.findAll(parent, '.ps');

      for (var i = 0, len = scrollers.length; i < len; i++) {
        KTUtil.scrollerUpdate(scrollers[i]);
      }
    },
    scrollDestroy: function scrollDestroy(element) {
      var ps = KTUtil.data(element).get('ps');

      if (ps) {
        ps.destroy();
        ps = KTUtil.data(element).remove('ps');
      }
    },
    setHTML: function setHTML(el, html) {
      if (KTUtil.get(el)) {
        KTUtil.get(el).innerHTML = html;
      }
    },
    getHTML: function getHTML(el) {
      if (KTUtil.get(el)) {
        return KTUtil.get(el).innerHTML;
      }
    },
    getDocumentHeight: function getDocumentHeight() {
      var body = document.body;
      var html = document.documentElement;
      return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
    },
    getScrollTop: function getScrollTop() {
      return (document.scrollingElement || document.documentElement).scrollTop;
    }
  };
}(); // webpack support


if ( true && typeof module.exports !== 'undefined') {
  module.exports = KTUtil;
} // Initialize KTUtil class on document ready


KTUtil.ready(function () {
  KTUtil.init();
}); // CSS3 Transitions only after page load(.page-loading class added to body tag and remove with JS on page load)

window.onload = function () {
  KTUtil.removeClass(KTUtil.get('body'), 'page--loading');
};

/***/ }),

/***/ "./resources/assets/js/global/layout/layout.js":
/*!*****************************************************!*\
  !*** ./resources/assets/js/global/layout/layout.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTLayout = function () {
  var body;
  var aside;
  var asideMenu;
  var asideMenuOffcanvas;
  var scrollTop;
  var pageStickyPortlet; // Aside

  var _initAside = function initAside() {
    aside = KTUtil.get('aside'); // Init offcanvas layout for mobile

    asideMenuOffcanvas = new KTOffcanvas('aside', {
      baseClass: 'aside',
      overlay: true,
      closeBy: 'aside_close_btn',
      toggleBy: {
        target: 'aside_mobile_toggler',
        state: 'header-mobile__toolbar-toggler--active'
      }
    }); // Init aside menu

    var menu = KTUtil.get('aside_menu');
    var menu = KTUtil.getByID('aside_menu');
    var menuDesktopMode = KTUtil.attr(menu, 'data-ktmenu-dropdown') === '1' ? 'dropdown' : 'accordion'; // Init scrollable menu container

    var scroll;

    if (KTUtil.attr(menu, 'data-ktmenu-scroll') === '1') {
      scroll = {
        rememberPosition: true,
        // remember position on page reload
        height: function height() {
          // calculate available scrollable area height
          // calculated height
          var height; // window height

          var windowHeight = parseInt(KTUtil.getViewPort().height); // secondary

          var secondary = KTUtil.find(aside, '.aside__secondary');
          var secondaryPaddingTop = parseInt(KTUtil.css(secondary, 'padding-top'));
          var secondaryPaddingBottom = parseInt(KTUtil.css(secondary, 'padding-bottom')); // top height

          var top = KTUtil.find(aside, '.aside__secondary-top');
          var topHeight = parseInt(KTUtil.height(top)); // bottom

          var bottom = KTUtil.find(aside, '.aside__secondary-bottom');
          var bottomPaddingTop = parseInt(KTUtil.css(bottom, 'padding-top'));
          var bottomPaddingBotton = parseInt(KTUtil.css(bottom, 'padding-bottom')); // calculate height

          height = windowHeight - topHeight - bottomPaddingTop - bottomPaddingBotton - secondaryPaddingTop - secondaryPaddingBottom;
          return height;
        }
      };
    } // Init aside menu


    asideMenu = new KTMenu('aside_menu', {
      // vertical scroll
      scroll: scroll,
      // submenu setup
      submenu: {
        desktop: {
          // by default the menu mode set to accordion in desktop mode
          "default": menuDesktopMode,
          // whenever body has this class switch the menu mode to dropdown
          state: {
            body: 'aside--minimize',
            mode: 'dropdown'
          }
        },
        tablet: 'accordion',
        // menu set to accordion in tablet mode
        mobile: 'accordion' // menu set to accordion in mobile mode

      },
      //accordion setup
      accordion: {
        expandAll: false // allow having multiple expanded accordions in the menu

      }
    });
  }; // Scrolltop


  var _initScrolltop = function initScrolltop() {
    var scrolltop = new KTScrolltop('scrolltop', {
      offset: 300,
      speed: 600
    });
  }; // Init page sticky portlet


  var _initPageStickyPortlet = function initPageStickyPortlet() {
    var asidePrimaryWidth = 70;
    var asideSecondaryWidth = 250;
    return new KTPortlet('page_portlet', {
      sticky: {
        offset: 80,
        zIndex: 90,
        position: {
          top: function top() {
            var pos = 0;

            if (KTUtil.isInResponsiveRange('desktop')) {
              if (KTUtil.hasClass(body, 'subheader--fixed')) {
                pos = pos + parseInt(KTUtil.css(KTUtil.get('subheader'), 'height'));
              }
            } else {
              if (KTUtil.hasClass(body, 'header-mobile--fixed')) {
                pos = pos + parseInt(KTUtil.css(KTUtil.get('header_mobile'), 'height'));
              }
            }

            return pos;
          },
          left: function left(portlet) {
            var porletEl = portlet.getSelf();
            return KTUtil.offset(porletEl).left;
          },
          right: function right(portlet) {
            var porletEl = portlet.getSelf();
            var portletWidth = parseInt(KTUtil.css(porletEl, 'width'));
            var bodyWidth = parseInt(KTUtil.css(KTUtil.get('body'), 'width'));
            var portletOffsetLeft = KTUtil.offset(porletEl).left;
            return bodyWidth - portletWidth - portletOffsetLeft;
          }
        }
      }
    });
  };

  return {
    init: function init() {
      body = KTUtil.getByTag('body');
      this.initAside();
      this.initScrolltop();
      this.initPageStickyPortlet(); // Non functional links notice(can be removed in production)

      $('#aside_menu, #header_menu').on('click', '.menu__link[href="#"]:not(.menu__toggle)', function (e) {
        swal("", "You have clicked on a non-functional dummy link!");
        e.preventDefault();
      });
    },
    initAside: function initAside() {
      _initAside();
    },
    initScrolltop: function initScrolltop() {
      _initScrolltop();
    },
    initPageStickyPortlet: function initPageStickyPortlet() {
      if (!KTUtil.get('page_portlet')) {
        return;
      }

      pageStickyPortlet = _initPageStickyPortlet();
      pageStickyPortlet.initSticky();
      KTUtil.addResizeHandler(function () {
        pageStickyPortlet.updateSticky();
      });

      _initPageStickyPortlet();
    },
    getAsideMenu: function getAsideMenu() {
      return asideMenu;
    },
    closeMobileAsideMenuOffcanvas: function closeMobileAsideMenuOffcanvas() {
      if (KTUtil.isMobileDevice()) {
        asideMenuOffcanvas.hide();
      }
    },
    closeMobileHeaderMenuOffcanvas: function closeMobileHeaderMenuOffcanvas() {
      if (KTUtil.isMobileDevice()) {
        headerMenuOffcanvas.hide();
      }
    }
  };
}(); // webpack support


if (true) {
  module.exports = KTLayout;
} // Init on page load completed


KTUtil.ready(function () {
  KTLayout.init();
});

/***/ }),

/***/ "./resources/assets/js/global/layout/lib.js":
/*!**************************************************!*\
  !*** ./resources/assets/js/global/layout/lib.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Class definition
var KTLib = function () {
  return {
    initMiniChart: function initMiniChart(src, data, color, border, fill, tooltip) {
      if (src.length === 0) {
        return;
      } // set default values


      fill = typeof fill !== 'undefined' ? fill : false;
      tooltip = typeof tooltip !== 'undefined' ? tooltip : false;
      var config = {
        type: 'line',
        data: {
          labels: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October"],
          datasets: [{
            label: "",
            borderColor: color,
            borderWidth: border,
            pointHoverRadius: 4,
            pointHoverBorderWidth: 4,
            pointBackgroundColor: Chart.helpers.color('#000000').alpha(0).rgbString(),
            pointBorderColor: Chart.helpers.color('#000000').alpha(0).rgbString(),
            pointHoverBackgroundColor: KTApp.getStateColor('brand'),
            pointHoverBorderColor: Chart.helpers.color('#000000').alpha(0.1).rgbString(),
            fill: fill,
            backgroundColor: color,
            data: data
          }]
        },
        options: {
          title: {
            display: false
          },
          tooltips: tooltip ? {
            enabled: true,
            intersect: false,
            mode: 'nearest',
            bodySpacing: 5,
            yPadding: 10,
            xPadding: 10,
            caretPadding: 0,
            displayColors: false,
            backgroundColor: KTApp.getStateColor('brand'),
            titleFontColor: '#ffffff',
            cornerRadius: 4,
            footerSpacing: 0,
            titleSpacing: 0
          } : false,
          legend: {
            display: false,
            labels: {
              usePointStyle: false
            }
          },
          responsive: false,
          maintainAspectRatio: true,
          hover: {
            mode: 'index'
          },
          scales: {
            xAxes: [{
              display: false,
              gridLines: false,
              scaleLabel: {
                display: false,
                labelString: 'Month'
              }
            }],
            yAxes: [{
              display: false,
              gridLines: false,
              scaleLabel: {
                display: false,
                labelString: 'Month'
              }
            }]
          },
          elements: {
            line: {
              tension: 0.5
            },
            point: {
              radius: 2,
              borderWidth: 4
            }
          },
          layout: {
            padding: {
              left: 6,
              right: 0,
              top: 4,
              bottom: 0
            }
          }
        }
      };
      var chart = new Chart(src, config);
    },
    initMediumChart: function initMediumChart(src, data, max, color, border) {
      if (!document.getElementById(src)) {
        return;
      }

      var border = border ? border : 2; // Main chart

      var ctx = document.getElementById(src).getContext("2d");
      var gradient = ctx.createLinearGradient(0, 0, 0, 100);
      gradient.addColorStop(0, Chart.helpers.color(color).alpha(0.3).rgbString());
      gradient.addColorStop(1, Chart.helpers.color(color).alpha(0).rgbString());
      var mainConfig = {
        type: 'line',
        data: {
          labels: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October'],
          datasets: [{
            label: 'Orders',
            borderColor: color,
            borderWidth: border,
            backgroundColor: gradient,
            pointBackgroundColor: KTApp.getStateColor('brand'),
            data: data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          title: {
            display: false,
            text: 'Stacked Area'
          },
          tooltips: {
            enabled: true,
            intersect: false,
            mode: 'nearest',
            bodySpacing: 5,
            yPadding: 10,
            xPadding: 10,
            caretPadding: 0,
            displayColors: false,
            backgroundColor: KTApp.getStateColor('brand'),
            titleFontColor: '#ffffff',
            cornerRadius: 4,
            footerSpacing: 0,
            titleSpacing: 0
          },
          legend: {
            display: false,
            labels: {
              usePointStyle: false
            }
          },
          hover: {
            mode: 'index'
          },
          scales: {
            xAxes: [{
              display: false,
              scaleLabel: {
                display: false,
                labelString: 'Month'
              },
              ticks: {
                display: false,
                beginAtZero: true
              }
            }],
            yAxes: [{
              display: false,
              scaleLabel: {
                display: false,
                labelString: 'Value'
              },
              gridLines: {
                color: '#eef2f9',
                drawBorder: false,
                offsetGridLines: true,
                drawTicks: false
              },
              ticks: {
                max: max,
                display: false,
                beginAtZero: true
              }
            }]
          },
          elements: {
            point: {
              radius: 0,
              borderWidth: 0,
              hoverRadius: 0,
              hoverBorderWidth: 0
            }
          },
          layout: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        }
      };
      var chart = new Chart(ctx, mainConfig); // Update chart on window resize

      KTUtil.addResizeHandler(function () {
        chart.update();
      });
    }
  };
}(); // webpack support


if (true) {
  module.exports = KTLib;
}

/***/ }),

/***/ "./resources/assets/js/global/layout/offcanvas-panel.js":
/*!**************************************************************!*\
  !*** ./resources/assets/js/global/layout/offcanvas-panel.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTOffcanvasPanel = function () {
  var notificationPanel = KTUtil.get('offcanvas_toolbar_notifications');
  var quickActionsPanel = KTUtil.get('offcanvas_toolbar_quick_actions');
  var profilePanel = KTUtil.get('offcanvas_toolbar_profile');
  var searchPanel = KTUtil.get('offcanvas_toolbar_search');

  var initNotifications = function initNotifications() {
    var head = KTUtil.find(notificationPanel, '.offcanvas-panel__head');
    var body = KTUtil.find(notificationPanel, '.offcanvas-panel__body');
    var offcanvas = new KTOffcanvas(notificationPanel, {
      overlay: true,
      baseClass: 'offcanvas-panel',
      closeBy: 'offcanvas_toolbar_notifications_close',
      toggleBy: 'offcanvas_toolbar_notifications_toggler_btn'
    });
    KTUtil.scrollInit(body, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        var height = parseInt(KTUtil.getViewPort().height);

        if (head) {
          height = height - parseInt(KTUtil.actualHeight(head));
          height = height - parseInt(KTUtil.css(head, 'marginBottom'));
        }

        height = height - parseInt(KTUtil.css(notificationPanel, 'paddingTop'));
        height = height - parseInt(KTUtil.css(notificationPanel, 'paddingBottom'));
        return height;
      }
    });
  };

  var initQucikActions = function initQucikActions() {
    var head = KTUtil.find(quickActionsPanel, '.offcanvas-panel__head');
    var body = KTUtil.find(quickActionsPanel, '.offcanvas-panel__body');
    var offcanvas = new KTOffcanvas(quickActionsPanel, {
      overlay: true,
      baseClass: 'offcanvas-panel',
      closeBy: 'offcanvas_toolbar_quick_actions_close',
      toggleBy: 'offcanvas_toolbar_quick_actions_toggler_btn'
    });
    KTUtil.scrollInit(body, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        var height = parseInt(KTUtil.getViewPort().height);

        if (head) {
          height = height - parseInt(KTUtil.actualHeight(head));
          height = height - parseInt(KTUtil.css(head, 'marginBottom'));
        }

        height = height - parseInt(KTUtil.css(quickActionsPanel, 'paddingTop'));
        height = height - parseInt(KTUtil.css(quickActionsPanel, 'paddingBottom'));
        return height;
      }
    });
  };

  var initProfile = function initProfile() {
    var head = KTUtil.find(profilePanel, '.offcanvas-panel__head');
    var body = KTUtil.find(profilePanel, '.offcanvas-panel__body');
    var offcanvas = new KTOffcanvas(profilePanel, {
      overlay: true,
      baseClass: 'offcanvas-panel',
      closeBy: 'offcanvas_toolbar_profile_close',
      toggleBy: 'offcanvas_toolbar_profile_toggler_btn'
    });
    KTUtil.scrollInit(body, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        var height = parseInt(KTUtil.getViewPort().height);

        if (head) {
          height = height - parseInt(KTUtil.actualHeight(head));
          height = height - parseInt(KTUtil.css(head, 'marginBottom'));
        }

        height = height - parseInt(KTUtil.css(profilePanel, 'paddingTop'));
        height = height - parseInt(KTUtil.css(profilePanel, 'paddingBottom'));
        return height;
      }
    });
  };

  var initSearch = function initSearch() {
    var head = KTUtil.find(searchPanel, '.offcanvas-panel__head');
    var body = KTUtil.find(searchPanel, '.offcanvas-panel__body');
    var search = KTUtil.get('quick_search_offcanvas');
    var form = KTUtil.find(search, '.quick-search__form');
    var wrapper = KTUtil.find(search, '.quick-search__wrapper');
    var offcanvas = new KTOffcanvas(searchPanel, {
      overlay: true,
      baseClass: 'offcanvas-panel',
      closeBy: 'offcanvas_toolbar_search_close',
      toggleBy: 'offcanvas_toolbar_search_toggler_btn'
    });
    KTUtil.scrollInit(wrapper, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        var height = parseInt(KTUtil.getViewPort().height);
        height = height - parseInt(KTUtil.actualHeight(form));
        height = height - parseInt(KTUtil.css(form, 'marginBottom'));

        if (head) {
          height = height - parseInt(KTUtil.actualHeight(head));
          height = height - parseInt(KTUtil.css(head, 'marginBottom'));
        }

        height = height - parseInt(KTUtil.css(searchPanel, 'paddingTop'));
        height = height - parseInt(KTUtil.css(searchPanel, 'paddingBottom'));
        return height;
      }
    });
  };

  return {
    init: function init() {
      initNotifications();
      initQucikActions();
      initProfile();
      initSearch();
    }
  };
}(); // Init on page load completed


KTUtil.ready(function () {
  KTOffcanvasPanel.init();
});

/***/ }),

/***/ "./resources/assets/js/global/layout/quick-panel.js":
/*!**********************************************************!*\
  !*** ./resources/assets/js/global/layout/quick-panel.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTQuickPanel = function () {
  var panel = KTUtil.get('quick_panel');
  var notificationPanel = KTUtil.get('quick_panel_tab_notifications');
  var actionsPanel = KTUtil.get('quick_panel_tab_actions');
  var settingsPanel = KTUtil.get('quick_panel_tab_settings');

  var getContentHeight = function getContentHeight() {
    var height;
    var nav = KTUtil.find(panel, '.offcanvas-panel__nav');
    var content = KTUtil.find(panel, '.offcanvas-panel__body');
    height = parseInt(KTUtil.getViewPort().height) - parseInt(KTUtil.actualHeight(nav)) - parseInt(KTUtil.css(nav, 'margin-bottom')) - 2 * parseInt(KTUtil.css(nav, 'padding-top')) - 10;
    return height;
  };

  var initOffcanvas = function initOffcanvas() {
    var offcanvas = new KTOffcanvas(panel, {
      overlay: true,
      baseClass: 'offcanvas-panel',
      closeBy: 'quick_panel_close_btn',
      toggleBy: 'quick_panel_toggler_btn'
    });
  };

  var initNotifications = function initNotifications() {
    KTUtil.scrollInit(notificationPanel, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        return getContentHeight();
      }
    });
  };

  var initActions = function initActions() {
    KTUtil.scrollInit(actionsPanel, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        return getContentHeight();
      }
    });
  };

  var initSettings = function initSettings() {
    KTUtil.scrollInit(settingsPanel, {
      disableForMobile: true,
      resetHeightOnDestroy: true,
      handleWindowResize: true,
      height: function height() {
        return getContentHeight();
      }
    });
  };

  var updatePerfectScrollbars = function updatePerfectScrollbars() {
    $(panel).find('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
      KTUtil.scrollUpdate(notificationPanel);
      KTUtil.scrollUpdate(actionsPanel);
      KTUtil.scrollUpdate(settingsPanel);
    });
  };

  return {
    init: function init() {
      initOffcanvas();
      initNotifications();
      initActions();
      initSettings();
      updatePerfectScrollbars();
    }
  };
}(); // Init on page load completed


KTUtil.ready(function () {
  KTQuickPanel.init();
});

/***/ }),

/***/ "./resources/assets/js/global/layout/quick-search.js":
/*!***********************************************************!*\
  !*** ./resources/assets/js/global/layout/quick-search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KTQuickSearch = function KTQuickSearch() {
  var target;
  var form;
  var input;
  var closeIcon;
  var resultWrapper;
  var resultDropdown;
  var resultDropdownToggle;
  var inputGroup;
  var query = '';
  var hasResult = false;
  var timeout = false;
  var isProcessing = false;
  var requestTimeout = 200; // ajax request fire timeout in milliseconds

  var spinnerClass = 'spinner spinner--input spinner--sm spinner--brand spinner--right';
  var resultClass = 'quick-search--has-result';
  var minLength = 2;

  var showProgress = function showProgress() {
    isProcessing = true;
    KTUtil.addClass(inputGroup, spinnerClass);

    if (closeIcon) {
      KTUtil.hide(closeIcon);
    }
  };

  var hideProgress = function hideProgress() {
    isProcessing = false;
    KTUtil.removeClass(inputGroup, spinnerClass);

    if (closeIcon) {
      if (input.value.length < minLength) {
        KTUtil.hide(closeIcon);
      } else {
        KTUtil.show(closeIcon, 'flex');
      }
    }
  };

  var showDropdown = function showDropdown() {
    if (resultDropdownToggle && !KTUtil.hasClass(resultDropdown, 'show')) {
      $(resultDropdownToggle).dropdown('toggle');
      $(resultDropdownToggle).dropdown('update');
    }
  };

  var hideDropdown = function hideDropdown() {
    if (resultDropdownToggle && KTUtil.hasClass(resultDropdown, 'show')) {
      $(resultDropdownToggle).dropdown('toggle');
    }
  };

  var processSearch = function processSearch() {
    if (hasResult && query === input.value) {
      hideProgress();
      KTUtil.addClass(target, resultClass);
      showDropdown();
      KTUtil.scrollUpdate(resultWrapper);
      return;
    }

    query = input.value;
    KTUtil.removeClass(target, resultClass);
    showProgress();
    hideDropdown();
    setTimeout(function () {
      $.ajax({
        url: 'https://keenthemes.com/keen/tools/preview/inc/api/quick_search.php',
        data: {
          query: query
        },
        dataType: 'html',
        success: function success(res) {
          hasResult = true;
          hideProgress();
          KTUtil.addClass(target, resultClass);
          KTUtil.setHTML(resultWrapper, res);
          showDropdown();
          KTUtil.scrollUpdate(resultWrapper);
        },
        error: function error(res) {
          hasResult = false;
          hideProgress();
          KTUtil.addClass(target, resultClass);
          KTUtil.setHTML(resultWrapper, '<span class="quick-search__message">Connection error. Pleae try again later.</div>');
          showDropdown();
          KTUtil.scrollUpdate(resultWrapper);
        }
      });
    }, 1000);
  };

  var handleCancel = function handleCancel(e) {
    input.value = '';
    query = '';
    hasResult = false;
    KTUtil.hide(closeIcon);
    KTUtil.removeClass(target, resultClass);
    hideDropdown();
  };

  var handleSearch = function handleSearch() {
    if (input.value.length < minLength) {
      hideProgress();
      hideDropdown();
      return;
    }

    if (isProcessing == true) {
      return;
    }

    if (timeout) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(function () {
      processSearch();
    }, requestTimeout);
  };

  return {
    init: function init(element) {
      // Init
      target = element;
      form = KTUtil.find(target, '.quick-search__form');
      input = KTUtil.find(target, '.quick-search__input');
      closeIcon = KTUtil.find(target, '.quick-search__close');
      resultWrapper = KTUtil.find(target, '.quick-search__wrapper');
      resultDropdown = KTUtil.find(target, '.dropdown-menu');
      resultDropdownToggle = KTUtil.find(target, '[data-toggle="dropdown"]');
      inputGroup = KTUtil.find(target, '.input-group'); // Attach input keyup handler

      KTUtil.addEvent(input, 'keyup', handleSearch);
      KTUtil.addEvent(input, 'focus', handleSearch); // Prevent enter click

      form.onkeypress = function (e) {
        var key = e.charCode || e.keyCode || 0;

        if (key == 13) {
          e.preventDefault();
        }
      };

      KTUtil.addEvent(closeIcon, 'click', handleCancel);
    }
  };
};

var KTQuickSearchMobile = KTQuickSearch; // Init on page load completed

KTUtil.ready(function () {
  if (KTUtil.get('quick_search_dropdown')) {
    KTQuickSearch().init(KTUtil.get('quick_search_dropdown'));
  }

  if (KTUtil.get('quick_search_inline')) {
    KTQuickSearchMobile().init(KTUtil.get('quick_search_inline'));
  }

  if (KTUtil.get('quick_search_offcanvas')) {
    KTQuickSearchMobile().init(KTUtil.get('quick_search_offcanvas'));
  }
});

/***/ }),

/***/ "./resources/assets/js/global/template.js":
/*!************************************************!*\
  !*** ./resources/assets/js/global/template.js ***!
  \************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tooltip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tooltip.js */ "./node_modules/tooltip.js/dist/esm/tooltip.js");



/**
 * Define the output of this file. The output of CSS and JS file will be auto detected.
 *
 * @output js/template
 */
// Global Libraire

__webpack_require__(/*! perfect-scrollbar/css/perfect-scrollbar.css */ "./node_modules/perfect-scrollbar/css/perfect-scrollbar.css");

window.wNumb = __webpack_require__(/*! wnumb */ "./node_modules/wnumb/wNumb.js");
window.Sticky = __webpack_require__(/*! sticky-js */ "./node_modules/sticky-js/index.js");
window.PerfectScrollbar = __webpack_require__(/*! perfect-scrollbar/dist/perfect-scrollbar */ "./node_modules/perfect-scrollbar/dist/perfect-scrollbar.js");
window.Cookies = __webpack_require__(/*! js-cookie */ "./node_modules/js-cookie/src/js.cookie.js");
window.Tooltip = tooltip_js__WEBPACK_IMPORTED_MODULE_0__["default"]; // Shopper"s plugins

window.KTUtil = __webpack_require__(/*! ./components/base/util */ "./resources/assets/js/global/components/base/util.js");
window.KTApp = __webpack_require__(/*! ./components/base/app */ "./resources/assets/js/global/components/base/app.js");
window.KTAvatar = __webpack_require__(/*! ./components/base/avatar */ "./resources/assets/js/global/components/base/avatar.js");
window.KTDialog = __webpack_require__(/*! ./components/base/dialog */ "./resources/assets/js/global/components/base/dialog.js");
window.KTHeader = __webpack_require__(/*! ./components/base/header */ "./resources/assets/js/global/components/base/header.js");
window.KTMenu = __webpack_require__(/*! ./components/base/menu */ "./resources/assets/js/global/components/base/menu.js");
window.KTOffcanvas = __webpack_require__(/*! ./components/base/offcanvas */ "./resources/assets/js/global/components/base/offcanvas.js");
window.KTPortlet = __webpack_require__(/*! ./components/base/portlet */ "./resources/assets/js/global/components/base/portlet.js");
window.KTScrolltop = __webpack_require__(/*! ./components/base/scrolltop */ "./resources/assets/js/global/components/base/scrolltop.js");
window.KTToggle = __webpack_require__(/*! ./components/base/toggle */ "./resources/assets/js/global/components/base/toggle.js"); // Layout scripts

window.KTLayout = __webpack_require__(/*! ./layout/layout */ "./resources/assets/js/global/layout/layout.js");
window.KTLib = __webpack_require__(/*! ./layout/lib */ "./resources/assets/js/global/layout/lib.js");

__webpack_require__(/*! ./layout/offcanvas-panel */ "./resources/assets/js/global/layout/offcanvas-panel.js");

__webpack_require__(/*! ./layout/quick-panel */ "./resources/assets/js/global/layout/quick-panel.js");

__webpack_require__(/*! ./layout/quick-search */ "./resources/assets/js/global/layout/quick-search.js");

/***/ }),

/***/ 1:
/*!******************************************************!*\
  !*** multi ./resources/assets/js/global/template.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/mckenzie/Sites/packages/laravel-shopper-v6/packages/shopper/framework/resources/assets/js/global/template.js */"./resources/assets/js/global/template.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL2Nzcy9wZXJmZWN0LXNjcm9sbGJhci5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy1jb29raWUvc3JjL2pzLmNvb2tpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvY3NzL3BlcmZlY3Qtc2Nyb2xsYmFyLmNzcz9kMDhkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9kaXN0L3BlcmZlY3Qtc2Nyb2xsYmFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGlja3ktanMvZGlzdC9zdGlja3kuY29tcGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RpY2t5LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b29sdGlwLmpzL2Rpc3QvZXNtL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd251bWIvd051bWIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9nbG9iYWwvY29tcG9uZW50cy9iYXNlL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC9jb21wb25lbnRzL2Jhc2UvYXZhdGFyLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvZ2xvYmFsL2NvbXBvbmVudHMvYmFzZS9kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9nbG9iYWwvY29tcG9uZW50cy9iYXNlL2hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC9jb21wb25lbnRzL2Jhc2UvbWVudS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC9jb21wb25lbnRzL2Jhc2Uvb2ZmY2FudmFzLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvZ2xvYmFsL2NvbXBvbmVudHMvYmFzZS9wb3J0bGV0LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvZ2xvYmFsL2NvbXBvbmVudHMvYmFzZS9zY3JvbGx0b3AuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9nbG9iYWwvY29tcG9uZW50cy9iYXNlL3RvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC9jb21wb25lbnRzL2Jhc2UvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC9sYXlvdXQvbGF5b3V0LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvZ2xvYmFsL2xheW91dC9saWIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9nbG9iYWwvbGF5b3V0L29mZmNhbnZhcy1wYW5lbC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC9sYXlvdXQvcXVpY2stcGFuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9nbG9iYWwvbGF5b3V0L3F1aWNrLXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2dsb2JhbC90ZW1wbGF0ZS5qcyJdLCJuYW1lcyI6WyJLVEFwcCIsImNvbG9ycyIsImluaXRUb29sdGlwIiwiZWwiLCJza2luIiwiZGF0YSIsIndpZHRoIiwidHJpZ2dlclZhbHVlIiwicGxhY2VtZW50IiwidG9vbHRpcCIsInRyaWdnZXIiLCJ0ZW1wbGF0ZSIsImluaXRUb29sdGlwcyIsIiQiLCJlYWNoIiwiaW5pdFBvcG92ZXIiLCJwb3BvdmVyIiwiaW5pdFBvcG92ZXJzIiwiaW5pdEZpbGVJbnB1dCIsIm9uIiwiZmlsZU5hbWUiLCJ2YWwiLCJuZXh0IiwiYWRkQ2xhc3MiLCJodG1sIiwiaW5pdFBvcnRsZXQiLCJvcHRpb25zIiwicG9ydGxldCIsIktUUG9ydGxldCIsImluaXRQb3J0bGV0cyIsImluaXRTY3JvbGwiLCJLVFV0aWwiLCJzY3JvbGxJbml0IiwibW9iaWxlTmF0aXZlU2Nyb2xsIiwiaGFuZGxlV2luZG93UmVzaXplIiwicmVtZW1iZXJQb3NpdGlvbiIsImhlaWdodCIsImlzSW5SZXNwb25zaXZlUmFuZ2UiLCJpbml0QWxlcnRzIiwiY2xvc2VzdCIsImhpZGUiLCJpbml0U3RpY2t5Iiwic3RpY2t5IiwiU3RpY2t5IiwiaW5pdEFic29sdXRlRHJvcGRvd24iLCJjb250ZXh0IiwiZHJvcGRvd25NZW51IiwiZSIsInRhcmdldCIsImZpbmQiLCJhcHBlbmQiLCJkZXRhY2giLCJjc3MiLCJwb3NpdGlvbiIsInJlbGF0ZWRUYXJnZXQiLCJpbml0QWJzb2x1dGVEcm9wZG93bnMiLCJsZW5ndGgiLCJpbml0IiwiaW5pdENvbXBvbmVudHMiLCJibG9jayIsImV4dGVuZCIsIm9wYWNpdHkiLCJvdmVybGF5Q29sb3IiLCJ0eXBlIiwic2l6ZSIsInN0YXRlIiwiY2VudGVyWCIsImNlbnRlclkiLCJtZXNzYWdlIiwic2hhZG93IiwidmVyc2lvbiIsInNwaW5uZXIiLCJjbGFzc2VzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZ2V0IiwicHJlcGVuZCIsImlubmVySFRNTCIsImFjdHVhbFdpZHRoIiwicmVtb3ZlIiwicGFyYW1zIiwidG9wIiwibGVmdCIsImJvcmRlciIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJvdmVybGF5Q1NTIiwiY3Vyc29yIiwiekluZGV4Iiwib25VbmJsb2NrIiwiYmxvY2tVSSIsInVuYmxvY2siLCJ1bmJsb2NrVUkiLCJibG9ja1BhZ2UiLCJ1bmJsb2NrUGFnZSIsInByb2dyZXNzIiwiYWxpZ25tZW50IiwidW5wcm9ncmVzcyIsImF0dHIiLCJyZW1vdmVDbGFzcyIsInJlbW92ZUF0dHIiLCJnZXRTdGF0ZUNvbG9yIiwibmFtZSIsImdldEJhc2VDb2xvciIsImxldmVsIiwibW9kdWxlIiwiZXhwb3J0cyIsIktUQXBwT3B0aW9ucyIsInJlYWR5IiwiS1RBdmF0YXIiLCJlbGVtZW50SWQiLCJ0aGUiLCJlbGVtZW50IiwiYm9keSIsImRlZmF1bHRPcHRpb25zIiwiUGx1Z2luIiwiY29uc3RydWN0IiwiaGFzIiwiYnVpbGQiLCJzZXQiLCJldmVudHMiLCJpbnB1dCIsImhvbGRlciIsImNhbmNlbCIsInNyYyIsImRlZXBFeHRlbmQiLCJhZGRFdmVudCIsInByZXZlbnREZWZhdWx0IiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsInZhbHVlIiwiZXZlbnRUcmlnZ2VyIiwiaSIsImV2ZW50Iiwib25lIiwiZmlyZWQiLCJoYW5kbGVyIiwiY2FsbCIsInB1c2giLCJzZXREZWZhdWx0cyIsImFwcGx5IiwiS1REaWFsb2ciLCJzaG93Iiwic2V0SFRNTCIsImFwcGVuZENoaWxkIiwic2hvd24iLCJoaWRkZW4iLCJLVEhlYWRlciIsInVuZGVmaW5lZCIsImNsYXNzaWMiLCJvZmZzZXQiLCJtb2JpbGUiLCJkZXNrdG9wIiwibWluaW1pemUiLCJsYXN0U2Nyb2xsVG9wIiwiZXZlbnRUcmlnZ2VyU3RhdGUiLCJ2aWV3cG9ydEhlaWdodCIsImdldFZpZXdQb3J0IiwiZG9jdW1lbnRIZWlnaHQiLCJnZXREb2N1bWVudEhlaWdodCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvZmYiLCJzdCIsImdldFNjcm9sbFRvcCIsImFyZ3MiLCJLVE1lbnUiLCJzY3JvbGwiLCJhY2NvcmRpb24iLCJzbGlkZVNwZWVkIiwiYXV0b1Njcm9sbCIsImF1dG9TY3JvbGxTcGVlZCIsImV4cGFuZEFsbCIsImRyb3Bkb3duIiwidGltZW91dCIsInJlc2V0IiwiZXZlbnRIYW5kbGVycyIsInBhdXNlRHJvcGRvd25Ib3ZlclRpbWUiLCJ1aWQiLCJnZXRVbmlxdWVJRCIsInVwZGF0ZSIsInJlbG9hZCIsInJlc2V0U3VibWVudVByb3BzIiwiaGFuZGxlU3VibWVudUFjY29yZGlvbiIsImdldFN1Ym1lbnVNb2RlIiwiaXNDb25kaXRpb25hbFN1Ym1lbnVEcm9wZG93biIsImhhbmRsZVN1Ym1lbnVEcm9kb3duSG92ZXJFbnRlciIsImhhbmRsZVN1Ym1lbnVEcm9kb3duSG92ZXJFeGl0IiwiaGFuZGxlU3VibWVudURyb3Bkb3duQ2xpY2siLCJoYW5kbGVTdWJtZW51RHJvcGRvd25UYWJDbGljayIsImhhbmRsZUxpbmtDbGljayIsInNjcm9sbERlc3Ryb3kiLCJ3aW5kb3dTY3JvbGwiLCJyZXNldEhlaWdodE9uRGVzdHJveSIsInNjcm9sbFVwZGF0ZSIsInNjcm9sbFRvcCIsImhhc0F0dHIiLCJpc3NldCIsInN1Ym1lbnUiLCJoYXNDbGFzc2VzIiwibW9kZSIsInRhYmxldCIsInN1Ym1lbnVzIiwiZmluZEFsbCIsImxlbiIsInJlc3VtZURyb3Bkb3duSG92ZXIiLCJpdGVtIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiY2xlYXJUaW1lb3V0Iiwic2hvd1N1Ym1lbnVEcm9wZG93biIsInRpbWUiLCJzZXRUaW1lb3V0IiwiaGlkZVN1Ym1lbnVEcm9wZG93biIsInNldEF0dHJpYnV0ZSIsImhhc0NsYXNzIiwiaGlkZVN1Ym1lbnVEcm9wZG93bnMiLCJoYW5kbGVTdWJtZW51RHJvcGRvd25DbG9zZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxdWVyeSIsImxpIiwiY2hpbGQiLCJzcGVlZCIsImhhc0Nsb3NhYmxlcyIsInN1Ym5hdiIsImNsb3NhYmxlcyIsImNoaWxkcmVuIiwiZWxfIiwic3VibWVudV8iLCJzbGlkZVVwIiwic2xpZGVEb3duIiwic2Nyb2xsVG9JdGVtIiwic2Nyb2xsVG8iLCJjbGFzc0Fsc28iLCJpdGVtcyIsImoiLCJjbnQiLCJsaXN0IiwiY29udGFpbnMiLCJjcmVhdGVTdWJtZW51RHJvcGRvd25DbGlja0Ryb3BvZmYiLCJkcm9wb2ZmIiwic3RvcFByb3BhZ2F0aW9uIiwicGF1c2VEcm9wZG93bkhvdmVyIiwiZGF0ZSIsIkRhdGUiLCJnZXRUaW1lIiwicmVzZXRBY3RpdmVJdGVtIiwicGFyZW50cyIsImlfIiwibGVuXyIsInNldEFjdGl2ZUl0ZW0iLCJnZXRCcmVhZGNydW1icyIsImJyZWFkY3J1bWJzIiwibGluayIsInRleHQiLCJ0aXRsZSIsImhyZWYiLCJzdWJtZW51TGluayIsInJldmVyc2UiLCJnZXRQYWdlVGl0bGUiLCJyZW1vdmVFdmVudCIsInNjcm9sbFJlSW5pdCIsImhpZGVEcm9wZG93biIsImhpZGVEcm9wZG93bnMiLCJhZGRSZXNpemVIYW5kbGVyIiwicGFyZW50Tm9kZSIsIktUT2ZmY2FudmFzIiwib3ZlcmxheSIsImNsYXNzQmFzZSIsImJhc2VDbGFzcyIsImNsYXNzU2hvd24iLCJjbGFzc092ZXJsYXkiLCJ0b2dnbGVCeSIsInRvZ2dsZSIsImNsb3NlQnkiLCJwYXJzZUludCIsImlzU2hvd24iLCJ0b2dnbGVyQ2xhc3MiLCJpbnNlcnRBZnRlciIsInRyYW5zaXRpb25FbmQiLCJpZCIsImJvZHlUb2dnbGVTcGVlZCIsInRvb2x0aXBzIiwidG9vbHMiLCJjb2xsYXBzZSIsImV4cGFuZCIsImZ1bGxzY3JlZW4iLCJoZWFkIiwiZm9vdCIsInNldHVwVG9vbHRpcHMiLCJvblNjcm9sbFN0aWNreSIsImlzTmFOIiwidXBkYXRlU3RpY2t5IiwicmVzZXRTdGlja3kiLCJGdW5jdGlvbiIsInJpZ2h0IiwicmVtb3ZlVG9vbHRpcHMiLCJzZXRDb250ZW50IiwiZ2V0Qm9keSIsImdldFNlbGYiLCJjb2xsYXBzZWQiLCJmdWxsc2NyZWVuT24iLCJ0aXAiLCJUb29sdGlwIiwiZGlzcG9zZSIsInVwZGF0ZVRpdGxlQ29udGVudCIsImQiLCJoZWlnaHQxIiwiaGVpZ2h0MiIsImRlc3Ryb3lTdGlja3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidW5GdWxsc2NyZWVuIiwiS1RTY3JvbGx0b3AiLCJ0b2dnbGVDbGFzcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1hdGNoIiwiaGFuZGxlIiwicG9zIiwicGFnZVlPZmZzZXQiLCJLVFRvZ2dsZSIsInRvZ2dsZXJTdGF0ZSIsInRhcmdldFN0YXRlIiwidG9nZ2xlT24iLCJ0b2dnbGVPZmYiLCJnZXRTdGF0ZSIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJzIiwiYW5jZXN0b3IiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJlbnRFbGVtZW50IiwiZWxlbSIsInJlbW92ZUNoaWxkIiwibGFzdFRpbWUiLCJ2ZW5kb3JzIiwieCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2FsbGJhY2siLCJjdXJyVGltZSIsInRpbWVUb0NhbGwiLCJNYXRoIiwibWF4IiwiYXJyIiwiZm9yRWFjaCIsImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJhcmdBcnIiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwiZG9jRnJhZyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJhcmdJdGVtIiwiaXNOb2RlIiwiTm9kZSIsImNyZWF0ZVRleHROb2RlIiwiU3RyaW5nIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsIkRvY3VtZW50IiwiRG9jdW1lbnRGcmFnbWVudCIsIktUVXRpbEVsZW1lbnREYXRhU3RvcmUiLCJLVFV0aWxFbGVtZW50RGF0YVN0b3JlSUQiLCJLVFV0aWxEZWxlZ2F0ZWRFdmVudEhhbmRsZXJzIiwicmVzaXplSGFuZGxlcnMiLCJicmVha3BvaW50cyIsInNtIiwibWQiLCJsZyIsInhsIiwiX3dpbmRvd1Jlc2l6ZUhhbmRsZXIiLCJfcnVuUmVzaXplSGFuZGxlcnMiLCJkZWxheSIsInJlbW92ZVJlc2l6ZUhhbmRsZXIiLCJydW5SZXNpemVIYW5kbGVycyIsInJlc2l6ZSIsIkV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImV2dCIsImNyZWF0ZUV2ZW50IiwiaW5pdFVJRXZlbnQiLCJnZXRVUkxQYXJhbSIsInBhcmFtTmFtZSIsInNlYXJjaFN0cmluZyIsImxvY2F0aW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwic3BsaXQiLCJ1bmVzY2FwZSIsImlzTW9iaWxlRGV2aWNlIiwiZ2V0QnJlYWtwb2ludCIsImlzRGVza3RvcERldmljZSIsImEiLCJicmVha3BvaW50IiwicHJlZml4IiwiZmxvb3IiLCJyYW5kb20iLCJvYmoiLCJrZXlzIiwic3RvbmUiLCJpbmRleE9mIiwiRXJyb3IiLCJzaGlmdCIsImdldEhpZ2hlc3RaaW5kZXgiLCJoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQiLCJzbGVlcCIsIm1pbGxpc2Vjb25kcyIsInN0YXJ0IiwiZ2V0UmFuZG9tSW50IiwibWluIiwiaXNBbmd1bGFyVmVyc2lvbiIsIlpvbmUiLCJvdXQiLCJrZXkiLCJub2RlVHlwZSIsImdldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiZ2V0QnlJRCIsImdldEJ5VGFnIiwiZ2V0QnlDbGFzcyIsImNsYXNzZXNBcnIiLCJ0cmltIiwiY2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiUmVnRXhwIiwidGVzdCIsImNsYXNzTmFtZXMiLCJhZGQiLCJyZXBsYWNlIiwidHJpZ2dlckN1c3RvbUV2ZW50IiwiZXZlbnROYW1lIiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJpbml0Q3VzdG9tRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJub2RlIiwiZG9jIiwib3duZXJEb2N1bWVudCIsImV2ZW50Q2xhc3MiLCJidWJibGVzIiwiaW5pdEV2ZW50Iiwic3ludGhldGljIiwiZmlyZUV2ZW50IiwiY3JlYXRlRXZlbnRPYmplY3QiLCJpbmRleCIsImVsbSIsImMiLCJzdHJpbmciLCJldmVudFRyaWdnZXJlZCIsImN1cnJlbnRUYXJnZXQiLCJkYXRhc2V0IiwidHJpZ2dlcmVkIiwicGFyZW50IiwicXVlcnlTZWxlY3RvciIsInJlZmVyZW5jZU5vZGUiLCJuZXh0U2libGluZyIsInNlbGVjdG9yIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsImxvZyIsImNoaWxkTm9kZXMiLCJsIiwicCIsImYiLCJ0YWdOYW1lIiwiY3VzdG9tRGF0YVRhZyIsIm91dGVyV2lkdGgiLCJtYXJnaW4iLCJwYXJzZUZsb2F0Iiwib2Zmc2V0V2lkdGgiLCJyZWN0Iiwid2luIiwiZ2V0Q2xpZW50UmVjdHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJkZWZhdWx0VmlldyIsInBhZ2VYT2Zmc2V0IiwidmlzaWJsZSIsIm9mZnNldEhlaWdodCIsImFuaW1hdGUiLCJmcm9tIiwidG8iLCJkdXJhdGlvbiIsImVhc2luZyIsImRvbmUiLCJlYXNpbmdzIiwibGluZWFyIiwidCIsImIiLCJyQUYiLCJjYW5jZWxlZCIsImNoYW5nZSIsImxvb3AiLCJ0aW1lc3RhbXAiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImFjdHVhbENzcyIsInByb3AiLCJjYWNoZSIsIkhUTUxFbGVtZW50Iiwic3R5bGUiLCJjc3NUZXh0IiwiYWN0dWFsSGVpZ2h0IiwiZ2V0U2Nyb2xsIiwibWV0aG9kIiwic2VsZiIsImJyb3dzZXJTdXBwb3J0c0JveE1vZGVsIiwic3R5bGVQcm9wIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRvTG93ZXJDYXNlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImN1cnJlbnRTdHlsZSIsInN0ciIsImxldHRlciIsInRvVXBwZXJDYXNlIiwib2xkTGVmdCIsIm9sZFJzTGVmdCIsInJ1bnRpbWVTdHlsZSIsInBpeGVsTGVmdCIsInNsaWRlIiwiZGlyIiwicmVjYWxjTWF4SGVpZ2h0IiwiY2FsY0hlaWdodCIsImNhbGNQYWRkaW5nVG9wIiwiY2FsY1BhZGRpbmdCb3R0b20iLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImRpc3BsYXkiLCJvdmVyZmxvdyIsImV2ZW50SWQiLCJ0YXJnZXRzIiwib25ldGltZSIsImNhbGxlZSIsImhhc2giLCJjaHIiLCJjaGFyQ29kZUF0IiwiYW5pbWF0ZUNsYXNzIiwiYW5pbWF0aW9uTmFtZSIsImFuaW1hdGlvbiIsImFuaW1hdGlvbnMiLCJPQW5pbWF0aW9uIiwiTW96QW5pbWF0aW9uIiwiV2Via2l0QW5pbWF0aW9uIiwibXNBbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwidHJhbnNpdGlvbnMiLCJPVHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJXZWJraXRUcmFuc2l0aW9uIiwibXNUcmFuc2l0aW9uIiwiYW5pbWF0aW9uRW5kIiwiYW5pbWF0ZURlbGF5IiwiYW5pbWF0ZUR1cmF0aW9uIiwidGFyZ2V0UG9zIiwic2Nyb2xsUG9zIiwiaXNBcnJheSIsImF0dGFjaEV2ZW50IiwicmVhZHlTdGF0ZSIsImlzRW1wdHkiLCJudW1iZXJTdHJpbmciLCJuU3RyIiwieDEiLCJ4MiIsInJneCIsImRldGVjdElFIiwidWEiLCJtc2llIiwidHJpZGVudCIsInJ2IiwiZWRnZSIsImlzUlRMIiwicHMiLCJkaXNhYmxlRm9yTW9iaWxlIiwiZGVzdHJveSIsImRlc2t0b3BOYXRpdmVTY3JvbGwiLCJQZXJmZWN0U2Nyb2xsYmFyIiwid2hlZWxTcGVlZCIsInN3aXBlRWFzaW5nIiwid2hlZWxQcm9wYWdhdGlvbiIsIm1pblNjcm9sbGJhckxlbmd0aCIsIm1heFNjcm9sbGJhckxlbmd0aCIsInN1cHByZXNzU2Nyb2xsWCIsIkNvb2tpZXMiLCJzY3JvbGxVcGRhdGVBbGwiLCJzY3JvbGxlcnMiLCJzY3JvbGxlclVwZGF0ZSIsImdldEhUTUwiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxpbmdFbGVtZW50IiwiS1RMYXlvdXQiLCJhc2lkZSIsImFzaWRlTWVudSIsImFzaWRlTWVudU9mZmNhbnZhcyIsInBhZ2VTdGlja3lQb3J0bGV0IiwiaW5pdEFzaWRlIiwibWVudSIsIm1lbnVEZXNrdG9wTW9kZSIsIndpbmRvd0hlaWdodCIsInNlY29uZGFyeSIsInNlY29uZGFyeVBhZGRpbmdUb3AiLCJzZWNvbmRhcnlQYWRkaW5nQm90dG9tIiwidG9wSGVpZ2h0IiwiYm90dG9tIiwiYm90dG9tUGFkZGluZ1RvcCIsImJvdHRvbVBhZGRpbmdCb3R0b24iLCJpbml0U2Nyb2xsdG9wIiwic2Nyb2xsdG9wIiwiaW5pdFBhZ2VTdGlja3lQb3J0bGV0IiwiYXNpZGVQcmltYXJ5V2lkdGgiLCJhc2lkZVNlY29uZGFyeVdpZHRoIiwicG9ybGV0RWwiLCJwb3J0bGV0V2lkdGgiLCJib2R5V2lkdGgiLCJwb3J0bGV0T2Zmc2V0TGVmdCIsInN3YWwiLCJnZXRBc2lkZU1lbnUiLCJjbG9zZU1vYmlsZUFzaWRlTWVudU9mZmNhbnZhcyIsImNsb3NlTW9iaWxlSGVhZGVyTWVudU9mZmNhbnZhcyIsImhlYWRlck1lbnVPZmZjYW52YXMiLCJLVExpYiIsImluaXRNaW5pQ2hhcnQiLCJjb2xvciIsImZpbGwiLCJjb25maWciLCJsYWJlbHMiLCJkYXRhc2V0cyIsImxhYmVsIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsInBvaW50SG92ZXJSYWRpdXMiLCJwb2ludEhvdmVyQm9yZGVyV2lkdGgiLCJwb2ludEJhY2tncm91bmRDb2xvciIsIkNoYXJ0IiwiaGVscGVycyIsImFscGhhIiwicmdiU3RyaW5nIiwicG9pbnRCb3JkZXJDb2xvciIsInBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJwb2ludEhvdmVyQm9yZGVyQ29sb3IiLCJlbmFibGVkIiwiaW50ZXJzZWN0IiwiYm9keVNwYWNpbmciLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiZGlzcGxheUNvbG9ycyIsInRpdGxlRm9udENvbG9yIiwiY29ybmVyUmFkaXVzIiwiZm9vdGVyU3BhY2luZyIsInRpdGxlU3BhY2luZyIsImxlZ2VuZCIsInVzZVBvaW50U3R5bGUiLCJyZXNwb25zaXZlIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsImhvdmVyIiwic2NhbGVzIiwieEF4ZXMiLCJncmlkTGluZXMiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJ5QXhlcyIsImVsZW1lbnRzIiwibGluZSIsInRlbnNpb24iLCJwb2ludCIsInJhZGl1cyIsImxheW91dCIsImNoYXJ0IiwiaW5pdE1lZGl1bUNoYXJ0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImdyYWRpZW50IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJtYWluQ29uZmlnIiwidGlja3MiLCJiZWdpbkF0WmVybyIsImRyYXdCb3JkZXIiLCJvZmZzZXRHcmlkTGluZXMiLCJkcmF3VGlja3MiLCJob3ZlclJhZGl1cyIsImhvdmVyQm9yZGVyV2lkdGgiLCJLVE9mZmNhbnZhc1BhbmVsIiwibm90aWZpY2F0aW9uUGFuZWwiLCJxdWlja0FjdGlvbnNQYW5lbCIsInByb2ZpbGVQYW5lbCIsInNlYXJjaFBhbmVsIiwiaW5pdE5vdGlmaWNhdGlvbnMiLCJvZmZjYW52YXMiLCJpbml0UXVjaWtBY3Rpb25zIiwiaW5pdFByb2ZpbGUiLCJpbml0U2VhcmNoIiwiZm9ybSIsIndyYXBwZXIiLCJLVFF1aWNrUGFuZWwiLCJwYW5lbCIsImFjdGlvbnNQYW5lbCIsInNldHRpbmdzUGFuZWwiLCJnZXRDb250ZW50SGVpZ2h0IiwibmF2IiwiY29udGVudCIsImluaXRPZmZjYW52YXMiLCJpbml0QWN0aW9ucyIsImluaXRTZXR0aW5ncyIsInVwZGF0ZVBlcmZlY3RTY3JvbGxiYXJzIiwiS1RRdWlja1NlYXJjaCIsImNsb3NlSWNvbiIsInJlc3VsdFdyYXBwZXIiLCJyZXN1bHREcm9wZG93biIsInJlc3VsdERyb3Bkb3duVG9nZ2xlIiwiaW5wdXRHcm91cCIsImhhc1Jlc3VsdCIsImlzUHJvY2Vzc2luZyIsInJlcXVlc3RUaW1lb3V0Iiwic3Bpbm5lckNsYXNzIiwicmVzdWx0Q2xhc3MiLCJtaW5MZW5ndGgiLCJzaG93UHJvZ3Jlc3MiLCJoaWRlUHJvZ3Jlc3MiLCJzaG93RHJvcGRvd24iLCJwcm9jZXNzU2VhcmNoIiwiYWpheCIsInVybCIsImRhdGFUeXBlIiwic3VjY2VzcyIsInJlcyIsImVycm9yIiwiaGFuZGxlQ2FuY2VsIiwiaGFuZGxlU2VhcmNoIiwib25rZXlwcmVzcyIsImNoYXJDb2RlIiwia2V5Q29kZSIsIktUUXVpY2tTZWFyY2hNb2JpbGUiLCJyZXF1aXJlIiwid051bWIiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHdEQUF3RCw0QkFBNEIsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUgsd0RBQXdELDRCQUE0QixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFLHNDQUFzQywyRUFBMkU7O0FBRWpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLCtDQUErQztBQUMxRSwwQkFBMEIsa0RBQWtEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzVYWTtBQUViOzs7O0FBSUEsSUFBSUEsS0FBSyxHQUFHLFlBQVc7QUFDbkI7QUFDQSxNQUFJQyxNQUFNLEdBQUcsRUFBYjs7QUFFQSxNQUFJQyxZQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFTQyxFQUFULEVBQWE7QUFDM0IsUUFBSUMsSUFBSSxHQUFHRCxFQUFFLENBQUNFLElBQUgsQ0FBUSxNQUFSLElBQWtCLGFBQWFGLEVBQUUsQ0FBQ0UsSUFBSCxDQUFRLE1BQVIsQ0FBL0IsR0FBaUQsRUFBNUQ7QUFDQSxRQUFJQyxLQUFLLEdBQUdILEVBQUUsQ0FBQ0UsSUFBSCxDQUFRLE9BQVIsTUFBcUIsTUFBckIsR0FBOEIsb0JBQTlCLEdBQXFELEVBQWpFO0FBQ0EsUUFBSUUsWUFBWSxHQUFHSixFQUFFLENBQUNFLElBQUgsQ0FBUSxTQUFSLElBQXFCRixFQUFFLENBQUNFLElBQUgsQ0FBUSxTQUFSLENBQXJCLEdBQTBDLE9BQTdEO0FBQ0EsUUFBSUcsU0FBUyxHQUFHTCxFQUFFLENBQUNFLElBQUgsQ0FBUSxXQUFSLElBQXVCRixFQUFFLENBQUNFLElBQUgsQ0FBUSxXQUFSLENBQXZCLEdBQThDLE1BQTlEO0FBRUFGLE1BQUUsQ0FBQ00sT0FBSCxDQUFXO0FBQ1BDLGFBQU8sRUFBRUgsWUFERjtBQUVQSSxjQUFRLEVBQUUseUJBQXlCUCxJQUF6QixHQUFnQyxHQUFoQyxHQUFzQ0UsS0FBdEMsR0FBOEM7Ozs7QUFGakQsS0FBWDtBQU9ILEdBYkQ7O0FBZUEsTUFBSU0sYUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBVztBQUMxQjtBQUNBQyxLQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QkMsSUFBN0IsQ0FBa0MsWUFBVztBQUN6Q1osa0JBQVcsQ0FBQ1csQ0FBQyxDQUFDLElBQUQsQ0FBRixDQUFYO0FBQ0gsS0FGRDtBQUdILEdBTEQ7O0FBT0EsTUFBSUUsWUFBVyxHQUFHLFNBQWRBLFdBQWMsQ0FBU1osRUFBVCxFQUFhO0FBQzNCLFFBQUlDLElBQUksR0FBR0QsRUFBRSxDQUFDRSxJQUFILENBQVEsTUFBUixJQUFrQixhQUFhRixFQUFFLENBQUNFLElBQUgsQ0FBUSxNQUFSLENBQS9CLEdBQWlELEVBQTVEO0FBQ0EsUUFBSUUsWUFBWSxHQUFHSixFQUFFLENBQUNFLElBQUgsQ0FBUSxTQUFSLElBQXFCRixFQUFFLENBQUNFLElBQUgsQ0FBUSxTQUFSLENBQXJCLEdBQTBDLE9BQTdEO0FBRUFGLE1BQUUsQ0FBQ2EsT0FBSCxDQUFXO0FBQ1BOLGFBQU8sRUFBRUgsWUFERjtBQUVQSSxjQUFRLEVBQUU7aUNBQUEsR0FDY1AsSUFEZCxHQUNxQjs7Ozs7QUFIeEIsS0FBWDtBQVNILEdBYkQ7O0FBZUEsTUFBSWEsYUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBVztBQUMxQjtBQUNBSixLQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QkMsSUFBN0IsQ0FBa0MsWUFBVztBQUN6Q0Msa0JBQVcsQ0FBQ0YsQ0FBQyxDQUFDLElBQUQsQ0FBRixDQUFYO0FBQ0gsS0FGRDtBQUdILEdBTEQ7O0FBT0EsTUFBSUssYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFXO0FBQzNCO0FBQ0FMLEtBQUMsQ0FBQyxvQkFBRCxDQUFELENBQXdCTSxFQUF4QixDQUEyQixRQUEzQixFQUFxQyxZQUFXO0FBQzVDLFVBQUlDLFFBQVEsR0FBR1AsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRUSxHQUFSLEVBQWY7QUFDQVIsT0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRUyxJQUFSLENBQWEsb0JBQWIsRUFBbUNDLFFBQW5DLENBQTRDLFVBQTVDLEVBQXdEQyxJQUF4RCxDQUE2REosUUFBN0Q7QUFDSCxLQUhEO0FBSUgsR0FORDs7QUFRQSxNQUFJSyxZQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFTdEIsRUFBVCxFQUFhdUIsT0FBYixFQUFzQjtBQUNwQztBQUNBLFFBQUl2QixFQUFFLEdBQUdVLENBQUMsQ0FBQ1YsRUFBRCxDQUFWO0FBQ0EsUUFBSXdCLE9BQU8sR0FBRyxJQUFJQyxTQUFKLENBQWN6QixFQUFFLENBQUMsQ0FBRCxDQUFoQixFQUFxQnVCLE9BQXJCLENBQWQ7QUFDSCxHQUpEOztBQU1BLE1BQUlHLGFBQVksR0FBRyxTQUFmQSxZQUFlLEdBQVc7QUFDMUI7QUFDQWhCLEtBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCQyxJQUE3QixDQUFrQyxZQUFXO0FBQ3pDLFVBQUlYLEVBQUUsR0FBR1UsQ0FBQyxDQUFDLElBQUQsQ0FBVjs7QUFFQSxVQUFJVixFQUFFLENBQUNFLElBQUgsQ0FBUSw0QkFBUixNQUEwQyxJQUE5QyxFQUFvRDtBQUNoRG9CLG9CQUFXLENBQUN0QixFQUFELEVBQUssRUFBTCxDQUFYOztBQUNBQSxVQUFFLENBQUNFLElBQUgsQ0FBUSw0QkFBUixFQUFzQyxJQUF0QztBQUNIO0FBQ0osS0FQRDtBQVFILEdBVkQ7O0FBWUEsTUFBSXlCLFVBQVUsR0FBRyxTQUFiQSxVQUFhLEdBQVc7QUFDeEJqQixLQUFDLENBQUMsc0JBQUQsQ0FBRCxDQUEwQkMsSUFBMUIsQ0FBK0IsWUFBVztBQUN0QyxVQUFJWCxFQUFFLEdBQUdVLENBQUMsQ0FBQyxJQUFELENBQVY7QUFDQWtCLFlBQU0sQ0FBQ0MsVUFBUCxDQUFrQixJQUFsQixFQUF3QjtBQUNwQkMsMEJBQWtCLEVBQUUsSUFEQTtBQUVwQkMsMEJBQWtCLEVBQUUsSUFGQTtBQUdwQkMsd0JBQWdCLEVBQUdoQyxFQUFFLENBQUNFLElBQUgsQ0FBUSxtQkFBUixLQUFnQyxNQUFoQyxHQUF5QyxJQUF6QyxHQUFnRCxLQUgvQztBQUlwQitCLGNBQU0sRUFBRSxrQkFBVztBQUNmLGNBQUlMLE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsbUJBQTNCLEtBQW1EbEMsRUFBRSxDQUFDRSxJQUFILENBQVEsZUFBUixDQUF2RCxFQUFpRjtBQUM3RSxtQkFBT0YsRUFBRSxDQUFDRSxJQUFILENBQVEsZUFBUixDQUFQO0FBQ0gsV0FGRCxNQUVPO0FBQ0gsbUJBQU9GLEVBQUUsQ0FBQ0UsSUFBSCxDQUFRLFFBQVIsQ0FBUDtBQUNIO0FBQ0o7QUFWbUIsT0FBeEI7QUFZSCxLQWREO0FBZUgsR0FoQkQ7O0FBa0JBLE1BQUlpQyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxHQUFXO0FBQ3hCO0FBQ0F6QixLQUFDLENBQUMsTUFBRCxDQUFELENBQVVNLEVBQVYsQ0FBYSxPQUFiLEVBQXNCLG9CQUF0QixFQUE0QyxZQUFXO0FBQ25ETixPQUFDLENBQUMsSUFBRCxDQUFELENBQVEwQixPQUFSLENBQWdCLFFBQWhCLEVBQTBCQyxJQUExQjtBQUNILEtBRkQ7QUFHSCxHQUxEOztBQU9BLE1BQUlDLFdBQVUsR0FBRyxTQUFiQSxVQUFhLEdBQVc7QUFDeEIsUUFBSUMsTUFBTSxHQUFHLElBQUlDLE1BQUosQ0FBVyxzQkFBWCxDQUFiO0FBQ0gsR0FGRDs7QUFJQSxNQUFJQyxxQkFBb0IsR0FBRyxTQUF2QkEsb0JBQXVCLENBQVNDLE9BQVQsRUFBa0I7QUFDekMsUUFBSUMsWUFBSjs7QUFFQSxRQUFJLENBQUNELE9BQUwsRUFBYztBQUNWO0FBQ0g7O0FBRURoQyxLQUFDLENBQUMsTUFBRCxDQUFELENBQVVNLEVBQVYsQ0FBYSxrQkFBYixFQUFpQzBCLE9BQWpDLEVBQTBDLFVBQVNFLENBQVQsRUFBWTtBQUNyREQsa0JBQVksR0FBR2pDLENBQUMsQ0FBQ2tDLENBQUMsQ0FBQ0MsTUFBSCxDQUFELENBQVlDLElBQVosQ0FBaUIsZ0JBQWpCLENBQWY7QUFDQXBDLE9BQUMsQ0FBQyxNQUFELENBQUQsQ0FBVXFDLE1BQVYsQ0FBaUJKLFlBQVksQ0FBQ0ssTUFBYixFQUFqQjtBQUNBTCxrQkFBWSxDQUFDTSxHQUFiLENBQWlCLFNBQWpCLEVBQTRCLE9BQTVCO0FBQ0FOLGtCQUFZLENBQUNPLFFBQWIsQ0FBc0I7QUFDckIsY0FBTSxXQURlO0FBRXJCLGNBQU0sY0FGZTtBQUdyQixjQUFNeEMsQ0FBQyxDQUFDa0MsQ0FBQyxDQUFDTyxhQUFIO0FBSGMsT0FBdEI7QUFLQSxLQVRELEVBU0duQyxFQVRILENBU00sa0JBVE4sRUFTMEIwQixPQVQxQixFQVNtQyxVQUFTRSxDQUFULEVBQVk7QUFDOUNsQyxPQUFDLENBQUNrQyxDQUFDLENBQUNDLE1BQUgsQ0FBRCxDQUFZRSxNQUFaLENBQW1CSixZQUFZLENBQUNLLE1BQWIsRUFBbkI7QUFDQUwsa0JBQVksQ0FBQ04sSUFBYjtBQUNBLEtBWkQ7QUFhSCxHQXBCRDs7QUFzQkEsTUFBSWUscUJBQXFCLEdBQUcsU0FBeEJBLHFCQUF3QixHQUFXO0FBQ25DMUMsS0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVTSxFQUFWLENBQWEsa0JBQWIsRUFBaUMsVUFBUzRCLENBQVQsRUFBWTtBQUN6QyxVQUFLbEMsQ0FBQyxDQUFDa0MsQ0FBQyxDQUFDQyxNQUFILENBQUQsQ0FBWUMsSUFBWixDQUFpQixzQkFBakIsRUFBeUNPLE1BQXpDLEtBQW9ELENBQXpELEVBQTREO0FBQ3hEO0FBQ0g7O0FBRUQsVUFBSVYsWUFBWSxHQUFHakMsQ0FBQyxDQUFDa0MsQ0FBQyxDQUFDQyxNQUFILENBQUQsQ0FBWUMsSUFBWixDQUFpQixnQkFBakIsQ0FBbkI7QUFFQXBDLE9BQUMsQ0FBQyxNQUFELENBQUQsQ0FBVXFDLE1BQVYsQ0FBaUJKLFlBQVksQ0FBQ0ssTUFBYixFQUFqQjtBQUNBTCxrQkFBWSxDQUFDTSxHQUFiLENBQWlCLFNBQWpCLEVBQTRCLE9BQTVCO0FBQ0FOLGtCQUFZLENBQUNPLFFBQWIsQ0FBc0I7QUFDbEIsY0FBTSxXQURZO0FBRWxCLGNBQU0sY0FGWTtBQUdsQixjQUFNeEMsQ0FBQyxDQUFDa0MsQ0FBQyxDQUFDTyxhQUFIO0FBSFcsT0FBdEI7QUFLSCxLQWREO0FBZ0JBekMsS0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVTSxFQUFWLENBQWEsa0JBQWIsRUFBaUMsVUFBUzRCLENBQVQsRUFBWTtBQUN6QyxVQUFLbEMsQ0FBQyxDQUFDa0MsQ0FBQyxDQUFDQyxNQUFILENBQUQsQ0FBWUMsSUFBWixDQUFpQixzQkFBakIsRUFBeUNPLE1BQXpDLEtBQW9ELENBQXpELEVBQTREO0FBQ3hEO0FBQ0g7O0FBRUQsVUFBSVYsWUFBWSxHQUFHakMsQ0FBQyxDQUFDa0MsQ0FBQyxDQUFDQyxNQUFILENBQUQsQ0FBWUMsSUFBWixDQUFpQixnQkFBakIsQ0FBbkI7QUFFQXBDLE9BQUMsQ0FBQ2tDLENBQUMsQ0FBQ0MsTUFBSCxDQUFELENBQVlFLE1BQVosQ0FBbUJKLFlBQVksQ0FBQ0ssTUFBYixFQUFuQjtBQUNBTCxrQkFBWSxDQUFDTixJQUFiO0FBQ0gsS0FURDtBQVVILEdBM0JEOztBQTZCQSxTQUFPO0FBQ0hpQixRQUFJLEVBQUUsY0FBUy9CLE9BQVQsRUFBa0I7QUFDcEIsVUFBSUEsT0FBTyxJQUFJQSxPQUFPLENBQUN6QixNQUF2QixFQUErQjtBQUMzQkEsY0FBTSxHQUFHeUIsT0FBTyxDQUFDekIsTUFBakI7QUFDSDs7QUFFREQsV0FBSyxDQUFDMEQsY0FBTjtBQUNILEtBUEU7QUFTSEEsa0JBQWMsRUFBRSwwQkFBVztBQUN2QjVCLGdCQUFVOztBQUNWbEIsbUJBQVk7O0FBQ1pLLG1CQUFZOztBQUNacUIsZ0JBQVU7O0FBQ1ZULG1CQUFZOztBQUNaWCxtQkFBYTs7QUFDYnVCLGlCQUFVOztBQUNWYywyQkFBcUI7QUFDeEIsS0FsQkU7QUFvQkgzQyxnQkFBWSxFQUFFLHdCQUFXO0FBQ3JCQSxtQkFBWTtBQUNmLEtBdEJFO0FBd0JIVixlQUFXLEVBQUUscUJBQVNDLEVBQVQsRUFBYTtBQUN0QkQsa0JBQVcsQ0FBQ0MsRUFBRCxDQUFYO0FBQ0gsS0ExQkU7QUE0QkhjLGdCQUFZLEVBQUUsd0JBQVc7QUFDckJBLG1CQUFZO0FBQ2YsS0E5QkU7QUFnQ0hGLGVBQVcsRUFBRSxxQkFBU1osRUFBVCxFQUFhO0FBQ3RCWSxrQkFBVyxDQUFDWixFQUFELENBQVg7QUFDSCxLQWxDRTtBQW9DSHNCLGVBQVcsRUFBRSxxQkFBU3RCLEVBQVQsRUFBYXVCLE9BQWIsRUFBc0I7QUFDL0JELGtCQUFXLENBQUN0QixFQUFELEVBQUt1QixPQUFMLENBQVg7QUFDSCxLQXRDRTtBQXdDSEcsZ0JBQVksRUFBRSx3QkFBVztBQUNyQkEsbUJBQVk7QUFDZixLQTFDRTtBQTRDSFksY0FBVSxFQUFFLHNCQUFXO0FBQ25CQSxpQkFBVTtBQUNiLEtBOUNFO0FBZ0RIRyx3QkFBb0IsRUFBRSw4QkFBU0MsT0FBVCxFQUFrQjtBQUNwQ0QsMkJBQW9CLENBQUNDLE9BQUQsQ0FBcEI7QUFDSCxLQWxERTtBQW9ESGMsU0FBSyxFQUFFLGVBQVNYLE1BQVQsRUFBaUJ0QixPQUFqQixFQUEwQjtBQUM3QixVQUFJdkIsRUFBRSxHQUFHVSxDQUFDLENBQUNtQyxNQUFELENBQVY7QUFFQXRCLGFBQU8sR0FBR2IsQ0FBQyxDQUFDK0MsTUFBRixDQUFTLElBQVQsRUFBZTtBQUNyQkMsZUFBTyxFQUFFLElBRFk7QUFFckJDLG9CQUFZLEVBQUUsU0FGTztBQUdyQkMsWUFBSSxFQUFFLEVBSGU7QUFJckJDLFlBQUksRUFBRSxFQUplO0FBS3JCQyxhQUFLLEVBQUUsT0FMYztBQU1yQkMsZUFBTyxFQUFFLElBTlk7QUFPckJDLGVBQU8sRUFBRSxJQVBZO0FBUXJCQyxlQUFPLEVBQUUsRUFSWTtBQVNyQkMsY0FBTSxFQUFFLElBVGE7QUFVckIvRCxhQUFLLEVBQUU7QUFWYyxPQUFmLEVBV1BvQixPQVhPLENBQVY7QUFhQSxVQUFJRixJQUFKO0FBQ0EsVUFBSThDLE9BQU8sR0FBRzVDLE9BQU8sQ0FBQ3FDLElBQVIsR0FBZSxjQUFjckMsT0FBTyxDQUFDcUMsSUFBckMsR0FBNEMsRUFBMUQ7QUFDQSxVQUFJRSxLQUFLLEdBQUd2QyxPQUFPLENBQUN1QyxLQUFSLEdBQWdCLGNBQWN2QyxPQUFPLENBQUN1QyxLQUF0QyxHQUE4QyxFQUExRDtBQUNBLFVBQUlELElBQUksR0FBR3RDLE9BQU8sQ0FBQ3NDLElBQVIsR0FBZSxjQUFjdEMsT0FBTyxDQUFDc0MsSUFBckMsR0FBNEMsRUFBdkQ7QUFDQSxVQUFJTyxPQUFPLEdBQUcseUJBQXlCRCxPQUF6QixHQUFtQyxHQUFuQyxHQUF5Q0wsS0FBekMsR0FBaUQsR0FBakQsR0FBdURELElBQXZELEdBQThELFNBQTVFOztBQUVBLFVBQUl0QyxPQUFPLENBQUMwQyxPQUFSLElBQW1CMUMsT0FBTyxDQUFDMEMsT0FBUixDQUFnQlosTUFBaEIsR0FBeUIsQ0FBaEQsRUFBbUQ7QUFDL0MsWUFBSWdCLE9BQU8sR0FBRyxjQUFjOUMsT0FBTyxDQUFDMkMsTUFBUixLQUFtQixLQUFuQixHQUEyQixTQUEzQixHQUF1QyxFQUFyRCxDQUFkO0FBRUE3QyxZQUFJLEdBQUcsaUJBQWlCZ0QsT0FBakIsR0FBMkIsVUFBM0IsR0FBd0M5QyxPQUFPLENBQUMwQyxPQUFoRCxHQUEwRCxlQUExRCxHQUE0RUcsT0FBNUUsR0FBc0YsZUFBN0Y7QUFFQSxZQUFJcEUsRUFBRSxHQUFHc0UsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVQ7QUFDQTNDLGNBQU0sQ0FBQzRDLEdBQVAsQ0FBVyxNQUFYLEVBQW1CQyxPQUFuQixDQUEyQnpFLEVBQTNCO0FBQ0E0QixjQUFNLENBQUNSLFFBQVAsQ0FBZ0JwQixFQUFoQixFQUFvQnFFLE9BQXBCO0FBQ0FyRSxVQUFFLENBQUMwRSxTQUFILEdBQWUsV0FBV25ELE9BQU8sQ0FBQzBDLE9BQW5CLEdBQTZCLGVBQTdCLEdBQStDRyxPQUEvQyxHQUF5RCxTQUF4RTtBQUNBN0MsZUFBTyxDQUFDcEIsS0FBUixHQUFnQnlCLE1BQU0sQ0FBQytDLFdBQVAsQ0FBbUIzRSxFQUFuQixJQUF5QixFQUF6QztBQUNBNEIsY0FBTSxDQUFDZ0QsTUFBUCxDQUFjNUUsRUFBZDs7QUFFQSxZQUFJNkMsTUFBTSxJQUFJLE1BQWQsRUFBc0I7QUFDbEJ4QixjQUFJLEdBQUcsaUJBQWlCZ0QsT0FBakIsR0FBMkIsd0JBQTNCLEdBQXVEOUMsT0FBTyxDQUFDcEIsS0FBUixHQUFnQixDQUF2RSxHQUE0RSxhQUE1RSxHQUE0Rm9CLE9BQU8sQ0FBQzBDLE9BQXBHLEdBQThHLGVBQTlHLEdBQWdJRyxPQUFoSSxHQUEwSSxlQUFqSjtBQUNIO0FBQ0osT0FmRCxNQWVPO0FBQ0gvQyxZQUFJLEdBQUcrQyxPQUFQO0FBQ0g7O0FBRUQsVUFBSVMsTUFBTSxHQUFHO0FBQ1RaLGVBQU8sRUFBRTVDLElBREE7QUFFVDJDLGVBQU8sRUFBRXpDLE9BQU8sQ0FBQ3lDLE9BRlI7QUFHVEQsZUFBTyxFQUFFeEMsT0FBTyxDQUFDd0MsT0FIUjtBQUlUZCxXQUFHLEVBQUU7QUFDRDZCLGFBQUcsRUFBRSxLQURKO0FBRURDLGNBQUksRUFBRSxLQUZMO0FBR0RDLGdCQUFNLEVBQUUsR0FIUDtBQUlEQyxpQkFBTyxFQUFFLEdBSlI7QUFLREMseUJBQWUsRUFBRSxNQUxoQjtBQU1EL0UsZUFBSyxFQUFFb0IsT0FBTyxDQUFDcEI7QUFOZCxTQUpJO0FBWVRnRixrQkFBVSxFQUFFO0FBQ1JELHlCQUFlLEVBQUUzRCxPQUFPLENBQUNvQyxZQURqQjtBQUVSRCxpQkFBTyxFQUFFbkMsT0FBTyxDQUFDbUMsT0FGVDtBQUdSMEIsZ0JBQU0sRUFBRSxNQUhBO0FBSVJDLGdCQUFNLEVBQUU7QUFKQSxTQVpIO0FBa0JUQyxpQkFBUyxFQUFFLHFCQUFXO0FBQ2xCLGNBQUl0RixFQUFFLElBQUlBLEVBQUUsQ0FBQyxDQUFELENBQVosRUFBaUI7QUFDYjRCLGtCQUFNLENBQUNxQixHQUFQLENBQVdqRCxFQUFFLENBQUMsQ0FBRCxDQUFiLEVBQWtCLFVBQWxCLEVBQThCLEVBQTlCO0FBQ0E0QixrQkFBTSxDQUFDcUIsR0FBUCxDQUFXakQsRUFBRSxDQUFDLENBQUQsQ0FBYixFQUFrQixNQUFsQixFQUEwQixFQUExQjtBQUNIO0FBQ0o7QUF2QlEsT0FBYjs7QUEwQkEsVUFBSTZDLE1BQU0sSUFBSSxNQUFkLEVBQXNCO0FBQ2xCZ0MsY0FBTSxDQUFDNUIsR0FBUCxDQUFXNkIsR0FBWCxHQUFpQixLQUFqQjtBQUNBcEUsU0FBQyxDQUFDNkUsT0FBRixDQUFVVixNQUFWO0FBQ0gsT0FIRCxNQUdPO0FBQ0gsWUFBSTdFLEVBQUUsR0FBR1UsQ0FBQyxDQUFDbUMsTUFBRCxDQUFWO0FBQ0E3QyxVQUFFLENBQUN3RCxLQUFILENBQVNxQixNQUFUO0FBQ0g7QUFDSixLQTlIRTtBQWdJSFcsV0FBTyxFQUFFLGlCQUFTM0MsTUFBVCxFQUFpQjtBQUN0QixVQUFJQSxNQUFNLElBQUlBLE1BQU0sSUFBSSxNQUF4QixFQUFnQztBQUM1Qm5DLFNBQUMsQ0FBQ21DLE1BQUQsQ0FBRCxDQUFVMkMsT0FBVjtBQUNILE9BRkQsTUFFTztBQUNIOUUsU0FBQyxDQUFDK0UsU0FBRjtBQUNIO0FBQ0osS0F0SUU7QUF3SUhDLGFBQVMsRUFBRSxtQkFBU25FLE9BQVQsRUFBa0I7QUFDekIsYUFBTzFCLEtBQUssQ0FBQzJELEtBQU4sQ0FBWSxNQUFaLEVBQW9CakMsT0FBcEIsQ0FBUDtBQUNILEtBMUlFO0FBNElIb0UsZUFBVyxFQUFFLHVCQUFXO0FBQ3BCLGFBQU85RixLQUFLLENBQUMyRixPQUFOLENBQWMsTUFBZCxDQUFQO0FBQ0gsS0E5SUU7QUFnSkhJLFlBQVEsRUFBRSxrQkFBUy9DLE1BQVQsRUFBaUJ0QixPQUFqQixFQUEwQjtBQUNoQyxVQUFJdEIsSUFBSSxHQUFJc0IsT0FBTyxJQUFJQSxPQUFPLENBQUN0QixJQUFwQixHQUE0QnNCLE9BQU8sQ0FBQ3RCLElBQXBDLEdBQTJDLE9BQXREO0FBQ0EsVUFBSTRGLFNBQVMsR0FBSXRFLE9BQU8sSUFBSUEsT0FBTyxDQUFDc0UsU0FBcEIsR0FBaUN0RSxPQUFPLENBQUNzRSxTQUF6QyxHQUFxRCxPQUFyRTtBQUNBLFVBQUloQyxJQUFJLEdBQUl0QyxPQUFPLElBQUlBLE9BQU8sQ0FBQ3NDLElBQXBCLEdBQTRCLGVBQWV0QyxPQUFPLENBQUNzQyxJQUFuRCxHQUEwRCxFQUFyRTtBQUNBLFVBQUlRLE9BQU8sR0FBRyxhQUFhLFdBQWIsR0FBMkJwRSxJQUEzQixHQUFrQyxZQUFsQyxHQUFpRDRGLFNBQWpELEdBQTZEaEMsSUFBM0U7QUFFQWhFLFdBQUssQ0FBQ2lHLFVBQU4sQ0FBaUJqRCxNQUFqQjtBQUNBakIsWUFBTSxDQUFDbUUsSUFBUCxDQUFZbEQsTUFBWixFQUFvQixVQUFwQixFQUFnQyxJQUFoQztBQUVBbkMsT0FBQyxDQUFDbUMsTUFBRCxDQUFELENBQVV6QixRQUFWLENBQW1CaUQsT0FBbkI7QUFDQTNELE9BQUMsQ0FBQ21DLE1BQUQsQ0FBRCxDQUFVM0MsSUFBVixDQUFlLGtCQUFmLEVBQW1DbUUsT0FBbkM7QUFDSCxLQTNKRTtBQTZKSHlCLGNBQVUsRUFBRSxvQkFBU2pELE1BQVQsRUFBaUI7QUFDekJuQyxPQUFDLENBQUNtQyxNQUFELENBQUQsQ0FBVW1ELFdBQVYsQ0FBc0J0RixDQUFDLENBQUNtQyxNQUFELENBQUQsQ0FBVTNDLElBQVYsQ0FBZSxrQkFBZixDQUF0QjtBQUNBMEIsWUFBTSxDQUFDcUUsVUFBUCxDQUFrQnBELE1BQWxCLEVBQTBCLFVBQTFCO0FBQ0gsS0FoS0U7QUFrS0hxRCxpQkFBYSxFQUFFLHVCQUFTQyxJQUFULEVBQWU7QUFDMUIsYUFBT3JHLE1BQU0sQ0FBQyxPQUFELENBQU4sQ0FBZ0JxRyxJQUFoQixDQUFQO0FBQ0gsS0FwS0U7QUFzS0hDLGdCQUFZLEVBQUUsc0JBQVN4QyxJQUFULEVBQWV5QyxLQUFmLEVBQXNCO0FBQ2hDLGFBQU92RyxNQUFNLENBQUMsTUFBRCxDQUFOLENBQWU4RCxJQUFmLEVBQXFCeUMsS0FBSyxHQUFHLENBQTdCLENBQVA7QUFDSDtBQXhLRSxHQUFQO0FBMEtILENBcFVXLEVBQVosQyxDQXNVQTs7O0FBQ0EsSUFBSSxTQUFpQyxPQUFPQyxNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQjFHLEtBQWpCO0FBQ0g7O0FBRUQsSUFBTTJHLFlBQVksR0FBRztBQUNuQixZQUFVO0FBQ1IsYUFBUztBQUNQLGVBQVMsU0FERjtBQUVQLGVBQVMsU0FGRjtBQUdQLGVBQVMsU0FIRjtBQUlQLGdCQUFVLFNBSkg7QUFLUCxpQkFBVyxTQUxKO0FBTVAsaUJBQVcsU0FOSjtBQU9QLGNBQVEsU0FQRDtBQVFQLGlCQUFXLFNBUko7QUFTUCxnQkFBVSxTQVRIO0FBVVAsZUFBUztBQVZGLEtBREQ7QUFhUixZQUFRO0FBQ04sZUFBUyxDQUNQLFNBRE8sRUFFUCxTQUZPLEVBR1AsU0FITyxFQUlQLFNBSk8sQ0FESDtBQU9OLGVBQVMsQ0FDUCxTQURPLEVBRVAsU0FGTyxFQUdQLFNBSE8sRUFJUCxTQUpPO0FBUEg7QUFiQTtBQURTLENBQXJCLEMsQ0ErQkE7O0FBQ0E5RixDQUFDLENBQUM0RCxRQUFELENBQUQsQ0FBWW1DLEtBQVosQ0FBa0IsWUFBVztBQUN6QjVHLE9BQUssQ0FBQ3lELElBQU4sQ0FBV2tELFlBQVg7QUFDSCxDQUZELEU7Ozs7Ozs7Ozs7O0FDalhBO0FBQ0EsSUFBSUUsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBU0MsU0FBVCxFQUFvQnBGLE9BQXBCLEVBQTZCO0FBQ3hDO0FBQ0EsTUFBSXFGLEdBQUcsR0FBRyxJQUFWO0FBQ0EsTUFBSXRELElBQUksR0FBRyxLQUFYLENBSHdDLENBS3hDOztBQUNBLE1BQUl1RCxPQUFPLEdBQUdqRixNQUFNLENBQUM0QyxHQUFQLENBQVdtQyxTQUFYLENBQWQ7QUFDQSxNQUFJRyxJQUFJLEdBQUdsRixNQUFNLENBQUM0QyxHQUFQLENBQVcsTUFBWCxDQUFYOztBQUVBLE1BQUksQ0FBQ3FDLE9BQUwsRUFBYztBQUNWO0FBQ0gsR0FYdUMsQ0FheEM7OztBQUNBLE1BQUlFLGNBQWMsR0FBRyxFQUFyQixDQWR3QyxDQWlCeEM7QUFDQTtBQUNBOztBQUVBLE1BQUlDLE1BQU0sR0FBRztBQUNUOzs7QUFJQUMsYUFBUyxFQUFFLG1CQUFTMUYsT0FBVCxFQUFrQjtBQUN6QixVQUFJSyxNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCSyxHQUFyQixDQUF5QixRQUF6QixDQUFKLEVBQXdDO0FBQ3BDTixXQUFHLEdBQUdoRixNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCckMsR0FBckIsQ0FBeUIsUUFBekIsQ0FBTjtBQUNILE9BRkQsTUFFTztBQUNIO0FBQ0F3QyxjQUFNLENBQUMxRCxJQUFQLENBQVkvQixPQUFaLEVBRkcsQ0FJSDs7QUFDQXlGLGNBQU0sQ0FBQ0csS0FBUDtBQUVBdkYsY0FBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQk8sR0FBckIsQ0FBeUIsUUFBekIsRUFBbUNSLEdBQW5DO0FBQ0g7O0FBRUQsYUFBT0EsR0FBUDtBQUNILEtBbkJROztBQXFCVDs7O0FBR0F0RCxRQUFJLEVBQUUsY0FBUy9CLE9BQVQsRUFBa0I7QUFDcEJxRixTQUFHLENBQUNDLE9BQUosR0FBY0EsT0FBZDtBQUNBRCxTQUFHLENBQUNTLE1BQUosR0FBYSxFQUFiO0FBRUFULFNBQUcsQ0FBQ1UsS0FBSixHQUFZMUYsTUFBTSxDQUFDa0IsSUFBUCxDQUFZK0QsT0FBWixFQUFxQixvQkFBckIsQ0FBWjtBQUNBRCxTQUFHLENBQUNXLE1BQUosR0FBYTNGLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWStELE9BQVosRUFBcUIsaUJBQXJCLENBQWI7QUFDQUQsU0FBRyxDQUFDWSxNQUFKLEdBQWE1RixNQUFNLENBQUNrQixJQUFQLENBQVkrRCxPQUFaLEVBQXFCLGlCQUFyQixDQUFiO0FBQ0FELFNBQUcsQ0FBQ2EsR0FBSixHQUFVN0YsTUFBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDVyxNQUFmLEVBQXVCLGlCQUF2QixDQUFWLENBUG9CLENBU3BCOztBQUNBWCxTQUFHLENBQUNyRixPQUFKLEdBQWNLLE1BQU0sQ0FBQzhGLFVBQVAsQ0FBa0IsRUFBbEIsRUFBc0JYLGNBQXRCLEVBQXNDeEYsT0FBdEMsQ0FBZDtBQUNILEtBbkNROztBQXFDVDs7O0FBR0E0RixTQUFLLEVBQUUsaUJBQVc7QUFDZDtBQUNBdkYsWUFBTSxDQUFDK0YsUUFBUCxDQUFnQmYsR0FBRyxDQUFDVSxLQUFwQixFQUEyQixRQUEzQixFQUFxQyxVQUFTMUUsQ0FBVCxFQUFZO0FBQzdDQSxTQUFDLENBQUNnRixjQUFGOztBQUVILFlBQUloQixHQUFHLENBQUNVLEtBQUosSUFBYVYsR0FBRyxDQUFDVSxLQUFKLENBQVVPLEtBQXZCLElBQWdDakIsR0FBRyxDQUFDVSxLQUFKLENBQVVPLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBcEMsRUFBd0Q7QUFDcEQsY0FBSUMsTUFBTSxHQUFHLElBQUlDLFVBQUosRUFBYjs7QUFDQUQsZ0JBQU0sQ0FBQ0UsTUFBUCxHQUFnQixVQUFTcEYsQ0FBVCxFQUFZO0FBQ3hCaEIsa0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ1csTUFBZixFQUF1QixrQkFBdkIsRUFBMkMsU0FBTzNFLENBQUMsQ0FBQ0MsTUFBRixDQUFTb0YsTUFBaEIsR0FBd0IsR0FBbkU7QUFDSCxXQUZEOztBQUdBSCxnQkFBTSxDQUFDSSxhQUFQLENBQXFCdEIsR0FBRyxDQUFDVSxLQUFKLENBQVVPLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBckI7QUFFQWpHLGdCQUFNLENBQUNSLFFBQVAsQ0FBZ0J3RixHQUFHLENBQUNDLE9BQXBCLEVBQTZCLGlCQUE3QjtBQUNIO0FBQ0QsT0FaRCxFQUZjLENBZ0JkOztBQUNBakYsWUFBTSxDQUFDK0YsUUFBUCxDQUFnQmYsR0FBRyxDQUFDWSxNQUFwQixFQUE0QixPQUE1QixFQUFxQyxVQUFTNUUsQ0FBVCxFQUFZO0FBQzdDQSxTQUFDLENBQUNnRixjQUFGO0FBRUhoRyxjQUFNLENBQUNvRSxXQUFQLENBQW1CWSxHQUFHLENBQUNDLE9BQXZCLEVBQWdDLGlCQUFoQztBQUNBakYsY0FBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDVyxNQUFmLEVBQXVCLGtCQUF2QixFQUEyQ1gsR0FBRyxDQUFDYSxHQUEvQztBQUNBYixXQUFHLENBQUNVLEtBQUosQ0FBVWEsS0FBVixHQUFrQixFQUFsQjtBQUNBLE9BTkQ7QUFPSCxLQWhFUTs7QUFrRVQ7OztBQUdBQyxnQkFBWSxFQUFFLHNCQUFTakMsSUFBVCxFQUFlO0FBQ3pCO0FBQ0EsV0FBSyxJQUFJa0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXaEUsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLFlBQUlDLEtBQUssR0FBRzFCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxDQUFaOztBQUNBLFlBQUlDLEtBQUssQ0FBQ25DLElBQU4sSUFBY0EsSUFBbEIsRUFBd0I7QUFDcEIsY0FBSW1DLEtBQUssQ0FBQ0MsR0FBTixJQUFhLElBQWpCLEVBQXVCO0FBQ25CLGdCQUFJRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxLQUFuQixFQUEwQjtBQUN0QjVCLGlCQUFHLENBQUNTLE1BQUosQ0FBV2dCLENBQVgsRUFBY0csS0FBZCxHQUFzQixJQUF0QjtBQUNBLHFCQUFPRixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLENBQVA7QUFDSDtBQUNKLFdBTEQsTUFLTztBQUNILG1CQUFPMEIsS0FBSyxDQUFDRyxPQUFOLENBQWNDLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUI5QixHQUF6QixDQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0FwRlE7QUFzRlRlLFlBQVEsRUFBRSxrQkFBU3hCLElBQVQsRUFBZXNDLE9BQWYsRUFBd0JGLEdBQXhCLEVBQTZCO0FBQ25DM0IsU0FBRyxDQUFDUyxNQUFKLENBQVdzQixJQUFYLENBQWdCO0FBQ1p4QyxZQUFJLEVBQUVBLElBRE07QUFFWnNDLGVBQU8sRUFBRUEsT0FGRztBQUdaRixXQUFHLEVBQUVBLEdBSE87QUFJWkMsYUFBSyxFQUFFO0FBSkssT0FBaEI7QUFPQSxhQUFPNUIsR0FBUDtBQUNIO0FBL0ZRLEdBQWIsQ0FyQndDLENBdUh4QztBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQUEsS0FBRyxDQUFDZ0MsV0FBSixHQUFrQixVQUFTckgsT0FBVCxFQUFrQjtBQUNoQ3dGLGtCQUFjLEdBQUd4RixPQUFqQjtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQXFGLEtBQUcsQ0FBQzVGLEVBQUosR0FBUyxVQUFTbUYsSUFBVCxFQUFlc0MsT0FBZixFQUF3QjtBQUM3QixXQUFPekIsTUFBTSxDQUFDVyxRQUFQLENBQWdCeEIsSUFBaEIsRUFBc0JzQyxPQUF0QixDQUFQO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBN0IsS0FBRyxDQUFDMkIsR0FBSixHQUFVLFVBQVNwQyxJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzlCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLEVBQStCLElBQS9CLENBQVA7QUFDSCxHQUZELENBN0l3QyxDQWlKeEM7OztBQUNBekIsUUFBTSxDQUFDQyxTQUFQLENBQWlCNEIsS0FBakIsQ0FBdUJqQyxHQUF2QixFQUE0QixDQUFDckYsT0FBRCxDQUE1QjtBQUVBLFNBQU9xRixHQUFQO0FBQ0gsQ0FySkQsQyxDQXVKQTs7O0FBQ0EsSUFBSSxTQUFpQyxPQUFPTixNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQkcsUUFBakI7QUFDSCxDOzs7Ozs7Ozs7Ozs7Q0N6SkQ7O0FBQ0EsSUFBSW9DLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVN2SCxPQUFULEVBQWtCO0FBQzdCO0FBQ0EsTUFBSXFGLEdBQUcsR0FBRyxJQUFWLENBRjZCLENBSTdCOztBQUNBLE1BQUlDLE9BQUo7QUFDQSxNQUFJQyxJQUFJLEdBQUdsRixNQUFNLENBQUM0QyxHQUFQLENBQVcsTUFBWCxDQUFYLENBTjZCLENBUTdCOztBQUNBLE1BQUl1QyxjQUFjLEdBQUc7QUFDakIsaUJBQWMsWUFERztBQUVqQixZQUFVLFFBRk87QUFHakIsYUFBVSxHQUhPO0FBSWpCLGFBQVUsU0FKTztBQUtqQixlQUFZO0FBTEssR0FBckIsQ0FUNkIsQ0FpQjdCO0FBQ0E7QUFDQTs7QUFFQSxNQUFJQyxNQUFNLEdBQUc7QUFDVDs7O0FBSUFDLGFBQVMsRUFBRSxtQkFBUzFGLE9BQVQsRUFBa0I7QUFDekJ5RixZQUFNLENBQUMxRCxJQUFQLENBQVkvQixPQUFaO0FBRUEsYUFBT3FGLEdBQVA7QUFDSCxLQVRROztBQVdUOzs7QUFHQXRELFFBQUksRUFBRSxjQUFTL0IsT0FBVCxFQUFrQjtBQUNwQnFGLFNBQUcsQ0FBQ1MsTUFBSixHQUFhLEVBQWIsQ0FEb0IsQ0FHcEI7O0FBQ0FULFNBQUcsQ0FBQ3JGLE9BQUosR0FBY0ssTUFBTSxDQUFDOEYsVUFBUCxDQUFrQixFQUFsQixFQUFzQlgsY0FBdEIsRUFBc0N4RixPQUF0QyxDQUFkO0FBRUFxRixTQUFHLENBQUM5QyxLQUFKLEdBQVksS0FBWjtBQUNILEtBckJROztBQXVCVDs7O0FBR0FpRixRQUFJLEVBQUUsZ0JBQVc7QUFDYi9CLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsTUFBcEI7QUFFQXZCLGFBQU8sR0FBR3ZDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFWO0FBQ0EzQyxZQUFNLENBQUNvSCxPQUFQLENBQWVuQyxPQUFmLEVBQXdCRCxHQUFHLENBQUNyRixPQUFKLENBQVkwQyxPQUFwQztBQUVBckMsWUFBTSxDQUFDUixRQUFQLENBQWdCeUYsT0FBaEIsRUFBeUIsc0JBQXpCO0FBQ0FqRixZQUFNLENBQUNSLFFBQVAsQ0FBZ0J5RixPQUFoQixFQUF5QixhQUFhRCxHQUFHLENBQUNyRixPQUFKLENBQVl1QyxLQUFsRDtBQUNBbEMsWUFBTSxDQUFDUixRQUFQLENBQWdCeUYsT0FBaEIsRUFBeUIsYUFBYUQsR0FBRyxDQUFDckYsT0FBSixDQUFZcUMsSUFBbEQ7O0FBRUEsVUFBSWdELEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWxCLFNBQVosS0FBMEIsWUFBOUIsRUFBNEM7QUFDeEN1QixjQUFNLENBQUNSLFFBQVAsQ0FBZ0J5RixPQUFoQixFQUF5QixvQkFBekI7QUFDSDs7QUFFREMsVUFBSSxDQUFDbUMsV0FBTCxDQUFpQnBDLE9BQWpCO0FBRUFELFNBQUcsQ0FBQzlDLEtBQUosR0FBWSxPQUFaO0FBRUFrRCxZQUFNLENBQUNvQixZQUFQLENBQW9CLE9BQXBCO0FBRUEsYUFBT3hCLEdBQVA7QUFDSCxLQS9DUTs7QUFpRFQ7OztBQUdBdkUsUUFBSSxFQUFFLGdCQUFXO0FBQ2IsVUFBSXdFLE9BQUosRUFBYTtBQUNURyxjQUFNLENBQUNvQixZQUFQLENBQW9CLE1BQXBCO0FBRUF2QixlQUFPLENBQUNqQyxNQUFSO0FBQ0FnQyxXQUFHLENBQUM5QyxLQUFKLEdBQVksUUFBWjtBQUVBa0QsY0FBTSxDQUFDb0IsWUFBUCxDQUFvQixRQUFwQjtBQUNIOztBQUVELGFBQU94QixHQUFQO0FBQ0gsS0EvRFE7O0FBaUVUOzs7QUFHQXdCLGdCQUFZLEVBQUUsc0JBQVNqQyxJQUFULEVBQWU7QUFDekIsV0FBSyxJQUFJa0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXaEUsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLFlBQUlDLEtBQUssR0FBRzFCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxDQUFaOztBQUVBLFlBQUlDLEtBQUssQ0FBQ25DLElBQU4sSUFBY0EsSUFBbEIsRUFBd0I7QUFDcEIsY0FBSW1DLEtBQUssQ0FBQ0MsR0FBTixJQUFhLElBQWpCLEVBQXVCO0FBQ25CLGdCQUFJRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxLQUFuQixFQUEwQjtBQUN0QjVCLGlCQUFHLENBQUNTLE1BQUosQ0FBV2dCLENBQVgsRUFBY0csS0FBZCxHQUFzQixJQUF0QjtBQUNBLHFCQUFPRixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLENBQVA7QUFDSDtBQUNKLFdBTEQsTUFLTztBQUNILG1CQUFPMEIsS0FBSyxDQUFDRyxPQUFOLENBQWNDLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUI5QixHQUF6QixDQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0FuRlE7QUFxRlRlLFlBQVEsRUFBRSxrQkFBU3hCLElBQVQsRUFBZXNDLE9BQWYsRUFBd0JGLEdBQXhCLEVBQTZCO0FBQ25DM0IsU0FBRyxDQUFDUyxNQUFKLENBQVdzQixJQUFYLENBQWdCO0FBQ1p4QyxZQUFJLEVBQUVBLElBRE07QUFFWnNDLGVBQU8sRUFBRUEsT0FGRztBQUdaRixXQUFHLEVBQUVBLEdBSE87QUFJWkMsYUFBSyxFQUFFO0FBSkssT0FBaEI7QUFPQSxhQUFPNUIsR0FBUDtBQUNIO0FBOUZRLEdBQWIsQ0FyQjZCLENBc0g3QjtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQUEsS0FBRyxDQUFDZ0MsV0FBSixHQUFrQixVQUFTckgsT0FBVCxFQUFrQjtBQUNoQ3dGLGtCQUFjLEdBQUd4RixPQUFqQjtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQXFGLEtBQUcsQ0FBQ3NDLEtBQUosR0FBWSxZQUFXO0FBQ25CLFdBQU90QyxHQUFHLENBQUM5QyxLQUFKLElBQWEsT0FBcEI7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0E4QyxLQUFHLENBQUN1QyxNQUFKLEdBQWEsWUFBVztBQUNwQixXQUFPdkMsR0FBRyxDQUFDOUMsS0FBSixJQUFhLFFBQXBCO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBOEMsS0FBRyxDQUFDbUMsSUFBSixHQUFXLFlBQVc7QUFDbEIsV0FBTy9CLE1BQU0sQ0FBQytCLElBQVAsRUFBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQW5DLEtBQUcsQ0FBQ3ZFLElBQUosR0FBVyxZQUFXO0FBQ2xCLFdBQU8yRSxNQUFNLENBQUMzRSxJQUFQLEVBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7OztBQUlBdUUsS0FBRyxDQUFDNUYsRUFBSixHQUFTLFVBQVNtRixJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzdCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLENBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7OztBQUlBN0IsS0FBRyxDQUFDMkIsR0FBSixHQUFVLFVBQVNwQyxJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzlCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLEVBQStCLElBQS9CLENBQVA7QUFDSCxHQUZELENBMUs2QixDQThLN0I7OztBQUNBekIsUUFBTSxDQUFDQyxTQUFQLENBQWlCNEIsS0FBakIsQ0FBdUJqQyxHQUF2QixFQUE0QixDQUFDckYsT0FBRCxDQUE1QjtBQUVBLFNBQU9xRixHQUFQO0FBQ0gsQ0FsTEQsQyxDQW9MQTs7O0FBQ0EsSUFBSSxTQUFpQyxPQUFPTixNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQnVDLFFBQWpCO0FBQ0gsQzs7Ozs7Ozs7Ozs7O0FDMUxZOztBQUNiLElBQUlNLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVN6QyxTQUFULEVBQW9CcEYsT0FBcEIsRUFBNkI7QUFDeEM7QUFDQSxNQUFJcUYsR0FBRyxHQUFHLElBQVY7QUFDQSxNQUFJdEQsSUFBSSxHQUFHLEtBQVgsQ0FId0MsQ0FLeEM7O0FBQ0EsTUFBSXVELE9BQU8sR0FBR2pGLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV21DLFNBQVgsQ0FBZDtBQUNBLE1BQUlHLElBQUksR0FBR2xGLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxNQUFYLENBQVg7O0FBRUEsTUFBSXFDLE9BQU8sS0FBS3dDLFNBQWhCLEVBQTJCO0FBQ3ZCO0FBQ0gsR0FYdUMsQ0FheEM7OztBQUNBLE1BQUl0QyxjQUFjLEdBQUc7QUFDakJ1QyxXQUFPLEVBQUUsS0FEUTtBQUVqQkMsVUFBTSxFQUFFO0FBQ0pDLFlBQU0sRUFBRSxHQURKO0FBRUpDLGFBQU8sRUFBRTtBQUZMLEtBRlM7QUFNakJDLFlBQVEsRUFBRTtBQUNORixZQUFNLEVBQUUsS0FERjtBQUVOQyxhQUFPLEVBQUU7QUFGSDtBQU5PLEdBQXJCLENBZHdDLENBMEJ4QztBQUNBO0FBQ0E7O0FBRUEsTUFBSXpDLE1BQU0sR0FBRztBQUNUOzs7O0FBSUFDLGFBQVMsRUFBRSxtQkFBUzFGLE9BQVQsRUFBa0I7QUFDekIsVUFBSUssTUFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQkssR0FBckIsQ0FBeUIsUUFBekIsQ0FBSixFQUF3QztBQUNwQ04sV0FBRyxHQUFHaEYsTUFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQnJDLEdBQXJCLENBQXlCLFFBQXpCLENBQU47QUFDSCxPQUZELE1BRU87QUFDSDtBQUNBd0MsY0FBTSxDQUFDMUQsSUFBUCxDQUFZL0IsT0FBWixFQUZHLENBSUg7O0FBQ0F5RixjQUFNLENBQUNHLEtBQVA7QUFFQXZGLGNBQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJPLEdBQXJCLENBQXlCLFFBQXpCLEVBQW1DUixHQUFuQztBQUNIOztBQUVELGFBQU9BLEdBQVA7QUFDSCxLQW5CUTs7QUFxQlQ7Ozs7QUFJQXRELFFBQUksRUFBRSxjQUFTL0IsT0FBVCxFQUFrQjtBQUNwQnFGLFNBQUcsQ0FBQ1MsTUFBSixHQUFhLEVBQWIsQ0FEb0IsQ0FHcEI7O0FBQ0FULFNBQUcsQ0FBQ3JGLE9BQUosR0FBY0ssTUFBTSxDQUFDOEYsVUFBUCxDQUFrQixFQUFsQixFQUFzQlgsY0FBdEIsRUFBc0N4RixPQUF0QyxDQUFkO0FBQ0gsS0E5QlE7O0FBZ0NUOzs7O0FBSUE0RixTQUFLLEVBQUUsaUJBQVc7QUFDZCxVQUFJd0MsYUFBYSxHQUFHLENBQXBCO0FBQ0EsVUFBSUMsaUJBQWlCLEdBQUcsSUFBeEI7QUFDQSxVQUFJQyxjQUFjLEdBQUdqSSxNQUFNLENBQUNrSSxXQUFQLEdBQXFCN0gsTUFBMUM7QUFDQSxVQUFJOEgsY0FBYyxHQUFHbkksTUFBTSxDQUFDb0ksaUJBQVAsRUFBckI7O0FBRUEsVUFBSXBELEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWW1JLFFBQVosQ0FBcUJGLE1BQXJCLEtBQWdDLEtBQWhDLElBQXlDNUMsR0FBRyxDQUFDckYsT0FBSixDQUFZbUksUUFBWixDQUFxQkQsT0FBckIsS0FBaUMsS0FBOUUsRUFBcUY7QUFDakY7QUFDSDs7QUFFRFEsWUFBTSxDQUFDQyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxZQUFXO0FBQ3pDLFlBQUlYLE1BQU0sR0FBRyxDQUFiO0FBQUEsWUFBZ0J2SSxFQUFoQjtBQUFBLFlBQW9CbUosR0FBcEI7QUFBQSxZQUF5QkMsRUFBekI7O0FBRUEsWUFBSXhJLE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsU0FBM0IsQ0FBSixFQUEyQztBQUN2Q3FILGdCQUFNLEdBQUczQyxHQUFHLENBQUNyRixPQUFKLENBQVlnSSxNQUFaLENBQW1CRSxPQUE1QjtBQUNBekksWUFBRSxHQUFHNEYsR0FBRyxDQUFDckYsT0FBSixDQUFZbUksUUFBWixDQUFxQkQsT0FBckIsQ0FBNkJ6SSxFQUFsQztBQUNBbUosYUFBRyxHQUFHdkQsR0FBRyxDQUFDckYsT0FBSixDQUFZbUksUUFBWixDQUFxQkQsT0FBckIsQ0FBNkJVLEdBQW5DO0FBQ0gsU0FKRCxNQUlPLElBQUl2SSxNQUFNLENBQUNNLG1CQUFQLENBQTJCLG1CQUEzQixDQUFKLEVBQXFEO0FBQ3hEcUgsZ0JBQU0sR0FBRzNDLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdJLE1BQVosQ0FBbUJDLE1BQTVCO0FBQ0F4SSxZQUFFLEdBQUc0RixHQUFHLENBQUNyRixPQUFKLENBQVltSSxRQUFaLENBQXFCRixNQUFyQixDQUE0QnhJLEVBQWpDO0FBQ0FtSixhQUFHLEdBQUd2RCxHQUFHLENBQUNyRixPQUFKLENBQVltSSxRQUFaLENBQXFCRixNQUFyQixDQUE0QlcsR0FBbEM7QUFDSDs7QUFFREMsVUFBRSxHQUFHeEksTUFBTSxDQUFDeUksWUFBUCxFQUFMOztBQUVBLFlBQ0t6SSxNQUFNLENBQUNNLG1CQUFQLENBQTJCLG1CQUEzQixLQUFtRDBFLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWStILE9BQS9ELElBQTBFMUMsR0FBRyxDQUFDckYsT0FBSixDQUFZK0gsT0FBWixDQUFvQkUsTUFBL0YsSUFDQzVILE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsU0FBM0IsS0FBeUMwRSxHQUFHLENBQUNyRixPQUFKLENBQVkrSCxPQUFyRCxJQUFnRTFDLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWStILE9BQVosQ0FBb0JHLE9BRnpGLEVBR0U7QUFDRSxjQUFJVyxFQUFFLEdBQUdiLE1BQVQsRUFBaUI7QUFBRTtBQUNmM0gsa0JBQU0sQ0FBQ1IsUUFBUCxDQUFnQjBGLElBQWhCLEVBQXNCOUYsRUFBdEI7QUFDQVksa0JBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJjLElBQW5CLEVBQXlCcUQsR0FBekI7O0FBRUEsZ0JBQUlQLGlCQUFKLEVBQXVCO0FBQ25CNUMsb0JBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsWUFBcEIsRUFBa0N4QixHQUFsQztBQUNBZ0QsK0JBQWlCLEdBQUcsS0FBcEI7QUFDSDtBQUNKLFdBUkQsTUFRTztBQUFFO0FBQ0xoSSxrQkFBTSxDQUFDUixRQUFQLENBQWdCMEYsSUFBaEIsRUFBc0JxRCxHQUF0QjtBQUNBdkksa0JBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJjLElBQW5CLEVBQXlCOUYsRUFBekI7O0FBRUEsZ0JBQUk0SSxpQkFBaUIsSUFBSSxLQUF6QixFQUFnQztBQUM1QjVDLG9CQUFNLENBQUNvQixZQUFQLENBQW9CLGFBQXBCLEVBQW1DeEIsR0FBbkM7QUFDQWdELCtCQUFpQixHQUFHLElBQXBCO0FBQ0g7QUFDSjtBQUNKLFNBckJELE1BcUJPO0FBQ0gsY0FBSVEsRUFBRSxHQUFHYixNQUFMLElBQWVJLGFBQWEsR0FBR1MsRUFBbkMsRUFBdUM7QUFBRTtBQUNyQ3hJLGtCQUFNLENBQUNSLFFBQVAsQ0FBZ0IwRixJQUFoQixFQUFzQjlGLEVBQXRCO0FBQ0FZLGtCQUFNLENBQUNvRSxXQUFQLENBQW1CYyxJQUFuQixFQUF5QnFELEdBQXpCOztBQUVBLGdCQUFJUCxpQkFBSixFQUF1QjtBQUNuQjVDLG9CQUFNLENBQUNvQixZQUFQLENBQW9CLFlBQXBCLEVBQWtDeEIsR0FBbEM7QUFDQWdELCtCQUFpQixHQUFHLEtBQXBCO0FBQ0g7QUFDSixXQVJELE1BUU87QUFBRTtBQUNMaEksa0JBQU0sQ0FBQ1IsUUFBUCxDQUFnQjBGLElBQWhCLEVBQXNCcUQsR0FBdEI7QUFDQXZJLGtCQUFNLENBQUNvRSxXQUFQLENBQW1CYyxJQUFuQixFQUF5QjlGLEVBQXpCOztBQUVBLGdCQUFJNEksaUJBQWlCLElBQUksS0FBekIsRUFBZ0M7QUFDNUI1QyxvQkFBTSxDQUFDb0IsWUFBUCxDQUFvQixhQUFwQixFQUFtQ3hCLEdBQW5DO0FBQ0FnRCwrQkFBaUIsR0FBRyxJQUFwQjtBQUNIO0FBQ0o7O0FBRURELHVCQUFhLEdBQUdTLEVBQWhCO0FBQ0g7QUFDSixPQXpERDtBQTBESCxLQXhHUTs7QUEwR1Q7OztBQUdBaEMsZ0JBQVksRUFBRSxzQkFBU2pDLElBQVQsRUFBZW1FLElBQWYsRUFBcUI7QUFDL0IsV0FBSyxJQUFJakMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXaEUsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLFlBQUlDLEtBQUssR0FBRzFCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxDQUFaOztBQUNBLFlBQUlDLEtBQUssQ0FBQ25DLElBQU4sSUFBY0EsSUFBbEIsRUFBd0I7QUFDcEIsY0FBSW1DLEtBQUssQ0FBQ0MsR0FBTixJQUFhLElBQWpCLEVBQXVCO0FBQ25CLGdCQUFJRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxLQUFuQixFQUEwQjtBQUN0QjVCLGlCQUFHLENBQUNTLE1BQUosQ0FBV2dCLENBQVgsRUFBY0csS0FBZCxHQUFzQixJQUF0QjtBQUNBLHFCQUFPRixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLEVBQThCMEQsSUFBOUIsQ0FBUDtBQUNIO0FBQ0osV0FMRCxNQUtPO0FBQ0gsbUJBQU9oQyxLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLEVBQThCMEQsSUFBOUIsQ0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNKLEtBM0hRO0FBNkhUM0MsWUFBUSxFQUFFLGtCQUFTeEIsSUFBVCxFQUFlc0MsT0FBZixFQUF3QkYsR0FBeEIsRUFBNkI7QUFDbkMzQixTQUFHLENBQUNTLE1BQUosQ0FBV3NCLElBQVgsQ0FBZ0I7QUFDWnhDLFlBQUksRUFBRUEsSUFETTtBQUVac0MsZUFBTyxFQUFFQSxPQUZHO0FBR1pGLFdBQUcsRUFBRUEsR0FITztBQUlaQyxhQUFLLEVBQUU7QUFKSyxPQUFoQjtBQU1IO0FBcElRLEdBQWIsQ0E5QndDLENBcUt4QztBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTVCLEtBQUcsQ0FBQ2dDLFdBQUosR0FBa0IsVUFBU3JILE9BQVQsRUFBa0I7QUFDaEN3RixrQkFBYyxHQUFHeEYsT0FBakI7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0FxRixLQUFHLENBQUM1RixFQUFKLEdBQVMsVUFBU21GLElBQVQsRUFBZXNDLE9BQWYsRUFBd0I7QUFDN0IsV0FBT3pCLE1BQU0sQ0FBQ1csUUFBUCxDQUFnQnhCLElBQWhCLEVBQXNCc0MsT0FBdEIsQ0FBUDtBQUNILEdBRkQsQ0FwTHdDLENBd0x4QztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0F6QixRQUFNLENBQUNDLFNBQVAsQ0FBaUI0QixLQUFqQixDQUF1QmpDLEdBQXZCLEVBQTRCLENBQUNyRixPQUFELENBQTVCLEVBN0x3QyxDQStMeEM7O0FBQ0ErQixNQUFJLEdBQUcsSUFBUCxDQWhNd0MsQ0FrTXhDOztBQUNBLFNBQU9zRCxHQUFQO0FBQ0gsQ0FwTUQsQyxDQXNNQTs7O0FBQ0EsSUFBSSxTQUFpQyxPQUFPTixNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQjZDLFFBQWpCO0FBQ0gsQzs7Ozs7Ozs7Ozs7O0FDMU1ZOztBQUNiLElBQUltQixNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFTNUQsU0FBVCxFQUFvQnBGLE9BQXBCLEVBQTZCO0FBQ3RDO0FBQ0EsTUFBSXFGLEdBQUcsR0FBRyxJQUFWO0FBQ0EsTUFBSXRELElBQUksR0FBRyxLQUFYLENBSHNDLENBS3RDOztBQUNBLE1BQUl1RCxPQUFPLEdBQUdqRixNQUFNLENBQUM0QyxHQUFQLENBQVdtQyxTQUFYLENBQWQ7QUFDQSxNQUFJRyxJQUFJLEdBQUdsRixNQUFNLENBQUM0QyxHQUFQLENBQVcsTUFBWCxDQUFYOztBQUVBLE1BQUksQ0FBQ3FDLE9BQUwsRUFBYztBQUNWO0FBQ0gsR0FYcUMsQ0FhdEM7OztBQUNBLE1BQUlFLGNBQWMsR0FBRztBQUNqQjtBQUNBeUQsVUFBTSxFQUFFO0FBQ0p4SSxzQkFBZ0IsRUFBRTtBQURkLEtBRlM7QUFNakI7QUFDQXlJLGFBQVMsRUFBRTtBQUNQQyxnQkFBVSxFQUFFLEdBREw7QUFDVTtBQUNqQkMsZ0JBQVUsRUFBRSxLQUZMO0FBRVk7QUFDbkJDLHFCQUFlLEVBQUUsSUFIVjtBQUlQQyxlQUFTLEVBQUUsSUFKSixDQUlTOztBQUpULEtBUE07QUFjakI7QUFDQUMsWUFBUSxFQUFFO0FBQ05DLGFBQU8sRUFBRSxHQURILENBQ087O0FBRFA7QUFmTyxHQUFyQixDQWRzQyxDQWtDdEM7QUFDQTtBQUNBOztBQUVBLE1BQUkvRCxNQUFNLEdBQUc7QUFDVDs7OztBQUlBQyxhQUFTLEVBQUUsbUJBQVMxRixPQUFULEVBQWtCO0FBQ3pCLFVBQUlLLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJLLEdBQXJCLENBQXlCLE1BQXpCLENBQUosRUFBc0M7QUFDbENOLFdBQUcsR0FBR2hGLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJyQyxHQUFyQixDQUF5QixNQUF6QixDQUFOO0FBQ0gsT0FGRCxNQUVPO0FBQ0g7QUFDQXdDLGNBQU0sQ0FBQzFELElBQVAsQ0FBWS9CLE9BQVosRUFGRyxDQUlIOztBQUNBeUYsY0FBTSxDQUFDZ0UsS0FBUCxHQUxHLENBT0g7O0FBQ0FoRSxjQUFNLENBQUNHLEtBQVA7QUFFQXZGLGNBQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJPLEdBQXJCLENBQXlCLE1BQXpCLEVBQWlDUixHQUFqQztBQUNIOztBQUVELGFBQU9BLEdBQVA7QUFDSCxLQXRCUTs7QUF3QlQ7Ozs7QUFJQXRELFFBQUksRUFBRSxjQUFTL0IsT0FBVCxFQUFrQjtBQUNwQnFGLFNBQUcsQ0FBQ1MsTUFBSixHQUFhLEVBQWI7QUFFQVQsU0FBRyxDQUFDcUUsYUFBSixHQUFvQixFQUFwQixDQUhvQixDQUtwQjs7QUFDQXJFLFNBQUcsQ0FBQ3JGLE9BQUosR0FBY0ssTUFBTSxDQUFDOEYsVUFBUCxDQUFrQixFQUFsQixFQUFzQlgsY0FBdEIsRUFBc0N4RixPQUF0QyxDQUFkLENBTm9CLENBUXBCOztBQUNBcUYsU0FBRyxDQUFDc0Usc0JBQUosR0FBNkIsQ0FBN0I7QUFFQXRFLFNBQUcsQ0FBQ3VFLEdBQUosR0FBVXZKLE1BQU0sQ0FBQ3dKLFdBQVAsRUFBVjtBQUNILEtBeENRO0FBMENUQyxVQUFNLEVBQUUsZ0JBQVM5SixPQUFULEVBQWtCO0FBQ3RCO0FBQ0FxRixTQUFHLENBQUNyRixPQUFKLEdBQWNLLE1BQU0sQ0FBQzhGLFVBQVAsQ0FBa0IsRUFBbEIsRUFBc0JYLGNBQXRCLEVBQXNDeEYsT0FBdEMsQ0FBZCxDQUZzQixDQUl0Qjs7QUFDQXFGLFNBQUcsQ0FBQ3NFLHNCQUFKLEdBQTZCLENBQTdCLENBTHNCLENBT3JCOztBQUNEbEUsWUFBTSxDQUFDZ0UsS0FBUDtBQUVBcEUsU0FBRyxDQUFDcUUsYUFBSixHQUFvQixFQUFwQixDQVZzQixDQVl0Qjs7QUFDQWpFLFlBQU0sQ0FBQ0csS0FBUDtBQUVBdkYsWUFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQk8sR0FBckIsQ0FBeUIsTUFBekIsRUFBaUNSLEdBQWpDO0FBQ0gsS0ExRFE7QUE0RFQwRSxVQUFNLEVBQUUsa0JBQVc7QUFDZDtBQUNEdEUsWUFBTSxDQUFDZ0UsS0FBUCxHQUZlLENBSWY7O0FBQ0FoRSxZQUFNLENBQUNHLEtBQVAsR0FMZSxDQU9mOztBQUNBSCxZQUFNLENBQUN1RSxpQkFBUDtBQUNILEtBckVROztBQXVFVDs7OztBQUlBcEUsU0FBSyxFQUFFLGlCQUFXO0FBQ2Q7QUFDQVAsU0FBRyxDQUFDcUUsYUFBSixDQUFrQixTQUFsQixJQUErQnJKLE1BQU0sQ0FBQ1osRUFBUCxDQUFXNkYsT0FBWCxFQUFvQixlQUFwQixFQUFxQyxPQUFyQyxFQUE4Q0csTUFBTSxDQUFDd0Usc0JBQXJELENBQS9CLENBRmMsQ0FJZDs7QUFDQSxVQUFJeEUsTUFBTSxDQUFDeUUsY0FBUCxPQUE0QixVQUE1QixJQUEwQ3pFLE1BQU0sQ0FBQzBFLDRCQUFQLEVBQTlDLEVBQXFGO0FBQ2pGO0FBQ0E5RSxXQUFHLENBQUNxRSxhQUFKLENBQWtCLFNBQWxCLElBQStCckosTUFBTSxDQUFDWixFQUFQLENBQVc2RixPQUFYLEVBQW9CLHNDQUFwQixFQUE0RCxXQUE1RCxFQUF5RUcsTUFBTSxDQUFDMkUsOEJBQWhGLENBQS9CO0FBQ0EvRSxXQUFHLENBQUNxRSxhQUFKLENBQWtCLFNBQWxCLElBQStCckosTUFBTSxDQUFDWixFQUFQLENBQVc2RixPQUFYLEVBQW9CLHNDQUFwQixFQUE0RCxVQUE1RCxFQUF3RUcsTUFBTSxDQUFDNEUsNkJBQS9FLENBQS9CLENBSGlGLENBS2pGOztBQUNBaEYsV0FBRyxDQUFDcUUsYUFBSixDQUFrQixTQUFsQixJQUErQnJKLE1BQU0sQ0FBQ1osRUFBUCxDQUFXNkYsT0FBWCxFQUFvQix3SEFBcEIsRUFBOEksT0FBOUksRUFBdUpHLE1BQU0sQ0FBQzZFLDBCQUE5SixDQUEvQjtBQUNBakYsV0FBRyxDQUFDcUUsYUFBSixDQUFrQixTQUFsQixJQUErQnJKLE1BQU0sQ0FBQ1osRUFBUCxDQUFXNkYsT0FBWCxFQUFvQixvSEFBcEIsRUFBMEksT0FBMUksRUFBbUpHLE1BQU0sQ0FBQzhFLDZCQUExSixDQUEvQjtBQUNILE9BYmEsQ0FlZDs7O0FBQ0FsRixTQUFHLENBQUNxRSxhQUFKLENBQWtCLFNBQWxCLElBQStCckosTUFBTSxDQUFDWixFQUFQLENBQVU2RixPQUFWLEVBQW1CLDRFQUFuQixFQUFpRyxPQUFqRyxFQUEwR0csTUFBTSxDQUFDK0UsZUFBakgsQ0FBL0IsQ0FoQmMsQ0FrQmQ7O0FBQ0EsVUFBSW5GLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWlKLE1BQVosSUFBc0I1RCxHQUFHLENBQUNyRixPQUFKLENBQVlpSixNQUFaLENBQW1CdkksTUFBN0MsRUFBcUQ7QUFDakQrRSxjQUFNLENBQUNuRixVQUFQO0FBQ0g7QUFDSixLQWpHUTs7QUFtR1Q7Ozs7QUFJQW1KLFNBQUssRUFBRSxpQkFBVztBQUNkcEosWUFBTSxDQUFDdUksR0FBUCxDQUFZdEQsT0FBWixFQUFxQixPQUFyQixFQUE4QkQsR0FBRyxDQUFDcUUsYUFBSixDQUFrQixTQUFsQixDQUE5QixFQURjLENBR2Q7O0FBQ0FySixZQUFNLENBQUN1SSxHQUFQLENBQVl0RCxPQUFaLEVBQXFCLFdBQXJCLEVBQWtDRCxHQUFHLENBQUNxRSxhQUFKLENBQWtCLFNBQWxCLENBQWxDO0FBQ0FySixZQUFNLENBQUN1SSxHQUFQLENBQVl0RCxPQUFaLEVBQXFCLFVBQXJCLEVBQWlDRCxHQUFHLENBQUNxRSxhQUFKLENBQWtCLFNBQWxCLENBQWpDLEVBTGMsQ0FPZDs7QUFDQXJKLFlBQU0sQ0FBQ3VJLEdBQVAsQ0FBWXRELE9BQVosRUFBcUIsT0FBckIsRUFBOEJELEdBQUcsQ0FBQ3FFLGFBQUosQ0FBa0IsU0FBbEIsQ0FBOUI7QUFDQXJKLFlBQU0sQ0FBQ3VJLEdBQVAsQ0FBWXRELE9BQVosRUFBcUIsT0FBckIsRUFBOEJELEdBQUcsQ0FBQ3FFLGFBQUosQ0FBa0IsU0FBbEIsQ0FBOUIsRUFUYyxDQVdkOztBQUNBckosWUFBTSxDQUFDdUksR0FBUCxDQUFXdEQsT0FBWCxFQUFvQixPQUFwQixFQUE2QkQsR0FBRyxDQUFDcUUsYUFBSixDQUFrQixTQUFsQixDQUE3QjtBQUNILEtBcEhROztBQXNIVDs7OztBQUlBcEosY0FBVSxFQUFFLHNCQUFXO0FBQ25CLFVBQUsrRSxHQUFHLENBQUNyRixPQUFKLENBQVlpSixNQUFaLElBQXNCNUQsR0FBRyxDQUFDckYsT0FBSixDQUFZaUosTUFBWixDQUFtQnZJLE1BQTlDLEVBQXVEO0FBQ25ETCxjQUFNLENBQUNvSyxhQUFQLENBQXFCbkYsT0FBckI7QUFDQWpGLGNBQU0sQ0FBQ0MsVUFBUCxDQUFrQmdGLE9BQWxCLEVBQTJCO0FBQUMvRSw0QkFBa0IsRUFBRSxJQUFyQjtBQUEyQm1LLHNCQUFZLEVBQUUsS0FBekM7QUFBZ0RDLDhCQUFvQixFQUFFLElBQXRFO0FBQTRFbkssNEJBQWtCLEVBQUUsSUFBaEc7QUFBc0dFLGdCQUFNLEVBQUUyRSxHQUFHLENBQUNyRixPQUFKLENBQVlpSixNQUFaLENBQW1CdkksTUFBakk7QUFBeUlELDBCQUFnQixFQUFFNEUsR0FBRyxDQUFDckYsT0FBSixDQUFZaUosTUFBWixDQUFtQnhJO0FBQTlLLFNBQTNCO0FBQ0gsT0FIRCxNQUdPO0FBQ0hKLGNBQU0sQ0FBQ29LLGFBQVAsQ0FBcUJuRixPQUFyQjtBQUNIO0FBQ0osS0FqSVE7O0FBbUlUOzs7QUFHQXNGLGdCQUFZLEVBQUUsd0JBQVc7QUFDckIsVUFBS3ZGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWlKLE1BQVosSUFBc0I1RCxHQUFHLENBQUNyRixPQUFKLENBQVlpSixNQUFaLENBQW1CdkksTUFBOUMsRUFBdUQ7QUFDbkRMLGNBQU0sQ0FBQ3VLLFlBQVAsQ0FBb0J0RixPQUFwQjtBQUNIO0FBQ0osS0ExSVE7O0FBNElUOzs7QUFHQXVGLGFBQVMsRUFBRSxxQkFBVztBQUNsQixVQUFLeEYsR0FBRyxDQUFDckYsT0FBSixDQUFZaUosTUFBWixJQUFzQjVELEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWlKLE1BQVosQ0FBbUJ2SSxNQUE5QyxFQUF1RDtBQUNuREwsY0FBTSxDQUFDd0ssU0FBUCxDQUFpQnZGLE9BQWpCO0FBQ0g7QUFDSixLQW5KUTs7QUFxSlQ7Ozs7QUFJQTRFLGtCQUFjLEVBQUUsd0JBQVN6TCxFQUFULEVBQWE7QUFDekIsVUFBSzRCLE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsU0FBM0IsQ0FBTCxFQUE2QztBQUN6QyxZQUFJbEMsRUFBRSxJQUFJNEIsTUFBTSxDQUFDeUssT0FBUCxDQUFlck0sRUFBZixFQUFtQiw0QkFBbkIsQ0FBTixJQUEwRDRCLE1BQU0sQ0FBQ21FLElBQVAsQ0FBWS9GLEVBQVosRUFBZ0IsNEJBQWhCLEtBQWlELE9BQS9HLEVBQXdIO0FBQ3BILGlCQUFPLFVBQVA7QUFDSDs7QUFFRCxZQUFLNEIsTUFBTSxDQUFDMEssS0FBUCxDQUFhMUYsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0wsT0FBekIsRUFBa0Msb0JBQWxDLENBQUwsRUFBK0Q7QUFDM0QsY0FBSzNLLE1BQU0sQ0FBQzRLLFVBQVAsQ0FBa0IxRixJQUFsQixFQUF3QkYsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0wsT0FBWixDQUFvQjlDLE9BQXBCLENBQTRCM0YsS0FBNUIsQ0FBa0NnRCxJQUExRCxDQUFMLEVBQXVFO0FBQ25FLG1CQUFPRixHQUFHLENBQUNyRixPQUFKLENBQVlnTCxPQUFaLENBQW9COUMsT0FBcEIsQ0FBNEIzRixLQUE1QixDQUFrQzJJLElBQXpDO0FBQ0gsV0FGRCxNQUVPO0FBQ0gsbUJBQU83RixHQUFHLENBQUNyRixPQUFKLENBQVlnTCxPQUFaLENBQW9COUMsT0FBcEIsV0FBUDtBQUNIO0FBQ0osU0FORCxNQU1PLElBQUs3SCxNQUFNLENBQUMwSyxLQUFQLENBQWExRixHQUFHLENBQUNyRixPQUFKLENBQVlnTCxPQUF6QixFQUFrQyxTQUFsQyxDQUFMLEVBQW9EO0FBQ3ZELGlCQUFPM0YsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0wsT0FBWixDQUFvQjlDLE9BQTNCO0FBQ0g7QUFDSixPQWRELE1BY08sSUFBSzdILE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsUUFBM0IsS0FBd0NOLE1BQU0sQ0FBQzBLLEtBQVAsQ0FBYTFGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdMLE9BQXpCLEVBQWtDLFFBQWxDLENBQTdDLEVBQTJGO0FBQzlGLGVBQU8zRixHQUFHLENBQUNyRixPQUFKLENBQVlnTCxPQUFaLENBQW9CRyxNQUEzQjtBQUNILE9BRk0sTUFFQSxJQUFLOUssTUFBTSxDQUFDTSxtQkFBUCxDQUEyQixRQUEzQixLQUF3Q04sTUFBTSxDQUFDMEssS0FBUCxDQUFhMUYsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0wsT0FBekIsRUFBa0MsUUFBbEMsQ0FBN0MsRUFBMkY7QUFDOUYsZUFBTzNGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdMLE9BQVosQ0FBb0IvQyxNQUEzQjtBQUNILE9BRk0sTUFFQTtBQUNILGVBQU8sS0FBUDtBQUNIO0FBQ0osS0EvS1E7O0FBaUxUOzs7O0FBSUFrQyxnQ0FBNEIsRUFBRSx3Q0FBVztBQUNyQyxVQUFLOUosTUFBTSxDQUFDTSxtQkFBUCxDQUEyQixTQUEzQixLQUF5Q04sTUFBTSxDQUFDMEssS0FBUCxDQUFhMUYsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0wsT0FBekIsRUFBa0Msb0JBQWxDLENBQTlDLEVBQXdHO0FBQ3BHLGVBQU8sSUFBUDtBQUNILE9BRkQsTUFFTztBQUNILGVBQU8sS0FBUDtBQUNIO0FBQ0osS0EzTFE7O0FBOExUOzs7O0FBSUFoQixxQkFBaUIsRUFBRSwyQkFBUzNJLENBQVQsRUFBWTtBQUMzQixVQUFJK0osUUFBUSxHQUFHL0ssTUFBTSxDQUFDZ0wsT0FBUCxDQUFlL0YsT0FBZixFQUF3QixnQkFBeEIsQ0FBZjs7QUFDQSxVQUFLOEYsUUFBTCxFQUFnQjtBQUNaLGFBQUssSUFBSXRFLENBQUMsR0FBRyxDQUFSLEVBQVd3RSxHQUFHLEdBQUdGLFFBQVEsQ0FBQ3RKLE1BQS9CLEVBQXVDZ0YsQ0FBQyxHQUFHd0UsR0FBM0MsRUFBZ0R4RSxDQUFDLEVBQWpELEVBQXFEO0FBQ2pEekcsZ0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzBKLFFBQVEsQ0FBQyxDQUFELENBQW5CLEVBQXdCLFNBQXhCLEVBQW1DLEVBQW5DO0FBQ0EvSyxnQkFBTSxDQUFDcUIsR0FBUCxDQUFXMEosUUFBUSxDQUFDLENBQUQsQ0FBbkIsRUFBd0IsVUFBeEIsRUFBb0MsRUFBcEM7QUFDSDtBQUNKO0FBQ0osS0ExTVE7O0FBNE1UOzs7O0FBSUFoQixrQ0FBOEIsRUFBRSx3Q0FBUy9JLENBQVQsRUFBWTtBQUN4QyxVQUFLb0UsTUFBTSxDQUFDeUUsY0FBUCxDQUFzQixJQUF0QixNQUFnQyxXQUFyQyxFQUFtRDtBQUMvQztBQUNIOztBQUVELFVBQUs3RSxHQUFHLENBQUNrRyxtQkFBSixPQUE4QixLQUFuQyxFQUEyQztBQUN2QztBQUNIOztBQUVELFVBQUlDLElBQUksR0FBRyxJQUFYOztBQUVBLFVBQUtBLElBQUksQ0FBQ0MsWUFBTCxDQUFrQixZQUFsQixLQUFtQyxHQUF4QyxFQUE4QztBQUMxQ0QsWUFBSSxDQUFDRSxlQUFMLENBQXFCLFlBQXJCO0FBQ0FDLG9CQUFZLENBQUVILElBQUksQ0FBQ0MsWUFBTCxDQUFrQixjQUFsQixDQUFGLENBQVo7QUFDQUQsWUFBSSxDQUFDRSxlQUFMLENBQXFCLGNBQXJCO0FBQ0g7O0FBRURqRyxZQUFNLENBQUNtRyxtQkFBUCxDQUEyQkosSUFBM0I7QUFDSCxLQWxPUTs7QUFvT1Q7Ozs7QUFJQW5CLGlDQUE2QixFQUFFLHVDQUFTaEosQ0FBVCxFQUFZO0FBQ3ZDLFVBQUtnRSxHQUFHLENBQUNrRyxtQkFBSixPQUE4QixLQUFuQyxFQUEyQztBQUN2QztBQUNIOztBQUVELFVBQUs5RixNQUFNLENBQUN5RSxjQUFQLENBQXNCLElBQXRCLE1BQWdDLFdBQXJDLEVBQW1EO0FBQy9DO0FBQ0g7O0FBRUQsVUFBSXNCLElBQUksR0FBRyxJQUFYO0FBQ0EsVUFBSUssSUFBSSxHQUFHeEcsR0FBRyxDQUFDckYsT0FBSixDQUFZdUosUUFBWixDQUFxQkMsT0FBaEM7QUFFQSxVQUFJQSxPQUFPLEdBQUdzQyxVQUFVLENBQUMsWUFBVztBQUNoQyxZQUFLTixJQUFJLENBQUNDLFlBQUwsQ0FBa0IsWUFBbEIsS0FBbUMsR0FBeEMsRUFBOEM7QUFDMUNoRyxnQkFBTSxDQUFDc0csbUJBQVAsQ0FBMkJQLElBQTNCLEVBQWlDLElBQWpDO0FBQ0g7QUFDSixPQUp1QixFQUlyQkssSUFKcUIsQ0FBeEI7QUFNQUwsVUFBSSxDQUFDUSxZQUFMLENBQWtCLFlBQWxCLEVBQWdDLEdBQWhDO0FBQ0FSLFVBQUksQ0FBQ1EsWUFBTCxDQUFrQixjQUFsQixFQUFrQ3hDLE9BQWxDO0FBQ0gsS0E1UFE7O0FBOFBUOzs7O0FBSUFjLDhCQUEwQixFQUFFLG9DQUFTakosQ0FBVCxFQUFZO0FBQ3BDLFVBQUtvRSxNQUFNLENBQUN5RSxjQUFQLENBQXNCLElBQXRCLE1BQWdDLFdBQXJDLEVBQW1EO0FBQy9DO0FBQ0g7O0FBRUQsVUFBSXNCLElBQUksR0FBRyxLQUFLM0ssT0FBTCxDQUFhLGFBQWIsQ0FBWDs7QUFFQSxVQUFLMkssSUFBSSxDQUFDQyxZQUFMLENBQWtCLDBCQUFsQixLQUFpRCxXQUF0RCxFQUFvRTtBQUNoRTtBQUNIOztBQUVELFVBQUtwTCxNQUFNLENBQUM0TCxRQUFQLENBQWdCVCxJQUFoQixFQUFzQixtQkFBdEIsTUFBK0MsS0FBcEQsRUFBNEQ7QUFDeERuTCxjQUFNLENBQUNSLFFBQVAsQ0FBZ0IyTCxJQUFoQixFQUFzQiwyQkFBdEI7QUFDQS9GLGNBQU0sQ0FBQ21HLG1CQUFQLENBQTJCSixJQUEzQjtBQUNILE9BSEQsTUFHTztBQUNIbkwsY0FBTSxDQUFDb0UsV0FBUCxDQUFtQitHLElBQW5CLEVBQXlCLDJCQUF6QjtBQUNBL0YsY0FBTSxDQUFDc0csbUJBQVAsQ0FBMkJQLElBQTNCLEVBQWlDLElBQWpDO0FBQ0g7O0FBRURuSyxPQUFDLENBQUNnRixjQUFGO0FBQ0gsS0F0UlE7O0FBd1JUOzs7O0FBSUFrRSxpQ0FBNkIsRUFBRSx1Q0FBU2xKLENBQVQsRUFBWTtBQUN2QyxVQUFJb0UsTUFBTSxDQUFDeUUsY0FBUCxDQUFzQixJQUF0QixNQUFnQyxXQUFwQyxFQUFpRDtBQUM3QztBQUNIOztBQUVELFVBQUlzQixJQUFJLEdBQUcsS0FBSzNLLE9BQUwsQ0FBYSxhQUFiLENBQVg7O0FBRUEsVUFBSTJLLElBQUksQ0FBQ0MsWUFBTCxDQUFrQiwwQkFBbEIsS0FBaUQsV0FBckQsRUFBa0U7QUFDOUQ7QUFDSDs7QUFFRCxVQUFJcEwsTUFBTSxDQUFDNEwsUUFBUCxDQUFnQlQsSUFBaEIsRUFBc0IsbUJBQXRCLEtBQThDLEtBQWxELEVBQXlEO0FBQ3JEbkwsY0FBTSxDQUFDUixRQUFQLENBQWdCMkwsSUFBaEIsRUFBc0IsMkJBQXRCO0FBQ0EvRixjQUFNLENBQUNtRyxtQkFBUCxDQUEyQkosSUFBM0I7QUFDSDs7QUFFRG5LLE9BQUMsQ0FBQ2dGLGNBQUY7QUFDSCxLQTdTUTs7QUErU1Q7Ozs7QUFJQW1FLG1CQUFlLEVBQUUseUJBQVNuSixDQUFULEVBQVk7QUFDekIsVUFBSTJKLE9BQU8sR0FBRyxLQUFLbkssT0FBTCxDQUFhLGlDQUFiLENBQWQsQ0FEeUIsQ0FDc0M7O0FBRS9ELFVBQUk2RixNQUFNLEdBQUdqQixNQUFNLENBQUNvQixZQUFQLENBQW9CLFdBQXBCLEVBQWlDLElBQWpDLEVBQXVDeEYsQ0FBdkMsQ0FBYjs7QUFDQSxVQUFJcUYsTUFBTSxLQUFLLEtBQWYsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRCxVQUFLc0UsT0FBTyxJQUFJdkYsTUFBTSxDQUFDeUUsY0FBUCxDQUFzQmMsT0FBdEIsTUFBbUMsVUFBbkQsRUFBZ0U7QUFDNUR2RixjQUFNLENBQUN5RyxvQkFBUDtBQUNIO0FBQ0osS0E5VFE7O0FBZ1VUOzs7O0FBSUFDLDhCQUEwQixFQUFFLG9DQUFTOUssQ0FBVCxFQUFZNUMsRUFBWixFQUFnQjtBQUN4QztBQUNBLFVBQUlnSCxNQUFNLENBQUN5RSxjQUFQLENBQXNCekwsRUFBdEIsTUFBOEIsV0FBbEMsRUFBK0M7QUFDM0M7QUFDSDs7QUFFRCxVQUFJa0osS0FBSyxHQUFHckMsT0FBTyxDQUFDOEcsZ0JBQVIsQ0FBeUIsMEVBQXpCLENBQVosQ0FOd0MsQ0FReEM7O0FBQ0EsVUFBSXpFLEtBQUssQ0FBQzdGLE1BQU4sR0FBZSxDQUFmLElBQW9CekIsTUFBTSxDQUFDNEwsUUFBUCxDQUFnQnhOLEVBQWhCLEVBQW9CLGNBQXBCLE1BQXdDLEtBQTVELElBQXFFQSxFQUFFLENBQUMyTixnQkFBSCxDQUFvQixlQUFwQixFQUFxQ3RLLE1BQXJDLEtBQWdELENBQXpILEVBQTRIO0FBQ3hIO0FBQ0EsYUFBSyxJQUFJZ0YsQ0FBQyxHQUFHLENBQVIsRUFBV3dFLEdBQUcsR0FBRzNELEtBQUssQ0FBQzdGLE1BQTVCLEVBQW9DZ0YsQ0FBQyxHQUFHd0UsR0FBeEMsRUFBNkN4RSxDQUFDLEVBQTlDLEVBQWtEO0FBQzlDckIsZ0JBQU0sQ0FBQ3NHLG1CQUFQLENBQTJCcEUsS0FBSyxDQUFDLENBQUQsQ0FBaEMsRUFBcUMsSUFBckM7QUFDSDtBQUNKO0FBQ0osS0FuVlE7O0FBcVZUOzs7O0FBSUFzQywwQkFBc0IsRUFBRSxnQ0FBUzVJLENBQVQsRUFBWTVDLEVBQVosRUFBZ0I7QUFDcEMsVUFBSTROLEtBQUo7QUFDQSxVQUFJYixJQUFJLEdBQUcvTSxFQUFFLEdBQUdBLEVBQUgsR0FBUSxJQUFyQjs7QUFFQSxVQUFLZ0gsTUFBTSxDQUFDeUUsY0FBUCxDQUFzQnpMLEVBQXRCLE1BQThCLFVBQTlCLEtBQTZDNE4sS0FBSyxHQUFHYixJQUFJLENBQUMzSyxPQUFMLENBQWEsYUFBYixDQUFyRCxDQUFMLEVBQTBGO0FBQ3RGLFlBQUl3TCxLQUFLLENBQUNaLFlBQU4sQ0FBbUIsMEJBQW5CLEtBQWtELFdBQXRELEVBQW9FO0FBQ2hFcEssV0FBQyxDQUFDZ0YsY0FBRjtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxVQUFJaUcsRUFBRSxHQUFHZCxJQUFJLENBQUMzSyxPQUFMLENBQWEsYUFBYixDQUFUO0FBQ0EsVUFBSW1LLE9BQU8sR0FBRzNLLE1BQU0sQ0FBQ2tNLEtBQVAsQ0FBYUQsRUFBYixFQUFpQiw4QkFBakIsQ0FBZDs7QUFFQSxVQUFJak0sTUFBTSxDQUFDNEwsUUFBUCxDQUFnQlQsSUFBSSxDQUFDM0ssT0FBTCxDQUFhLGFBQWIsQ0FBaEIsRUFBNkMseUJBQTdDLENBQUosRUFBNkU7QUFDekU7QUFDSDs7QUFFRCxVQUFLeUwsRUFBRSxJQUFJdEIsT0FBWCxFQUFxQjtBQUNqQjNKLFNBQUMsQ0FBQ2dGLGNBQUY7QUFDQSxZQUFJbUcsS0FBSyxHQUFHbkgsR0FBRyxDQUFDckYsT0FBSixDQUFZa0osU0FBWixDQUFzQkMsVUFBbEM7QUFDQSxZQUFJc0QsWUFBWSxHQUFHLEtBQW5COztBQUVBLFlBQUtwTSxNQUFNLENBQUM0TCxRQUFQLENBQWdCSyxFQUFoQixFQUFvQixrQkFBcEIsTUFBNEMsS0FBakQsRUFBeUQ7QUFDckQ7QUFDQSxjQUFLakgsR0FBRyxDQUFDckYsT0FBSixDQUFZa0osU0FBWixDQUFzQkksU0FBdEIsS0FBb0MsS0FBekMsRUFBaUQ7QUFDN0MsZ0JBQUlvRCxNQUFNLEdBQUdsQixJQUFJLENBQUMzSyxPQUFMLENBQWEsMkJBQWIsQ0FBYjtBQUNBLGdCQUFJOEwsU0FBUyxHQUFHdE0sTUFBTSxDQUFDdU0sUUFBUCxDQUFnQkYsTUFBaEIsRUFBd0IsdUdBQXhCLENBQWhCOztBQUVBLGdCQUFLQSxNQUFNLElBQUlDLFNBQWYsRUFBMkI7QUFDdkIsbUJBQUssSUFBSTdGLENBQUMsR0FBRyxDQUFSLEVBQVd3RSxHQUFHLEdBQUdxQixTQUFTLENBQUM3SyxNQUFoQyxFQUF3Q2dGLENBQUMsR0FBR3dFLEdBQTVDLEVBQWlEeEUsQ0FBQyxFQUFsRCxFQUFzRDtBQUNsRCxvQkFBSStGLEdBQUcsR0FBR0YsU0FBUyxDQUFDLENBQUQsQ0FBbkI7QUFDQSxvQkFBSUcsUUFBUSxHQUFHek0sTUFBTSxDQUFDa00sS0FBUCxDQUFhTSxHQUFiLEVBQWtCLGdCQUFsQixDQUFmOztBQUNBLG9CQUFLQyxRQUFMLEVBQWdCO0FBQ1p6TSx3QkFBTSxDQUFDME0sT0FBUCxDQUFlRCxRQUFmLEVBQXlCTixLQUF6QixFQUFnQyxZQUFXO0FBQ3ZDL0csMEJBQU0sQ0FBQ21GLFlBQVA7QUFDQXZLLDBCQUFNLENBQUNvRSxXQUFQLENBQW1Cb0ksR0FBbkIsRUFBd0Isa0JBQXhCO0FBQ0gsbUJBSEQ7QUFJSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRHhNLGdCQUFNLENBQUMyTSxTQUFQLENBQWlCaEMsT0FBakIsRUFBMEJ3QixLQUExQixFQUFpQyxZQUFXO0FBQ3hDL0csa0JBQU0sQ0FBQ3dILFlBQVAsQ0FBb0J6QixJQUFwQjtBQUNBL0Ysa0JBQU0sQ0FBQ21GLFlBQVA7QUFFQW5GLGtCQUFNLENBQUNvQixZQUFQLENBQW9CLGVBQXBCLEVBQXFDbUUsT0FBckMsRUFBOEMzSixDQUE5QztBQUNILFdBTEQ7QUFPQWhCLGdCQUFNLENBQUNSLFFBQVAsQ0FBZ0J5TSxFQUFoQixFQUFvQixrQkFBcEI7QUFFSCxTQTdCRCxNQTZCTztBQUNIak0sZ0JBQU0sQ0FBQzBNLE9BQVAsQ0FBZS9CLE9BQWYsRUFBd0J3QixLQUF4QixFQUErQixZQUFXO0FBQ3RDL0csa0JBQU0sQ0FBQ3dILFlBQVAsQ0FBb0J6QixJQUFwQjtBQUNBL0Ysa0JBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsZUFBcEIsRUFBcUNtRSxPQUFyQyxFQUE4QzNKLENBQTlDO0FBQ0gsV0FIRDtBQUtBaEIsZ0JBQU0sQ0FBQ29FLFdBQVAsQ0FBbUI2SCxFQUFuQixFQUF1QixrQkFBdkI7QUFDSDtBQUNKO0FBQ0osS0F0WlE7O0FBd1pUOzs7O0FBSUFXLGdCQUFZLEVBQUUsc0JBQVN6QixJQUFULEVBQWU7QUFDekI7QUFDQSxVQUFLbkwsTUFBTSxDQUFDTSxtQkFBUCxDQUEyQixTQUEzQixLQUF5QzBFLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWtKLFNBQVosQ0FBc0JFLFVBQS9ELElBQTZFOUQsT0FBTyxDQUFDbUcsWUFBUixDQUFxQixvQkFBckIsTUFBK0MsR0FBakksRUFBdUk7QUFDbklwTCxjQUFNLENBQUM2TSxRQUFQLENBQWdCMUIsSUFBaEIsRUFBc0JuRyxHQUFHLENBQUNyRixPQUFKLENBQVlrSixTQUFaLENBQXNCRyxlQUE1QztBQUNIO0FBQ0osS0FqYVE7O0FBbWFUOzs7O0FBSUEwQyx1QkFBbUIsRUFBRSw2QkFBU1AsSUFBVCxFQUFlMkIsU0FBZixFQUEwQjtBQUMzQztBQUNBLFVBQUtBLFNBQUwsRUFBaUI7QUFDYjlNLGNBQU0sQ0FBQ29FLFdBQVAsQ0FBbUIrRyxJQUFuQixFQUF5QixtQkFBekI7QUFDQW5MLGNBQU0sQ0FBQ29FLFdBQVAsQ0FBbUIrRyxJQUFuQixFQUF5Qix3QkFBekI7QUFDSCxPQUwwQyxDQU8zQzs7O0FBQ0FBLFVBQUksQ0FBQ0UsZUFBTCxDQUFxQixZQUFyQjs7QUFFQSxVQUFLRixJQUFJLENBQUNDLFlBQUwsQ0FBa0IsbUNBQWxCLENBQUwsRUFBOEQ7QUFDMURwTCxjQUFNLENBQUNvRSxXQUFQLENBQW1CYyxJQUFuQixFQUF5QmlHLElBQUksQ0FBQ0MsWUFBTCxDQUFrQixtQ0FBbEIsQ0FBekI7QUFDSDs7QUFFRCxVQUFJakMsT0FBTyxHQUFHZ0MsSUFBSSxDQUFDQyxZQUFMLENBQWtCLGNBQWxCLENBQWQ7QUFDQUQsVUFBSSxDQUFDRSxlQUFMLENBQXFCLGNBQXJCO0FBQ0FDLGtCQUFZLENBQUNuQyxPQUFELENBQVo7QUFDSCxLQXhiUTs7QUEwYlQ7Ozs7QUFJQTBDLHdCQUFvQixFQUFFLGdDQUFXO0FBQzdCLFVBQUlrQixLQUFKOztBQUNBLFVBQUtBLEtBQUssR0FBRzlILE9BQU8sQ0FBQzhHLGdCQUFSLENBQXlCLHVHQUF6QixDQUFiLEVBQWlKO0FBQzdJLGFBQUssSUFBSWlCLENBQUMsR0FBRyxDQUFSLEVBQVdDLEdBQUcsR0FBR0YsS0FBSyxDQUFDdEwsTUFBNUIsRUFBb0N1TCxDQUFDLEdBQUdDLEdBQXhDLEVBQTZDRCxDQUFDLEVBQTlDLEVBQWtEO0FBQzlDNUgsZ0JBQU0sQ0FBQ3NHLG1CQUFQLENBQTJCcUIsS0FBSyxDQUFDQyxDQUFELENBQWhDLEVBQXFDLElBQXJDO0FBQ0g7QUFDSjtBQUNKLEtBcmNROztBQXVjVDs7OztBQUlBekIsdUJBQW1CLEVBQUUsNkJBQVNKLElBQVQsRUFBZTtBQUNoQztBQUNBLFVBQUkrQixJQUFJLEdBQUdqSSxPQUFPLENBQUM4RyxnQkFBUixDQUF5QixxRkFBekIsQ0FBWDs7QUFFQSxVQUFLbUIsSUFBTCxFQUFZO0FBQ1IsYUFBSyxJQUFJekcsQ0FBQyxHQUFHLENBQVIsRUFBV3dFLEdBQUcsR0FBR2lDLElBQUksQ0FBQ3pMLE1BQTNCLEVBQW1DZ0YsQ0FBQyxHQUFHd0UsR0FBdkMsRUFBNEN4RSxDQUFDLEVBQTdDLEVBQWlEO0FBQzdDLGNBQUlySSxFQUFFLEdBQUc4TyxJQUFJLENBQUN6RyxDQUFELENBQWI7O0FBQ0EsY0FBSzBFLElBQUksS0FBSy9NLEVBQVQsSUFBZUEsRUFBRSxDQUFDK08sUUFBSCxDQUFZaEMsSUFBWixNQUFzQixLQUFyQyxJQUE4Q0EsSUFBSSxDQUFDZ0MsUUFBTCxDQUFjL08sRUFBZCxNQUFzQixLQUF6RSxFQUFpRjtBQUM3RWdILGtCQUFNLENBQUNzRyxtQkFBUCxDQUEyQnROLEVBQTNCLEVBQStCLElBQS9CO0FBQ0g7QUFDSjtBQUNKLE9BWCtCLENBYWhDOzs7QUFDQTRCLFlBQU0sQ0FBQ1IsUUFBUCxDQUFnQjJMLElBQWhCLEVBQXNCLG1CQUF0Qjs7QUFFQSxVQUFLQSxJQUFJLENBQUNDLFlBQUwsQ0FBa0IsbUNBQWxCLENBQUwsRUFBOEQ7QUFDMURwTCxjQUFNLENBQUNSLFFBQVAsQ0FBZ0IwRixJQUFoQixFQUFzQmlHLElBQUksQ0FBQ0MsWUFBTCxDQUFrQixtQ0FBbEIsQ0FBdEI7QUFDSDtBQUNKLEtBOWRROztBQWdlVDs7OztBQUlBZ0MscUNBQWlDLEVBQUUsMkNBQVNoUCxFQUFULEVBQWE7QUFDNUMsVUFBSTROLEtBQUo7QUFDQSxVQUFJdkksTUFBTSxHQUFHLENBQUN1SSxLQUFLLEdBQUdoTSxNQUFNLENBQUNrTSxLQUFQLENBQWE5TixFQUFiLEVBQWlCLGdCQUFqQixJQUFxQzRCLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJLLEtBQVgsRUFBa0IsU0FBbEIsQ0FBckMsR0FBb0UsQ0FBN0UsSUFBa0YsQ0FBL0Y7QUFFQSxVQUFJcUIsT0FBTyxHQUFHM0ssUUFBUSxDQUFDQyxhQUFULENBQXVCLGdJQUFnSWMsTUFBaEksR0FBeUksVUFBaEssQ0FBZDtBQUVBeUIsVUFBSSxDQUFDbUMsV0FBTCxDQUFpQmdHLE9BQWpCO0FBRUFyTixZQUFNLENBQUMrRixRQUFQLENBQWdCc0gsT0FBaEIsRUFBeUIsT0FBekIsRUFBa0MsVUFBU3JNLENBQVQsRUFBWTtBQUMxQ0EsU0FBQyxDQUFDc00sZUFBRjtBQUNBdE0sU0FBQyxDQUFDZ0YsY0FBRjtBQUNBaEcsY0FBTSxDQUFDZ0QsTUFBUCxDQUFjLElBQWQ7QUFDQW9DLGNBQU0sQ0FBQ3NHLG1CQUFQLENBQTJCdE4sRUFBM0IsRUFBK0IsSUFBL0I7QUFDSCxPQUxEO0FBTUgsS0FsZlE7O0FBb2ZUOzs7O0FBSUFtUCxzQkFBa0IsRUFBRSw0QkFBUy9CLElBQVQsRUFBZTtBQUMvQixVQUFJZ0MsSUFBSSxHQUFHLElBQUlDLElBQUosRUFBWDtBQUVBekksU0FBRyxDQUFDc0Usc0JBQUosR0FBNkJrRSxJQUFJLENBQUNFLE9BQUwsS0FBaUJsQyxJQUE5QztBQUNILEtBNWZROztBQThmVDs7OztBQUlBTix1QkFBbUIsRUFBRSwrQkFBVztBQUM1QixVQUFJc0MsSUFBSSxHQUFHLElBQUlDLElBQUosRUFBWDtBQUVBLGFBQVFELElBQUksQ0FBQ0UsT0FBTCxLQUFpQjFJLEdBQUcsQ0FBQ3NFLHNCQUFyQixHQUE4QyxJQUE5QyxHQUFxRCxLQUE3RDtBQUNILEtBdGdCUTs7QUF3Z0JUOzs7O0FBSUFxRSxtQkFBZSxFQUFFLHlCQUFTeEMsSUFBVCxFQUFlO0FBQzVCLFVBQUkrQixJQUFKO0FBQ0EsVUFBSVUsT0FBSjtBQUVBVixVQUFJLEdBQUdqSSxPQUFPLENBQUM4RyxnQkFBUixDQUF5QixxQkFBekIsQ0FBUDs7QUFFQSxXQUFLLElBQUl0RixDQUFDLEdBQUcsQ0FBUixFQUFXd0UsR0FBRyxHQUFHaUMsSUFBSSxDQUFDekwsTUFBM0IsRUFBbUNnRixDQUFDLEdBQUd3RSxHQUF2QyxFQUE0Q3hFLENBQUMsRUFBN0MsRUFBaUQ7QUFDN0MsWUFBSXJJLEVBQUUsR0FBRzhPLElBQUksQ0FBQyxDQUFELENBQWI7QUFDQWxOLGNBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJoRyxFQUFuQixFQUF1QixvQkFBdkI7QUFDQTRCLGNBQU0sQ0FBQ1MsSUFBUCxDQUFhVCxNQUFNLENBQUNrTSxLQUFQLENBQWE5TixFQUFiLEVBQWlCLGdCQUFqQixDQUFiO0FBQ0F3UCxlQUFPLEdBQUc1TixNQUFNLENBQUM0TixPQUFQLENBQWV4UCxFQUFmLEVBQW1CLHNCQUFuQixLQUE4QyxFQUF4RDs7QUFFQSxhQUFLLElBQUl5UCxFQUFFLEdBQUcsQ0FBVCxFQUFZQyxJQUFJLEdBQUdGLE9BQU8sQ0FBQ25NLE1BQWhDLEVBQXdDb00sRUFBRSxHQUFHQyxJQUE3QyxFQUFtREQsRUFBRSxFQUFyRCxFQUF5RDtBQUNyRCxjQUFJckIsR0FBRyxHQUFHb0IsT0FBTyxDQUFDbkgsQ0FBRCxDQUFqQjtBQUNBekcsZ0JBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJvSSxHQUFuQixFQUF3QixrQkFBeEI7QUFDQXhNLGdCQUFNLENBQUNTLElBQVAsQ0FBYVQsTUFBTSxDQUFDa00sS0FBUCxDQUFhTSxHQUFiLEVBQWtCLGdCQUFsQixDQUFiO0FBQ0g7QUFDSixPQWpCMkIsQ0FtQjVCOzs7QUFDQSxVQUFLeEgsR0FBRyxDQUFDckYsT0FBSixDQUFZa0osU0FBWixDQUFzQkksU0FBdEIsS0FBb0MsS0FBekMsRUFBaUQ7QUFDN0MsWUFBS2lFLElBQUksR0FBR2pJLE9BQU8sQ0FBQzhHLGdCQUFSLENBQXlCLG1CQUF6QixDQUFaLEVBQTREO0FBQ3hELGVBQUssSUFBSXRGLENBQUMsR0FBRyxDQUFSLEVBQVd3RSxHQUFHLEdBQUdpQyxJQUFJLENBQUN6TCxNQUEzQixFQUFtQ2dGLENBQUMsR0FBR3dFLEdBQXZDLEVBQTRDeEUsQ0FBQyxFQUE3QyxFQUFpRDtBQUM3Q3pHLGtCQUFNLENBQUNvRSxXQUFQLENBQW1Cd0osT0FBTyxDQUFDLENBQUQsQ0FBMUIsRUFBK0Isa0JBQS9CO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0F2aUJROztBQXlpQlQ7Ozs7QUFJQUcsaUJBQWEsRUFBRSx1QkFBUzVDLElBQVQsRUFBZTtBQUMxQjtBQUNBL0YsWUFBTSxDQUFDdUksZUFBUDtBQUVBLFVBQUlDLE9BQU8sR0FBRzVOLE1BQU0sQ0FBQzROLE9BQVAsQ0FBZXpDLElBQWYsRUFBcUIsc0JBQXJCLEtBQWdELEVBQTlEOztBQUNBLFdBQUssSUFBSTFFLENBQUMsR0FBRyxDQUFSLEVBQVd3RSxHQUFHLEdBQUcyQyxPQUFPLENBQUNuTSxNQUE5QixFQUFzQ2dGLENBQUMsR0FBR3dFLEdBQTFDLEVBQStDeEUsQ0FBQyxFQUFoRCxFQUFvRDtBQUNoRHpHLGNBQU0sQ0FBQ1IsUUFBUCxDQUFnQlEsTUFBTSxDQUFDNEMsR0FBUCxDQUFXZ0wsT0FBTyxDQUFDbkgsQ0FBRCxDQUFsQixDQUFoQixFQUF3QyxrQkFBeEM7QUFDSDs7QUFFRHpHLFlBQU0sQ0FBQ1IsUUFBUCxDQUFnQlEsTUFBTSxDQUFDNEMsR0FBUCxDQUFXdUksSUFBWCxDQUFoQixFQUFrQyxvQkFBbEM7QUFDSCxLQXZqQlE7O0FBeWpCVDs7OztBQUlBNkMsa0JBQWMsRUFBRSx3QkFBUzdDLElBQVQsRUFBZTtBQUMzQixVQUFJYSxLQUFKO0FBQ0EsVUFBSWlDLFdBQVcsR0FBRyxFQUFsQjtBQUNBLFVBQUlDLElBQUksR0FBR2xPLE1BQU0sQ0FBQ2tNLEtBQVAsQ0FBYWYsSUFBYixFQUFtQixhQUFuQixDQUFYO0FBRUE4QyxpQkFBVyxDQUFDbEgsSUFBWixDQUFpQjtBQUNib0gsWUFBSSxFQUFHbkMsS0FBSyxHQUFHaE0sTUFBTSxDQUFDa00sS0FBUCxDQUFhZ0MsSUFBYixFQUFtQixrQkFBbkIsSUFBeUNsQyxLQUFLLENBQUNsSixTQUEvQyxHQUEyRCxFQUQ3RDtBQUVic0wsYUFBSyxFQUFFRixJQUFJLENBQUM5QyxZQUFMLENBQWtCLE9BQWxCLENBRk07QUFHYmlELFlBQUksRUFBRUgsSUFBSSxDQUFDOUMsWUFBTCxDQUFrQixNQUFsQjtBQUhPLE9BQWpCO0FBTUEsVUFBSXdDLE9BQU8sR0FBRzVOLE1BQU0sQ0FBQzROLE9BQVAsQ0FBZXpDLElBQWYsRUFBcUIsc0JBQXJCLENBQWQ7O0FBQ0EsV0FBSyxJQUFJMUUsQ0FBQyxHQUFHLENBQVIsRUFBV3dFLEdBQUcsR0FBRzJDLE9BQU8sQ0FBQ25NLE1BQTlCLEVBQXNDZ0YsQ0FBQyxHQUFHd0UsR0FBMUMsRUFBK0N4RSxDQUFDLEVBQWhELEVBQW9EO0FBQ2hELFlBQUk2SCxXQUFXLEdBQUd0TyxNQUFNLENBQUNrTSxLQUFQLENBQWEwQixPQUFPLENBQUNuSCxDQUFELENBQXBCLEVBQXlCLGFBQXpCLENBQWxCO0FBRUF3SCxtQkFBVyxDQUFDbEgsSUFBWixDQUFpQjtBQUNib0gsY0FBSSxFQUFHbkMsS0FBSyxHQUFHaE0sTUFBTSxDQUFDa00sS0FBUCxDQUFhb0MsV0FBYixFQUEwQixrQkFBMUIsSUFBZ0R0QyxLQUFLLENBQUNsSixTQUF0RCxHQUFrRSxFQURwRTtBQUVic0wsZUFBSyxFQUFFRSxXQUFXLENBQUNsRCxZQUFaLENBQXlCLE9BQXpCLENBRk07QUFHYmlELGNBQUksRUFBRUMsV0FBVyxDQUFDbEQsWUFBWixDQUF5QixNQUF6QjtBQUhPLFNBQWpCO0FBS0g7O0FBRUQsYUFBUTZDLFdBQVcsQ0FBQ00sT0FBWixFQUFSO0FBQ0gsS0FwbEJROztBQXNsQlQ7Ozs7QUFJQUMsZ0JBQVksRUFBRSxzQkFBU3JELElBQVQsRUFBZTtBQUN6QixVQUFJYSxLQUFKO0FBRUEsYUFBUUEsS0FBSyxHQUFHaE0sTUFBTSxDQUFDa00sS0FBUCxDQUFhZixJQUFiLEVBQW1CLGtCQUFuQixJQUF5Q2EsS0FBSyxDQUFDbEosU0FBL0MsR0FBMkQsRUFBM0U7QUFDSCxLQTlsQlE7O0FBZ21CVDs7O0FBR0EwRCxnQkFBWSxFQUFFLHNCQUFTakMsSUFBVCxFQUFldEQsTUFBZixFQUF1QkQsQ0FBdkIsRUFBMEI7QUFDcEMsV0FBSyxJQUFJeUYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXaEUsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTZDO0FBQ3pDLFlBQUlDLEtBQUssR0FBRzFCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxDQUFaOztBQUNBLFlBQUtDLEtBQUssQ0FBQ25DLElBQU4sSUFBY0EsSUFBbkIsRUFBMEI7QUFDdEIsY0FBS21DLEtBQUssQ0FBQ0MsR0FBTixJQUFhLElBQWxCLEVBQXlCO0FBQ3JCLGdCQUFLRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxLQUFwQixFQUE0QjtBQUN4QjVCLGlCQUFHLENBQUNTLE1BQUosQ0FBV2dCLENBQVgsRUFBY0csS0FBZCxHQUFzQixJQUF0QjtBQUNBLHFCQUFPRixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjdGLE1BQXpCLEVBQWlDRCxDQUFqQyxDQUFQO0FBQ0g7QUFDSixXQUxELE1BS087QUFDSCxtQkFBTzBGLEtBQUssQ0FBQ0csT0FBTixDQUFjQyxJQUFkLENBQW1CLElBQW5CLEVBQXlCN0YsTUFBekIsRUFBaUNELENBQWpDLENBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQWpuQlE7QUFtbkJUK0UsWUFBUSxFQUFFLGtCQUFTeEIsSUFBVCxFQUFlc0MsT0FBZixFQUF3QkYsR0FBeEIsRUFBNkI7QUFDbkMzQixTQUFHLENBQUNTLE1BQUosQ0FBV3NCLElBQVgsQ0FBZ0I7QUFDWnhDLFlBQUksRUFBRUEsSUFETTtBQUVac0MsZUFBTyxFQUFFQSxPQUZHO0FBR1pGLFdBQUcsRUFBRUEsR0FITztBQUlaQyxhQUFLLEVBQUU7QUFKSyxPQUFoQjtBQU1ILEtBMW5CUTtBQTRuQlQ2SCxlQUFXLEVBQUUscUJBQVNsSyxJQUFULEVBQWU7QUFDeEIsVUFBSVMsR0FBRyxDQUFDUyxNQUFKLENBQVdsQixJQUFYLENBQUosRUFBc0I7QUFDbEIsZUFBT1MsR0FBRyxDQUFDUyxNQUFKLENBQVdsQixJQUFYLENBQVA7QUFDSDtBQUNKO0FBaG9CUSxHQUFiLENBdENzQyxDQXlxQnRDO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBUyxLQUFHLENBQUNnQyxXQUFKLEdBQWtCLFVBQVNySCxPQUFULEVBQWtCO0FBQ2hDd0Ysa0JBQWMsR0FBR3hGLE9BQWpCO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBcUYsS0FBRyxDQUFDdUYsWUFBSixHQUFtQixZQUFXO0FBQzFCLFdBQU9uRixNQUFNLENBQUNtRixZQUFQLEVBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0F2RixLQUFHLENBQUMwSixZQUFKLEdBQW1CLFlBQVc7QUFDMUIsV0FBT3RKLE1BQU0sQ0FBQ25GLFVBQVAsRUFBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQStFLEtBQUcsQ0FBQ3dGLFNBQUosR0FBZ0IsWUFBVztBQUN2QixXQUFPcEYsTUFBTSxDQUFDb0YsU0FBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBeEYsS0FBRyxDQUFDK0ksYUFBSixHQUFvQixVQUFTNUMsSUFBVCxFQUFlO0FBQy9CLFdBQU8vRixNQUFNLENBQUMySSxhQUFQLENBQXFCNUMsSUFBckIsQ0FBUDtBQUNILEdBRkQ7O0FBSUFuRyxLQUFHLENBQUMwRSxNQUFKLEdBQWEsWUFBVztBQUNwQixXQUFPdEUsTUFBTSxDQUFDc0UsTUFBUCxFQUFQO0FBQ0gsR0FGRDs7QUFJQTFFLEtBQUcsQ0FBQ3lFLE1BQUosR0FBYSxVQUFTOUosT0FBVCxFQUFrQjtBQUMzQixXQUFPeUYsTUFBTSxDQUFDcUUsTUFBUCxDQUFjOUosT0FBZCxDQUFQO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBcUYsS0FBRyxDQUFDZ0osY0FBSixHQUFxQixVQUFTN0MsSUFBVCxFQUFlO0FBQ2hDLFdBQU8vRixNQUFNLENBQUM0SSxjQUFQLENBQXNCN0MsSUFBdEIsQ0FBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQW5HLEtBQUcsQ0FBQ3dKLFlBQUosR0FBbUIsVUFBU3JELElBQVQsRUFBZTtBQUM5QixXQUFPL0YsTUFBTSxDQUFDb0osWUFBUCxDQUFvQnJELElBQXBCLENBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0FuRyxLQUFHLENBQUM2RSxjQUFKLEdBQXFCLFVBQVN6TCxFQUFULEVBQWE7QUFDOUIsV0FBT2dILE1BQU0sQ0FBQ3lFLGNBQVAsQ0FBc0J6TCxFQUF0QixDQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQTRHLEtBQUcsQ0FBQzJKLFlBQUosR0FBbUIsVUFBU3hELElBQVQsRUFBZTtBQUM5Qi9GLFVBQU0sQ0FBQ3NHLG1CQUFQLENBQTJCUCxJQUEzQixFQUFpQyxJQUFqQztBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUFuRyxLQUFHLENBQUM0SixhQUFKLEdBQW9CLFlBQVc7QUFDM0J4SixVQUFNLENBQUN5RyxvQkFBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUE3RyxLQUFHLENBQUN1SSxrQkFBSixHQUF5QixVQUFTL0IsSUFBVCxFQUFlO0FBQ3BDcEcsVUFBTSxDQUFDbUksa0JBQVAsQ0FBMEIvQixJQUExQjtBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUF4RyxLQUFHLENBQUNrRyxtQkFBSixHQUEwQixZQUFXO0FBQ2pDLFdBQU85RixNQUFNLENBQUM4RixtQkFBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBbEcsS0FBRyxDQUFDNUYsRUFBSixHQUFTLFVBQVNtRixJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzdCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLENBQVA7QUFDSCxHQUZEOztBQUlBN0IsS0FBRyxDQUFDdUQsR0FBSixHQUFVLFVBQVNoRSxJQUFULEVBQWU7QUFDckIsV0FBT2EsTUFBTSxDQUFDcUosV0FBUCxDQUFtQmxLLElBQW5CLENBQVA7QUFDSCxHQUZEOztBQUlBUyxLQUFHLENBQUMyQixHQUFKLEdBQVUsVUFBU3BDLElBQVQsRUFBZXNDLE9BQWYsRUFBd0I7QUFDOUIsV0FBT3pCLE1BQU0sQ0FBQ1csUUFBUCxDQUFnQnhCLElBQWhCLEVBQXNCc0MsT0FBdEIsRUFBK0IsSUFBL0IsQ0FBUDtBQUNILEdBRkQsQ0F6eEJzQyxDQTZ4QnRDO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQXpCLFFBQU0sQ0FBQ0MsU0FBUCxDQUFpQjRCLEtBQWpCLENBQXVCakMsR0FBdkIsRUFBNEIsQ0FBQ3JGLE9BQUQsQ0FBNUIsRUFseUJzQyxDQW95QnRDOztBQUNBSyxRQUFNLENBQUM2TyxnQkFBUCxDQUF3QixZQUFXO0FBQy9CLFFBQUluTixJQUFKLEVBQVU7QUFDTnNELFNBQUcsQ0FBQzBFLE1BQUo7QUFDSDtBQUNKLEdBSkQsRUFyeUJzQyxDQTJ5QnRDOztBQUNBaEksTUFBSSxHQUFHLElBQVAsQ0E1eUJzQyxDQTh5QnRDOztBQUNBLFNBQU9zRCxHQUFQO0FBQ0gsQ0FoekJELEMsQ0FrekJBOzs7QUFDQSxJQUFJLFNBQWlDLE9BQU9OLE1BQU0sQ0FBQ0MsT0FBZCxLQUEwQixXQUEvRCxFQUE0RTtBQUN4RUQsUUFBTSxDQUFDQyxPQUFQLEdBQWlCZ0UsTUFBakI7QUFDSCxDLENBRUQ7OztBQUNBakcsUUFBUSxDQUFDNEYsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUMsVUFBVXRILENBQVYsRUFBYTtBQUM1QyxNQUFJa0UsSUFBSSxHQUFHbEYsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLE1BQVgsQ0FBWDtBQUNBLE1BQUlvSixLQUFKOztBQUNBLE1BQUtBLEtBQUssR0FBRzlHLElBQUksQ0FBQzZHLGdCQUFMLENBQXNCLHlIQUF0QixDQUFiLEVBQWdLO0FBQzVKLFNBQUssSUFBSXRGLENBQUMsR0FBRyxDQUFSLEVBQVd3RSxHQUFHLEdBQUdlLEtBQUssQ0FBQ3ZLLE1BQTVCLEVBQW9DZ0YsQ0FBQyxHQUFHd0UsR0FBeEMsRUFBNkN4RSxDQUFDLEVBQTlDLEVBQWtEO0FBQzlDLFVBQUl4QixPQUFPLEdBQUcrRyxLQUFLLENBQUN2RixDQUFELENBQUwsQ0FBU2pHLE9BQVQsQ0FBaUIsWUFBakIsRUFBK0JzTyxVQUE3Qzs7QUFFQSxVQUFLN0osT0FBTCxFQUFlO0FBQ1gsWUFBSUQsR0FBRyxHQUFHaEYsTUFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQnJDLEdBQXJCLENBQXlCLE1BQXpCLENBQVY7O0FBRUEsWUFBSyxDQUFDb0MsR0FBTixFQUFZO0FBQ1I7QUFDSDs7QUFFRCxZQUFLLENBQUNBLEdBQUQsSUFBUUEsR0FBRyxDQUFDNkUsY0FBSixPQUF5QixVQUF0QyxFQUFtRDtBQUMvQztBQUNIOztBQUVELFlBQUs3SSxDQUFDLENBQUNDLE1BQUYsS0FBYWdFLE9BQWIsSUFBd0JBLE9BQU8sQ0FBQ2tJLFFBQVIsQ0FBaUJuTSxDQUFDLENBQUNDLE1BQW5CLE1BQStCLEtBQTVELEVBQW9FO0FBQ2hFK0QsYUFBRyxDQUFDNEosYUFBSjtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0osQ0F4QkQsRTs7Ozs7Ozs7Ozs7O0FDenpCYTs7QUFDYixJQUFJRyxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFTaEssU0FBVCxFQUFvQnBGLE9BQXBCLEVBQTZCO0FBQzNDO0FBQ0EsTUFBSXFGLEdBQUcsR0FBRyxJQUFWO0FBQ0EsTUFBSXRELElBQUksR0FBRyxLQUFYLENBSDJDLENBSzNDOztBQUNBLE1BQUl1RCxPQUFPLEdBQUdqRixNQUFNLENBQUM0QyxHQUFQLENBQVdtQyxTQUFYLENBQWQ7QUFDQSxNQUFJRyxJQUFJLEdBQUdsRixNQUFNLENBQUM0QyxHQUFQLENBQVcsTUFBWCxDQUFYOztBQUVBLE1BQUksQ0FBQ3FDLE9BQUwsRUFBYztBQUNWO0FBQ0gsR0FYMEMsQ0FhM0M7OztBQUNBLE1BQUlFLGNBQWMsR0FBRyxFQUFyQixDQWQyQyxDQWdCM0M7QUFDQTtBQUNBOztBQUVBLE1BQUlDLE1BQU0sR0FBRztBQUNUQyxhQUFTLEVBQUUsbUJBQVMxRixPQUFULEVBQWtCO0FBQ3pCLFVBQUlLLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJLLEdBQXJCLENBQXlCLFdBQXpCLENBQUosRUFBMkM7QUFDdkNOLFdBQUcsR0FBR2hGLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJyQyxHQUFyQixDQUF5QixXQUF6QixDQUFOO0FBQ0gsT0FGRCxNQUVPO0FBQ0g7QUFDQXdDLGNBQU0sQ0FBQzFELElBQVAsQ0FBWS9CLE9BQVosRUFGRyxDQUlIOztBQUNBeUYsY0FBTSxDQUFDRyxLQUFQO0FBRUF2RixjQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCTyxHQUFyQixDQUF5QixXQUF6QixFQUFzQ1IsR0FBdEM7QUFDSDs7QUFFRCxhQUFPQSxHQUFQO0FBQ0gsS0FmUTtBQWlCVHRELFFBQUksRUFBRSxjQUFTL0IsT0FBVCxFQUFrQjtBQUNwQnFGLFNBQUcsQ0FBQ1MsTUFBSixHQUFhLEVBQWIsQ0FEb0IsQ0FHcEI7O0FBQ0FULFNBQUcsQ0FBQ3JGLE9BQUosR0FBY0ssTUFBTSxDQUFDOEYsVUFBUCxDQUFrQixFQUFsQixFQUFzQlgsY0FBdEIsRUFBc0N4RixPQUF0QyxDQUFkO0FBQ0FxRixTQUFHLENBQUNnSyxPQUFKO0FBRUFoSyxTQUFHLENBQUNpSyxTQUFKLEdBQWdCakssR0FBRyxDQUFDckYsT0FBSixDQUFZdVAsU0FBNUI7QUFDQWxLLFNBQUcsQ0FBQ21LLFVBQUosR0FBaUJuSyxHQUFHLENBQUNpSyxTQUFKLEdBQWdCLE1BQWpDO0FBQ0FqSyxTQUFHLENBQUNvSyxZQUFKLEdBQW1CcEssR0FBRyxDQUFDaUssU0FBSixHQUFnQixVQUFuQztBQUVBakssU0FBRyxDQUFDOUMsS0FBSixHQUFZbEMsTUFBTSxDQUFDNEwsUUFBUCxDQUFnQjNHLE9BQWhCLEVBQXlCRCxHQUFHLENBQUNtSyxVQUE3QixJQUEyQyxPQUEzQyxHQUFxRCxRQUFqRTtBQUNILEtBN0JRO0FBK0JUNUosU0FBSyxFQUFFLGlCQUFXO0FBQ2Q7QUFDQSxVQUFJUCxHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFoQixFQUEwQjtBQUN0QixZQUFJLE9BQU9ySyxHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFuQixLQUFnQyxRQUFwQyxFQUE4QztBQUMxQ3JQLGdCQUFNLENBQUMrRixRQUFQLENBQWlCZixHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUE3QixFQUF1QyxPQUF2QyxFQUFnRCxVQUFTck8sQ0FBVCxFQUFZO0FBQ3hEQSxhQUFDLENBQUNnRixjQUFGO0FBQ0FaLGtCQUFNLENBQUNrSyxNQUFQO0FBQ0gsV0FIRDtBQUlILFNBTEQsTUFLTyxJQUFJdEssR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBWixJQUF3QnJLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTBQLFFBQVosQ0FBcUIsQ0FBckIsQ0FBNUIsRUFBcUQ7QUFDeEQsY0FBSXJLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTBQLFFBQVosQ0FBcUIsQ0FBckIsRUFBd0JwTyxNQUE1QixFQUFvQztBQUNoQyxpQkFBSyxJQUFJd0YsQ0FBVCxJQUFjekIsR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBMUIsRUFBb0M7QUFDaENyUCxvQkFBTSxDQUFDK0YsUUFBUCxDQUFpQmYsR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBWixDQUFxQjVJLENBQXJCLEVBQXdCeEYsTUFBekMsRUFBaUQsT0FBakQsRUFBMEQsVUFBU0QsQ0FBVCxFQUFZO0FBQ2xFQSxpQkFBQyxDQUFDZ0YsY0FBRjtBQUNBWixzQkFBTSxDQUFDa0ssTUFBUDtBQUNILGVBSEQ7QUFJSDtBQUNKLFdBUEQsTUFPTztBQUNILGlCQUFLLElBQUk3SSxDQUFULElBQWN6QixHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUExQixFQUFvQztBQUNoQ3JQLG9CQUFNLENBQUMrRixRQUFQLENBQWlCZixHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFaLENBQXFCNUksQ0FBckIsQ0FBakIsRUFBMEMsT0FBMUMsRUFBbUQsVUFBU3pGLENBQVQsRUFBWTtBQUMzREEsaUJBQUMsQ0FBQ2dGLGNBQUY7QUFDQVosc0JBQU0sQ0FBQ2tLLE1BQVA7QUFDSCxlQUhEO0FBSUg7QUFDSjtBQUVKLFNBakJNLE1BaUJBLElBQUl0SyxHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFaLElBQXdCckssR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBWixDQUFxQnBPLE1BQWpELEVBQXlEO0FBQzVEakIsZ0JBQU0sQ0FBQytGLFFBQVAsQ0FBaUJmLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTBQLFFBQVosQ0FBcUJwTyxNQUF0QyxFQUE4QyxPQUE5QyxFQUF1RCxVQUFTRCxDQUFULEVBQVk7QUFDL0RBLGFBQUMsQ0FBQ2dGLGNBQUY7QUFDQVosa0JBQU0sQ0FBQ2tLLE1BQVA7QUFDSCxXQUhEO0FBSUg7QUFDSixPQS9CYSxDQWlDZDs7O0FBQ0EsVUFBSUMsT0FBTyxHQUFHdlAsTUFBTSxDQUFDNEMsR0FBUCxDQUFXb0MsR0FBRyxDQUFDckYsT0FBSixDQUFZNFAsT0FBdkIsQ0FBZDs7QUFDQSxVQUFJQSxPQUFKLEVBQWE7QUFDVHZQLGNBQU0sQ0FBQytGLFFBQVAsQ0FBZ0J3SixPQUFoQixFQUF5QixPQUF6QixFQUFrQyxVQUFTdk8sQ0FBVCxFQUFZO0FBQzFDQSxXQUFDLENBQUNnRixjQUFGO0FBQ0FaLGdCQUFNLENBQUMzRSxJQUFQO0FBQ0gsU0FIRDtBQUlILE9BeENhLENBMENkOzs7QUFDQVQsWUFBTSxDQUFDNk8sZ0JBQVAsQ0FBd0IsWUFBVztBQUMvQixZQUFJVyxRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVc0RCxPQUFYLEVBQW9CLE1BQXBCLENBQUQsQ0FBUixJQUF5QyxDQUF6QyxJQUE4Q3VLLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBVzRELE9BQVgsRUFBb0IsT0FBcEIsS0FBZ0MsQ0FBakMsQ0FBdEQsSUFBNkZqRixNQUFNLENBQUNxQixHQUFQLENBQVc0RCxPQUFYLEVBQW9CLFVBQXBCLEtBQW1DLE9BQXBJLEVBQTZJO0FBQ3pJakYsZ0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzRELE9BQVgsRUFBb0IsU0FBcEIsRUFBK0IsR0FBL0I7QUFDSDtBQUNKLE9BSkQ7QUFLSCxLQS9FUTtBQWlGVHdLLFdBQU8sRUFBRSxpQkFBU3hPLE1BQVQsRUFBaUI7QUFDdEIsYUFBUStELEdBQUcsQ0FBQzlDLEtBQUosSUFBYSxPQUFiLEdBQXVCLElBQXZCLEdBQThCLEtBQXRDO0FBQ0gsS0FuRlE7QUFxRlRvTixVQUFNLEVBQUUsa0JBQVc7QUFBQztBQUNoQmxLLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsUUFBcEI7O0FBRUEsVUFBSXhCLEdBQUcsQ0FBQzlDLEtBQUosSUFBYSxPQUFqQixFQUEwQjtBQUN0QmtELGNBQU0sQ0FBQzNFLElBQVAsQ0FBWSxJQUFaO0FBQ0gsT0FGRCxNQUVPO0FBQ0gyRSxjQUFNLENBQUMrQixJQUFQLENBQVksSUFBWjtBQUNIO0FBQ0osS0E3RlE7QUErRlRBLFFBQUksRUFBRSxjQUFTbEcsTUFBVCxFQUFpQjtBQUNuQixVQUFJK0QsR0FBRyxDQUFDOUMsS0FBSixJQUFhLE9BQWpCLEVBQTBCO0FBQ3RCO0FBQ0g7O0FBRURrRCxZQUFNLENBQUNvQixZQUFQLENBQW9CLFlBQXBCO0FBRUFwQixZQUFNLENBQUNzSyxZQUFQLENBQW9Cek8sTUFBcEIsRUFBNEIsTUFBNUIsRUFQbUIsQ0FTbkI7O0FBQ0FqQixZQUFNLENBQUNSLFFBQVAsQ0FBZ0IwRixJQUFoQixFQUFzQkYsR0FBRyxDQUFDbUssVUFBMUI7QUFDQW5QLFlBQU0sQ0FBQ1IsUUFBUCxDQUFnQnlGLE9BQWhCLEVBQXlCRCxHQUFHLENBQUNtSyxVQUE3QjtBQUNBblAsWUFBTSxDQUFDcUIsR0FBUCxDQUFXNEQsT0FBWCxFQUFvQixTQUFwQixFQUErQixHQUEvQjtBQUVBRCxTQUFHLENBQUM5QyxLQUFKLEdBQVksT0FBWjs7QUFFQSxVQUFJOEMsR0FBRyxDQUFDckYsT0FBSixDQUFZcVAsT0FBaEIsRUFBeUI7QUFDckJoSyxXQUFHLENBQUNnSyxPQUFKLEdBQWNoUCxNQUFNLENBQUMyUCxXQUFQLENBQW1Cak4sUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQW5CLEVBQW1Ec0MsT0FBbkQsQ0FBZDtBQUNBakYsY0FBTSxDQUFDUixRQUFQLENBQWdCd0YsR0FBRyxDQUFDZ0ssT0FBcEIsRUFBNkJoSyxHQUFHLENBQUNvSyxZQUFqQztBQUNBcFAsY0FBTSxDQUFDK0YsUUFBUCxDQUFnQmYsR0FBRyxDQUFDZ0ssT0FBcEIsRUFBNkIsT0FBN0IsRUFBc0MsVUFBU2hPLENBQVQsRUFBWTtBQUM5Q0EsV0FBQyxDQUFDc00sZUFBRjtBQUNBdE0sV0FBQyxDQUFDZ0YsY0FBRjtBQUNBWixnQkFBTSxDQUFDM0UsSUFBUCxDQUFZUSxNQUFaO0FBQ0gsU0FKRDtBQUtIOztBQUVEbUUsWUFBTSxDQUFDb0IsWUFBUCxDQUFvQixXQUFwQjtBQUNILEtBMUhRO0FBNEhUL0YsUUFBSSxFQUFFLGNBQVNRLE1BQVQsRUFBaUI7QUFDbkIsVUFBSStELEdBQUcsQ0FBQzlDLEtBQUosSUFBYSxRQUFqQixFQUEyQjtBQUN2QjtBQUNIOztBQUVEa0QsWUFBTSxDQUFDb0IsWUFBUCxDQUFvQixZQUFwQjtBQUVBcEIsWUFBTSxDQUFDc0ssWUFBUCxDQUFvQnpPLE1BQXBCLEVBQTRCLE1BQTVCO0FBRUFqQixZQUFNLENBQUNvRSxXQUFQLENBQW1CYyxJQUFuQixFQUF5QkYsR0FBRyxDQUFDbUssVUFBN0I7QUFDQW5QLFlBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJhLE9BQW5CLEVBQTRCRCxHQUFHLENBQUNtSyxVQUFoQztBQUVBbkssU0FBRyxDQUFDOUMsS0FBSixHQUFZLFFBQVo7O0FBRUEsVUFBSThDLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWXFQLE9BQVosSUFBdUJoSyxHQUFHLENBQUNnSyxPQUEvQixFQUF3QztBQUNwQ2hQLGNBQU0sQ0FBQ2dELE1BQVAsQ0FBY2dDLEdBQUcsQ0FBQ2dLLE9BQWxCO0FBQ0g7O0FBRURoUCxZQUFNLENBQUM0UCxhQUFQLENBQXFCM0ssT0FBckIsRUFBOEIsWUFBVztBQUNyQ2pGLGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzRELE9BQVgsRUFBb0IsU0FBcEIsRUFBK0IsR0FBL0I7QUFDSCxPQUZEO0FBSUFHLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsV0FBcEI7QUFDSCxLQW5KUTtBQXFKVGtKLGdCQUFZLEVBQUUsc0JBQVN6TyxNQUFULEVBQWlCNEosSUFBakIsRUFBdUI7QUFDakM7QUFDQSxVQUFJZ0YsRUFBRSxHQUFHN1AsTUFBTSxDQUFDbUUsSUFBUCxDQUFZbEQsTUFBWixFQUFvQixJQUFwQixDQUFUO0FBQ0EsVUFBSW9PLFFBQUo7O0FBRUEsVUFBSXJLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTBQLFFBQVosSUFBd0JySyxHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFaLENBQXFCLENBQXJCLENBQXhCLElBQW1EckssR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBWixDQUFxQixDQUFyQixFQUF3QnBPLE1BQS9FLEVBQXVGO0FBQ25GLGFBQUssSUFBSXdGLENBQVQsSUFBY3pCLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTBQLFFBQTFCLEVBQW9DO0FBQ2hDLGNBQUlySyxHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFaLENBQXFCNUksQ0FBckIsRUFBd0J4RixNQUF4QixLQUFtQzRPLEVBQXZDLEVBQTJDO0FBQ3ZDUixvQkFBUSxHQUFHckssR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBWixDQUFxQjVJLENBQXJCLENBQVg7QUFDSDtBQUNKO0FBQ0osT0FORCxNQU1PLElBQUl6QixHQUFHLENBQUNyRixPQUFKLENBQVkwUCxRQUFaLElBQXdCckssR0FBRyxDQUFDckYsT0FBSixDQUFZMFAsUUFBWixDQUFxQnBPLE1BQWpELEVBQXlEO0FBQzVEb08sZ0JBQVEsR0FBR3JLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTBQLFFBQXZCO0FBQ0g7O0FBRUQsVUFBSUEsUUFBSixFQUFjO0FBQ1YsWUFBSWpSLEVBQUUsR0FBRzRCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV3lNLFFBQVEsQ0FBQ3BPLE1BQXBCLENBQVQ7O0FBRUEsWUFBSTRKLElBQUksS0FBSyxNQUFiLEVBQXFCO0FBQ2pCN0ssZ0JBQU0sQ0FBQ1IsUUFBUCxDQUFnQnBCLEVBQWhCLEVBQW9CaVIsUUFBUSxDQUFDbk4sS0FBN0I7QUFDSDs7QUFFRCxZQUFJMkksSUFBSSxLQUFLLE1BQWIsRUFBcUI7QUFDakI3SyxnQkFBTSxDQUFDb0UsV0FBUCxDQUFtQmhHLEVBQW5CLEVBQXVCaVIsUUFBUSxDQUFDbk4sS0FBaEM7QUFDSDtBQUNKO0FBQ0osS0EvS1E7QUFpTFRzRSxnQkFBWSxFQUFFLHNCQUFTakMsSUFBVCxFQUFlbUUsSUFBZixFQUFxQjtBQUMvQixXQUFLLElBQUlqQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHekIsR0FBRyxDQUFDUyxNQUFKLENBQVdoRSxNQUEvQixFQUF1Q2dGLENBQUMsRUFBeEMsRUFBNEM7QUFDeEMsWUFBSUMsS0FBSyxHQUFHMUIsR0FBRyxDQUFDUyxNQUFKLENBQVdnQixDQUFYLENBQVo7O0FBQ0EsWUFBSUMsS0FBSyxDQUFDbkMsSUFBTixJQUFjQSxJQUFsQixFQUF3QjtBQUNwQixjQUFJbUMsS0FBSyxDQUFDQyxHQUFOLElBQWEsSUFBakIsRUFBdUI7QUFDbkIsZ0JBQUlELEtBQUssQ0FBQ0UsS0FBTixJQUFlLEtBQW5CLEVBQTBCO0FBQ3RCNUIsaUJBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxFQUFjRyxLQUFkLEdBQXNCLElBQXRCO0FBQ0EscUJBQU9GLEtBQUssQ0FBQ0csT0FBTixDQUFjQyxJQUFkLENBQW1CLElBQW5CLEVBQXlCOUIsR0FBekIsRUFBOEIwRCxJQUE5QixDQUFQO0FBQ0g7QUFDSixXQUxELE1BS087QUFDSCxtQkFBT2hDLEtBQUssQ0FBQ0csT0FBTixDQUFjQyxJQUFkLENBQW1CLElBQW5CLEVBQXlCOUIsR0FBekIsRUFBOEIwRCxJQUE5QixDQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0EvTFE7QUFpTVQzQyxZQUFRLEVBQUUsa0JBQVN4QixJQUFULEVBQWVzQyxPQUFmLEVBQXdCRixHQUF4QixFQUE2QjtBQUNuQzNCLFNBQUcsQ0FBQ1MsTUFBSixDQUFXc0IsSUFBWCxDQUFnQjtBQUNaeEMsWUFBSSxFQUFFQSxJQURNO0FBRVpzQyxlQUFPLEVBQUVBLE9BRkc7QUFHWkYsV0FBRyxFQUFFQSxHQUhPO0FBSVpDLGFBQUssRUFBRTtBQUpLLE9BQWhCO0FBTUg7QUF4TVEsR0FBYixDQXBCMkMsQ0ErTjNDO0FBQ0E7QUFDQTs7QUFDQTVCLEtBQUcsQ0FBQ2dDLFdBQUosR0FBa0IsVUFBU3JILE9BQVQsRUFBa0I7QUFDaEN3RixrQkFBYyxHQUFHeEYsT0FBakI7QUFDSCxHQUZEOztBQUlBcUYsS0FBRyxDQUFDeUssT0FBSixHQUFjLFlBQVc7QUFDckIsV0FBT3JLLE1BQU0sQ0FBQ3FLLE9BQVAsRUFBUDtBQUNILEdBRkQ7O0FBSUF6SyxLQUFHLENBQUN2RSxJQUFKLEdBQVcsWUFBVztBQUNsQixXQUFPMkUsTUFBTSxDQUFDM0UsSUFBUCxFQUFQO0FBQ0gsR0FGRDs7QUFJQXVFLEtBQUcsQ0FBQ21DLElBQUosR0FBVyxZQUFXO0FBQ2xCLFdBQU8vQixNQUFNLENBQUMrQixJQUFQLEVBQVA7QUFDSCxHQUZEOztBQUlBbkMsS0FBRyxDQUFDNUYsRUFBSixHQUFTLFVBQVNtRixJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzdCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLENBQVA7QUFDSCxHQUZEOztBQUlBN0IsS0FBRyxDQUFDMkIsR0FBSixHQUFVLFVBQVNwQyxJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzlCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLEVBQStCLElBQS9CLENBQVA7QUFDSCxHQUZELENBdFAyQyxDQTBQM0M7QUFDQTtBQUNBO0FBRUE7OztBQUNBekIsUUFBTSxDQUFDQyxTQUFQLENBQWlCNEIsS0FBakIsQ0FBdUJqQyxHQUF2QixFQUE0QixDQUFDckYsT0FBRCxDQUE1QixFQS9QMkMsQ0FpUTNDOztBQUNBK0IsTUFBSSxHQUFHLElBQVAsQ0FsUTJDLENBb1EzQzs7QUFDQSxTQUFPc0QsR0FBUDtBQUNILENBdFFELEMsQ0F3UUE7OztBQUNBLElBQUksU0FBaUMsT0FBT04sTUFBTSxDQUFDQyxPQUFkLEtBQTBCLFdBQS9ELEVBQTRFO0FBQ3hFRCxRQUFNLENBQUNDLE9BQVAsR0FBaUJvSyxXQUFqQjtBQUNILEM7Ozs7Ozs7Ozs7OztDQzNRRDs7QUFDQSxJQUFJbFAsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBU2tGLFNBQVQsRUFBb0JwRixPQUFwQixFQUE2QjtBQUN6QztBQUNBLE1BQUlxRixHQUFHLEdBQUcsSUFBVjtBQUNBLE1BQUl0RCxJQUFJLEdBQUcsS0FBWCxDQUh5QyxDQUt6Qzs7QUFDQSxNQUFJdUQsT0FBTyxHQUFHakYsTUFBTSxDQUFDNEMsR0FBUCxDQUFXbUMsU0FBWCxDQUFkO0FBQ0EsTUFBSUcsSUFBSSxHQUFHbEYsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLE1BQVgsQ0FBWDs7QUFFQSxNQUFJLENBQUNxQyxPQUFMLEVBQWM7QUFDVjtBQUNILEdBWHdDLENBYXpDOzs7QUFDQSxNQUFJRSxjQUFjLEdBQUc7QUFDakIySyxtQkFBZSxFQUFFLEdBREE7QUFFakJDLFlBQVEsRUFBRSxJQUZPO0FBR2pCQyxTQUFLLEVBQUU7QUFDSFYsWUFBTSxFQUFFO0FBQ0pXLGdCQUFRLEVBQUUsVUFETjtBQUVKQyxjQUFNLEVBQUU7QUFGSixPQURMO0FBS0h4RyxZQUFNLEVBQUUsUUFMTDtBQU1IMUcsWUFBTSxFQUFFLFFBTkw7QUFPSG1OLGdCQUFVLEVBQUU7QUFDUi9RLFVBQUUsRUFBRSxZQURJO0FBRVJtSixXQUFHLEVBQUU7QUFGRztBQVBULEtBSFU7QUFlakI1SCxVQUFNLEVBQUU7QUFDSmdILFlBQU0sRUFBRSxHQURKO0FBRUpsRSxZQUFNLEVBQUU7QUFGSjtBQWZTLEdBQXJCLENBZHlDLENBbUN6QztBQUNBO0FBQ0E7O0FBRUEsTUFBSTJCLE1BQU0sR0FBRztBQUNUOzs7QUFJQUMsYUFBUyxFQUFFLG1CQUFTMUYsT0FBVCxFQUFrQjtBQUN6QixVQUFJSyxNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCSyxHQUFyQixDQUF5QixTQUF6QixDQUFKLEVBQXlDO0FBQ3JDTixXQUFHLEdBQUdoRixNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCckMsR0FBckIsQ0FBeUIsU0FBekIsQ0FBTjtBQUNILE9BRkQsTUFFTztBQUNIO0FBQ0F3QyxjQUFNLENBQUMxRCxJQUFQLENBQVkvQixPQUFaLEVBRkcsQ0FJSDs7QUFDQXlGLGNBQU0sQ0FBQ0csS0FBUDtBQUVBdkYsY0FBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQk8sR0FBckIsQ0FBeUIsU0FBekIsRUFBb0NSLEdBQXBDO0FBQ0g7O0FBRUQsYUFBT0EsR0FBUDtBQUNILEtBbkJROztBQXFCVDs7O0FBR0F0RCxRQUFJLEVBQUUsY0FBUy9CLE9BQVQsRUFBa0I7QUFDcEJxRixTQUFHLENBQUNDLE9BQUosR0FBY0EsT0FBZDtBQUNBRCxTQUFHLENBQUNTLE1BQUosR0FBYSxFQUFiLENBRm9CLENBSXBCOztBQUNBVCxTQUFHLENBQUNyRixPQUFKLEdBQWNLLE1BQU0sQ0FBQzhGLFVBQVAsQ0FBa0IsRUFBbEIsRUFBc0JYLGNBQXRCLEVBQXNDeEYsT0FBdEMsQ0FBZDtBQUNBcUYsU0FBRyxDQUFDb0wsSUFBSixHQUFXcFEsTUFBTSxDQUFDa00sS0FBUCxDQUFhakgsT0FBYixFQUFzQixnQkFBdEIsQ0FBWDtBQUNBRCxTQUFHLENBQUNxTCxJQUFKLEdBQVdyUSxNQUFNLENBQUNrTSxLQUFQLENBQWFqSCxPQUFiLEVBQXNCLGdCQUF0QixDQUFYOztBQUVBLFVBQUlqRixNQUFNLENBQUNrTSxLQUFQLENBQWFqSCxPQUFiLEVBQXNCLGdCQUF0QixDQUFKLEVBQTZDO0FBQ3pDRCxXQUFHLENBQUNFLElBQUosR0FBV2xGLE1BQU0sQ0FBQ2tNLEtBQVAsQ0FBYWpILE9BQWIsRUFBc0IsZ0JBQXRCLENBQVg7QUFDSCxPQUZELE1BRU8sSUFBSWpGLE1BQU0sQ0FBQ2tNLEtBQVAsQ0FBYWpILE9BQWIsRUFBc0IsT0FBdEIsQ0FBSixFQUFvQztBQUN2Q0QsV0FBRyxDQUFDRSxJQUFKLEdBQVdsRixNQUFNLENBQUNrTSxLQUFQLENBQWFqSCxPQUFiLEVBQXNCLE9BQXRCLENBQVg7QUFDSDtBQUNKLEtBdENROztBQXdDVDs7O0FBR0FNLFNBQUssRUFBRSxpQkFBVztBQUNkO0FBQ0EsVUFBSXZDLE1BQU0sR0FBR2hELE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLDhCQUF0QixDQUFiOztBQUNBLFVBQUlwTixNQUFKLEVBQVk7QUFDUmhELGNBQU0sQ0FBQytGLFFBQVAsQ0FBZ0IvQyxNQUFoQixFQUF3QixPQUF4QixFQUFpQyxVQUFTaEMsQ0FBVCxFQUFZO0FBQ3pDQSxXQUFDLENBQUNnRixjQUFGO0FBQ0FaLGdCQUFNLENBQUNwQyxNQUFQO0FBQ0gsU0FIRDtBQUlILE9BUmEsQ0FVZDs7O0FBQ0EsVUFBSTBHLE1BQU0sR0FBRzFKLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLDhCQUF0QixDQUFiOztBQUNBLFVBQUkxRyxNQUFKLEVBQVk7QUFDUjFKLGNBQU0sQ0FBQytGLFFBQVAsQ0FBZ0IyRCxNQUFoQixFQUF3QixPQUF4QixFQUFpQyxVQUFTMUksQ0FBVCxFQUFZO0FBQ3pDQSxXQUFDLENBQUNnRixjQUFGO0FBQ0FaLGdCQUFNLENBQUNzRSxNQUFQO0FBQ0gsU0FIRDtBQUlILE9BakJhLENBbUJkOzs7QUFDQSxVQUFJNEYsTUFBTSxHQUFHdFAsTUFBTSxDQUFDa0IsSUFBUCxDQUFZOEQsR0FBRyxDQUFDb0wsSUFBaEIsRUFBc0IsOEJBQXRCLENBQWI7O0FBQ0EsVUFBSWQsTUFBSixFQUFZO0FBQ1J0UCxjQUFNLENBQUMrRixRQUFQLENBQWdCdUosTUFBaEIsRUFBd0IsT0FBeEIsRUFBaUMsVUFBU3RPLENBQVQsRUFBWTtBQUN6Q0EsV0FBQyxDQUFDZ0YsY0FBRjtBQUNBWixnQkFBTSxDQUFDa0ssTUFBUDtBQUNILFNBSEQ7QUFJSCxPQTFCYSxDQTRCZDs7O0FBQ0EsVUFBSWEsVUFBVSxHQUFHblEsTUFBTSxDQUFDa0IsSUFBUCxDQUFZOEQsR0FBRyxDQUFDb0wsSUFBaEIsRUFBc0Isa0NBQXRCLENBQWpCOztBQUNBLFVBQUlELFVBQUosRUFBZ0I7QUFDWm5RLGNBQU0sQ0FBQytGLFFBQVAsQ0FBZ0JvSyxVQUFoQixFQUE0QixPQUE1QixFQUFxQyxVQUFTblAsQ0FBVCxFQUFZO0FBQzdDQSxXQUFDLENBQUNnRixjQUFGO0FBQ0FaLGdCQUFNLENBQUMrSyxVQUFQO0FBQ0gsU0FIRDtBQUlIOztBQUVEL0ssWUFBTSxDQUFDa0wsYUFBUDtBQUNILEtBakZROztBQW1GVDs7O0FBR0E1UCxjQUFVLEVBQUUsc0JBQVc7QUFDbkIsVUFBSXFILGFBQWEsR0FBRyxDQUFwQjtBQUNBLFVBQUlKLE1BQU0sR0FBRzNDLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdCLE1BQVosQ0FBbUJnSCxNQUFoQzs7QUFFQSxVQUFJLENBQUMzQyxHQUFHLENBQUNvTCxJQUFULEVBQWU7QUFDWDtBQUNIOztBQUVKL0gsWUFBTSxDQUFDQyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQ2xELE1BQU0sQ0FBQ21MLGNBQXpDO0FBQ0EsS0EvRlE7O0FBaUdaOzs7QUFHQUEsa0JBQWMsRUFBRSx3QkFBU3ZQLENBQVQsRUFBWTtBQUMzQixVQUFJMkcsTUFBTSxHQUFHM0MsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0IsTUFBWixDQUFtQmdILE1BQWhDO0FBRUEsVUFBRzZJLEtBQUssQ0FBQzdJLE1BQUQsQ0FBUixFQUFrQjtBQUVsQixVQUFJYSxFQUFFLEdBQUd4SSxNQUFNLENBQUN5SSxZQUFQLEVBQVQ7O0FBRUEsVUFBSUQsRUFBRSxJQUFJYixNQUFOLElBQWdCM0gsTUFBTSxDQUFDNEwsUUFBUCxDQUFnQjFHLElBQWhCLEVBQXNCLGlCQUF0QixNQUE2QyxLQUFqRSxFQUF3RTtBQUN2RUUsY0FBTSxDQUFDb0IsWUFBUCxDQUFvQixVQUFwQjtBQUVBeEcsY0FBTSxDQUFDUixRQUFQLENBQWdCMEYsSUFBaEIsRUFBc0IsaUJBQXRCO0FBQ0FsRixjQUFNLENBQUNSLFFBQVAsQ0FBZ0J5RixPQUFoQixFQUF5QixpQkFBekI7QUFFQUcsY0FBTSxDQUFDcUwsWUFBUDtBQUVBLE9BUkQsTUFRTyxJQUFLakksRUFBRSxHQUFDLEdBQUosSUFBWWIsTUFBWixJQUFzQjNILE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IxRyxJQUFoQixFQUFzQixpQkFBdEIsQ0FBMUIsRUFBb0U7QUFDMUU7QUFDQUUsY0FBTSxDQUFDb0IsWUFBUCxDQUFvQixXQUFwQjtBQUVBeEcsY0FBTSxDQUFDb0UsV0FBUCxDQUFtQmMsSUFBbkIsRUFBeUIsaUJBQXpCO0FBQ0FsRixjQUFNLENBQUNvRSxXQUFQLENBQW1CYSxPQUFuQixFQUE0QixpQkFBNUI7QUFFQUcsY0FBTSxDQUFDc0wsV0FBUDtBQUNBO0FBQ0QsS0E1SFc7QUE4SFRELGdCQUFZLEVBQUUsd0JBQVc7QUFDckIsVUFBSSxDQUFDekwsR0FBRyxDQUFDb0wsSUFBVCxFQUFlO0FBQ1g7QUFDSDs7QUFFRCxVQUFJbE4sR0FBSjs7QUFFQSxVQUFJbEQsTUFBTSxDQUFDNEwsUUFBUCxDQUFnQjFHLElBQWhCLEVBQXNCLGlCQUF0QixDQUFKLEVBQThDO0FBQzFDLFlBQUlGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdCLE1BQVosQ0FBbUJXLFFBQW5CLENBQTRCNEIsR0FBNUIsWUFBMkN5TixRQUEvQyxFQUF5RDtBQUNyRHpOLGFBQUcsR0FBR3NNLFFBQVEsQ0FBQ3hLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdCLE1BQVosQ0FBbUJXLFFBQW5CLENBQTRCNEIsR0FBNUIsQ0FBZ0M0RCxJQUFoQyxDQUFxQyxJQUFyQyxFQUEyQzlCLEdBQTNDLENBQUQsQ0FBZDtBQUNILFNBRkQsTUFFTztBQUNIOUIsYUFBRyxHQUFHc00sUUFBUSxDQUFDeEssR0FBRyxDQUFDckYsT0FBSixDQUFZZ0IsTUFBWixDQUFtQlcsUUFBbkIsQ0FBNEI0QixHQUE3QixDQUFkO0FBQ0g7O0FBRUQsWUFBSUMsSUFBSjs7QUFDQSxZQUFJNkIsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0IsTUFBWixDQUFtQlcsUUFBbkIsQ0FBNEI2QixJQUE1QixZQUE0Q3dOLFFBQWhELEVBQTBEO0FBQ3REeE4sY0FBSSxHQUFHcU0sUUFBUSxDQUFDeEssR0FBRyxDQUFDckYsT0FBSixDQUFZZ0IsTUFBWixDQUFtQlcsUUFBbkIsQ0FBNEI2QixJQUE1QixDQUFpQzJELElBQWpDLENBQXNDLElBQXRDLEVBQTRDOUIsR0FBNUMsQ0FBRCxDQUFmO0FBQ0gsU0FGRCxNQUVPO0FBQ0g3QixjQUFJLEdBQUdxTSxRQUFRLENBQUN4SyxHQUFHLENBQUNyRixPQUFKLENBQVlnQixNQUFaLENBQW1CVyxRQUFuQixDQUE0QjZCLElBQTdCLENBQWY7QUFDSDs7QUFFRCxZQUFJeU4sS0FBSjs7QUFDQSxZQUFJNUwsR0FBRyxDQUFDckYsT0FBSixDQUFZZ0IsTUFBWixDQUFtQlcsUUFBbkIsQ0FBNEJzUCxLQUE1QixZQUE2Q0QsUUFBakQsRUFBMkQ7QUFDdkRDLGVBQUssR0FBR3BCLFFBQVEsQ0FBQ3hLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdCLE1BQVosQ0FBbUJXLFFBQW5CLENBQTRCc1AsS0FBNUIsQ0FBa0M5SixJQUFsQyxDQUF1QyxJQUF2QyxFQUE2QzlCLEdBQTdDLENBQUQsQ0FBaEI7QUFDSCxTQUZELE1BRU87QUFDSDRMLGVBQUssR0FBR3BCLFFBQVEsQ0FBQ3hLLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWWdCLE1BQVosQ0FBbUJXLFFBQW5CLENBQTRCc1AsS0FBN0IsQ0FBaEI7QUFDSDs7QUFFRDVRLGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ29MLElBQWYsRUFBcUIsU0FBckIsRUFBZ0NwTCxHQUFHLENBQUNyRixPQUFKLENBQVlnQixNQUFaLENBQW1COEMsTUFBbkQ7QUFDQXpELGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ29MLElBQWYsRUFBcUIsS0FBckIsRUFBNEJsTixHQUFHLEdBQUcsSUFBbEM7QUFDQWxELGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ29MLElBQWYsRUFBcUIsTUFBckIsRUFBNkJqTixJQUFJLEdBQUcsSUFBcEM7QUFDQW5ELGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ29MLElBQWYsRUFBcUIsT0FBckIsRUFBOEJRLEtBQUssR0FBRyxJQUF0QztBQUNIO0FBQ0osS0EvSlE7QUFpS1RGLGVBQVcsRUFBRSx1QkFBVztBQUNwQixVQUFJLENBQUMxTCxHQUFHLENBQUNvTCxJQUFULEVBQWU7QUFDWDtBQUNIOztBQUVELFVBQUlwUSxNQUFNLENBQUM0TCxRQUFQLENBQWdCMUcsSUFBaEIsRUFBc0IsaUJBQXRCLE1BQTZDLEtBQWpELEVBQXdEO0FBQ3BEbEYsY0FBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDb0wsSUFBZixFQUFxQixTQUFyQixFQUFnQyxFQUFoQztBQUNBcFEsY0FBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDb0wsSUFBZixFQUFxQixLQUFyQixFQUE0QixFQUE1QjtBQUNBcFEsY0FBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDb0wsSUFBZixFQUFxQixNQUFyQixFQUE2QixFQUE3QjtBQUNBcFEsY0FBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDb0wsSUFBZixFQUFxQixPQUFyQixFQUE4QixFQUE5QjtBQUNIO0FBQ0osS0E1S1E7O0FBOEtUOzs7QUFHQXBOLFVBQU0sRUFBRSxrQkFBVztBQUNmLFVBQUlvQyxNQUFNLENBQUNvQixZQUFQLENBQW9CLGNBQXBCLE1BQXdDLEtBQTVDLEVBQW1EO0FBQy9DO0FBQ0g7O0FBRUQsVUFBSXhHLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IxRyxJQUFoQixFQUFzQixxQkFBdEIsS0FBZ0RsRixNQUFNLENBQUM0TCxRQUFQLENBQWdCM0csT0FBaEIsRUFBeUIscUJBQXpCLENBQXBELEVBQXFHO0FBQ2pHRyxjQUFNLENBQUMrSyxVQUFQLENBQWtCLEtBQWxCO0FBQ0g7O0FBRUQvSyxZQUFNLENBQUN5TCxjQUFQO0FBRUE3USxZQUFNLENBQUNnRCxNQUFQLENBQWNpQyxPQUFkO0FBRUFHLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsYUFBcEI7QUFDSCxLQS9MUTs7QUFpTVQ7OztBQUdBc0ssY0FBVSxFQUFFLG9CQUFTclIsSUFBVCxFQUFlO0FBQ3ZCLFVBQUlBLElBQUosRUFBVTtBQUNOdUYsV0FBRyxDQUFDRSxJQUFKLENBQVNwQyxTQUFULEdBQXFCckQsSUFBckI7QUFDSDtBQUNKLEtBeE1ROztBQTBNVDs7O0FBR0FzUixXQUFPLEVBQUUsbUJBQVc7QUFDaEIsYUFBTy9MLEdBQUcsQ0FBQ0UsSUFBWDtBQUNILEtBL01ROztBQWlOVDs7O0FBR0E4TCxXQUFPLEVBQUUsbUJBQVc7QUFDaEIsYUFBTy9MLE9BQVA7QUFDSCxLQXROUTs7QUF3TlQ7OztBQUdBcUwsaUJBQWEsRUFBRSx5QkFBVztBQUN0QixVQUFJdEwsR0FBRyxDQUFDckYsT0FBSixDQUFZb1EsUUFBaEIsRUFBMEI7QUFDdEIsWUFBSWtCLFNBQVMsR0FBR2pSLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IzRyxPQUFoQixFQUF5QixtQkFBekIsS0FBaURqRixNQUFNLENBQUM0TCxRQUFQLENBQWdCM0csT0FBaEIsRUFBeUIsb0JBQXpCLENBQWpFO0FBQ0EsWUFBSWlNLFlBQVksR0FBR2xSLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IxRyxJQUFoQixFQUFzQixxQkFBdEIsS0FBZ0RsRixNQUFNLENBQUM0TCxRQUFQLENBQWdCM0csT0FBaEIsRUFBeUIscUJBQXpCLENBQW5FLENBRnNCLENBSXRCOztBQUNBLFlBQUlqQyxNQUFNLEdBQUdoRCxNQUFNLENBQUNrQixJQUFQLENBQVk4RCxHQUFHLENBQUNvTCxJQUFoQixFQUFzQiw4QkFBdEIsQ0FBYjs7QUFDQSxZQUFJcE4sTUFBSixFQUFZO0FBQ1IsY0FBSXZFLFNBQVMsR0FBSXlTLFlBQVksR0FBRyxRQUFILEdBQWMsS0FBM0M7QUFDQSxjQUFJQyxHQUFHLEdBQUcsSUFBSUMsT0FBSixDQUFZcE8sTUFBWixFQUFvQjtBQUMxQm9MLGlCQUFLLEVBQUVwSixHQUFHLENBQUNyRixPQUFKLENBQVlxUSxLQUFaLENBQWtCaE4sTUFEQztBQUUxQnZFLHFCQUFTLEVBQUVBLFNBRmU7QUFHMUJrSixrQkFBTSxFQUFHdUosWUFBWSxHQUFHLFlBQUgsR0FBa0IsT0FIYjtBQUkxQnZTLG1CQUFPLEVBQUUsT0FKaUI7QUFLMUJDLG9CQUFRLEVBQUUsNERBQTRESCxTQUE1RCxHQUF3RTs7OztBQUx4RCxXQUFwQixDQUFWO0FBV0F1QixnQkFBTSxDQUFDMUIsSUFBUCxDQUFZMEUsTUFBWixFQUFvQndDLEdBQXBCLENBQXdCLFNBQXhCLEVBQW1DMkwsR0FBbkM7QUFDSCxTQXBCcUIsQ0FzQnRCOzs7QUFDQSxZQUFJekgsTUFBTSxHQUFHMUosTUFBTSxDQUFDa0IsSUFBUCxDQUFZOEQsR0FBRyxDQUFDb0wsSUFBaEIsRUFBc0IsOEJBQXRCLENBQWI7O0FBQ0EsWUFBSTFHLE1BQUosRUFBWTtBQUNSLGNBQUlqTCxTQUFTLEdBQUl5UyxZQUFZLEdBQUcsUUFBSCxHQUFjLEtBQTNDO0FBQ0EsY0FBSUMsR0FBRyxHQUFHLElBQUlDLE9BQUosQ0FBWTFILE1BQVosRUFBb0I7QUFDMUIwRSxpQkFBSyxFQUFFcEosR0FBRyxDQUFDckYsT0FBSixDQUFZcVEsS0FBWixDQUFrQnRHLE1BREM7QUFFMUJqTCxxQkFBUyxFQUFFQSxTQUZlO0FBRzFCa0osa0JBQU0sRUFBR3VKLFlBQVksR0FBRyxZQUFILEdBQWtCLE9BSGI7QUFJMUJ2UyxtQkFBTyxFQUFFLE9BSmlCO0FBSzFCQyxvQkFBUSxFQUFFLDREQUE0REgsU0FBNUQsR0FBd0U7Ozs7QUFMeEQsV0FBcEIsQ0FBVjtBQVdBdUIsZ0JBQU0sQ0FBQzFCLElBQVAsQ0FBWW9MLE1BQVosRUFBb0JsRSxHQUFwQixDQUF3QixTQUF4QixFQUFtQzJMLEdBQW5DO0FBQ0gsU0F0Q3FCLENBd0N0Qjs7O0FBQ0EsWUFBSTdCLE1BQU0sR0FBR3RQLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLDhCQUF0QixDQUFiOztBQUNBLFlBQUlkLE1BQUosRUFBWTtBQUNSLGNBQUk3USxTQUFTLEdBQUl5UyxZQUFZLEdBQUcsUUFBSCxHQUFjLEtBQTNDO0FBQ0EsY0FBSUMsR0FBRyxHQUFHLElBQUlDLE9BQUosQ0FBWTlCLE1BQVosRUFBb0I7QUFDMUJsQixpQkFBSyxFQUFHNkMsU0FBUyxHQUFHak0sR0FBRyxDQUFDckYsT0FBSixDQUFZcVEsS0FBWixDQUFrQlYsTUFBbEIsQ0FBeUJZLE1BQTVCLEdBQXFDbEwsR0FBRyxDQUFDckYsT0FBSixDQUFZcVEsS0FBWixDQUFrQlYsTUFBbEIsQ0FBeUJXLFFBRHJEO0FBRTFCeFIscUJBQVMsRUFBRUEsU0FGZTtBQUcxQmtKLGtCQUFNLEVBQUd1SixZQUFZLEdBQUcsWUFBSCxHQUFrQixPQUhiO0FBSTFCdlMsbUJBQU8sRUFBRSxPQUppQjtBQUsxQkMsb0JBQVEsRUFBRSw0REFBNERILFNBQTVELEdBQXdFOzs7O0FBTHhELFdBQXBCLENBQVY7QUFXQXVCLGdCQUFNLENBQUMxQixJQUFQLENBQVlnUixNQUFaLEVBQW9COUosR0FBcEIsQ0FBd0IsU0FBeEIsRUFBbUMyTCxHQUFuQztBQUNILFNBeERxQixDQTBEdEI7OztBQUNBLFlBQUloQixVQUFVLEdBQUduUSxNQUFNLENBQUNrQixJQUFQLENBQVk4RCxHQUFHLENBQUNvTCxJQUFoQixFQUFzQixrQ0FBdEIsQ0FBakI7O0FBQ0EsWUFBSUQsVUFBSixFQUFnQjtBQUNaLGNBQUkxUixTQUFTLEdBQUl5UyxZQUFZLEdBQUcsUUFBSCxHQUFjLEtBQTNDO0FBQ0EsY0FBSUMsR0FBRyxHQUFHLElBQUlDLE9BQUosQ0FBWWpCLFVBQVosRUFBd0I7QUFDOUIvQixpQkFBSyxFQUFHOEMsWUFBWSxHQUFHbE0sR0FBRyxDQUFDckYsT0FBSixDQUFZcVEsS0FBWixDQUFrQkcsVUFBbEIsQ0FBNkI1SCxHQUFoQyxHQUFzQ3ZELEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWXFRLEtBQVosQ0FBa0JHLFVBQWxCLENBQTZCL1EsRUFEekQ7QUFFOUJYLHFCQUFTLEVBQUVBLFNBRm1CO0FBRzlCa0osa0JBQU0sRUFBR3VKLFlBQVksR0FBRyxZQUFILEdBQWtCLE9BSFQ7QUFJOUJ2UyxtQkFBTyxFQUFFLE9BSnFCO0FBSzlCQyxvQkFBUSxFQUFFLDREQUE0REgsU0FBNUQsR0FBd0U7Ozs7QUFMcEQsV0FBeEIsQ0FBVjtBQVdBdUIsZ0JBQU0sQ0FBQzFCLElBQVAsQ0FBWTZSLFVBQVosRUFBd0IzSyxHQUF4QixDQUE0QixTQUE1QixFQUF1QzJMLEdBQXZDO0FBQ0g7QUFDSjtBQUNKLEtBeFNROztBQTBTVDs7O0FBR0FOLGtCQUFjLEVBQUUsMEJBQVc7QUFDdkIsVUFBSTdMLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWW9RLFFBQWhCLEVBQTBCO0FBQ3RCO0FBQ0EsWUFBSS9NLE1BQU0sR0FBR2hELE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLDhCQUF0QixDQUFiOztBQUNBLFlBQUlwTixNQUFNLElBQUloRCxNQUFNLENBQUMxQixJQUFQLENBQVkwRSxNQUFaLEVBQW9Cc0MsR0FBcEIsQ0FBd0IsU0FBeEIsQ0FBZCxFQUFrRDtBQUM5Q3RGLGdCQUFNLENBQUMxQixJQUFQLENBQVkwRSxNQUFaLEVBQW9CSixHQUFwQixDQUF3QixTQUF4QixFQUFtQ3lPLE9BQW5DO0FBQ0gsU0FMcUIsQ0FPdEI7OztBQUNBLFlBQUkzSCxNQUFNLEdBQUcxSixNQUFNLENBQUNrQixJQUFQLENBQVk4RCxHQUFHLENBQUNvTCxJQUFoQixFQUFzQiw4QkFBdEIsQ0FBYjs7QUFDQSxZQUFJMUcsTUFBTSxJQUFJMUosTUFBTSxDQUFDMUIsSUFBUCxDQUFZb0wsTUFBWixFQUFvQnBFLEdBQXBCLENBQXdCLFNBQXhCLENBQWQsRUFBa0Q7QUFDOUN0RixnQkFBTSxDQUFDMUIsSUFBUCxDQUFZb0wsTUFBWixFQUFvQjlHLEdBQXBCLENBQXdCLFNBQXhCLEVBQW1DeU8sT0FBbkM7QUFDSCxTQVhxQixDQWF0Qjs7O0FBQ0EsWUFBSS9CLE1BQU0sR0FBR3RQLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLDhCQUF0QixDQUFiOztBQUNBLFlBQUlkLE1BQU0sSUFBSXRQLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWWdSLE1BQVosRUFBb0JoSyxHQUFwQixDQUF3QixTQUF4QixDQUFkLEVBQWtEO0FBQzlDdEYsZ0JBQU0sQ0FBQzFCLElBQVAsQ0FBWWdSLE1BQVosRUFBb0IxTSxHQUFwQixDQUF3QixTQUF4QixFQUFtQ3lPLE9BQW5DO0FBQ0gsU0FqQnFCLENBbUJ0Qjs7O0FBQ0EsWUFBSWxCLFVBQVUsR0FBR25RLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLGtDQUF0QixDQUFqQjs7QUFDQSxZQUFJRCxVQUFVLElBQUluUSxNQUFNLENBQUMxQixJQUFQLENBQVk2UixVQUFaLEVBQXdCN0ssR0FBeEIsQ0FBNEIsU0FBNUIsQ0FBbEIsRUFBMEQ7QUFDdER0RixnQkFBTSxDQUFDMUIsSUFBUCxDQUFZNlIsVUFBWixFQUF3QnZOLEdBQXhCLENBQTRCLFNBQTVCLEVBQXVDeU8sT0FBdkM7QUFDSDtBQUNKO0FBQ0osS0F2VVE7O0FBeVVUOzs7QUFHQTNILFVBQU0sRUFBRSxrQkFBVztBQUNmdEUsWUFBTSxDQUFDb0IsWUFBUCxDQUFvQixRQUFwQjtBQUNILEtBOVVROztBQWdWVDs7O0FBR0E4SSxVQUFNLEVBQUUsa0JBQVc7QUFDZixVQUFJdFAsTUFBTSxDQUFDNEwsUUFBUCxDQUFnQjNHLE9BQWhCLEVBQXlCLG1CQUF6QixLQUFpRGpGLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IzRyxPQUFoQixFQUF5QixvQkFBekIsQ0FBckQsRUFBcUc7QUFDakdHLGNBQU0sQ0FBQzhLLE1BQVA7QUFDSCxPQUZELE1BRU87QUFDSDlLLGNBQU0sQ0FBQzZLLFFBQVA7QUFDSDtBQUNKLEtBelZROztBQTJWVDs7O0FBR0FBLFlBQVEsRUFBRSxvQkFBVztBQUNqQixVQUFJN0ssTUFBTSxDQUFDb0IsWUFBUCxDQUFvQixnQkFBcEIsTUFBMEMsS0FBOUMsRUFBcUQ7QUFDakQ7QUFDSDs7QUFFRHhHLFlBQU0sQ0FBQzBNLE9BQVAsQ0FBZTFILEdBQUcsQ0FBQ0UsSUFBbkIsRUFBeUJGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWW1RLGVBQXJDLEVBQXNELFlBQVc7QUFDN0QxSyxjQUFNLENBQUNvQixZQUFQLENBQW9CLGVBQXBCO0FBQ0gsT0FGRDtBQUlBeEcsWUFBTSxDQUFDUixRQUFQLENBQWdCeUYsT0FBaEIsRUFBeUIsbUJBQXpCO0FBRUEsVUFBSXFLLE1BQU0sR0FBR3RQLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWThELEdBQUcsQ0FBQ29MLElBQWhCLEVBQXNCLDhCQUF0QixDQUFiOztBQUNBLFVBQUlkLE1BQU0sSUFBSXRQLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWWdSLE1BQVosRUFBb0JoSyxHQUFwQixDQUF3QixTQUF4QixDQUFkLEVBQWtEO0FBQzlDdEYsY0FBTSxDQUFDMUIsSUFBUCxDQUFZZ1IsTUFBWixFQUFvQjFNLEdBQXBCLENBQXdCLFNBQXhCLEVBQW1DME8sa0JBQW5DLENBQXNEdE0sR0FBRyxDQUFDckYsT0FBSixDQUFZcVEsS0FBWixDQUFrQlYsTUFBbEIsQ0FBeUJZLE1BQS9FO0FBQ0g7QUFDSixLQTdXUTs7QUErV1Q7OztBQUdBQSxVQUFNLEVBQUUsa0JBQVc7QUFDZixVQUFJOUssTUFBTSxDQUFDb0IsWUFBUCxDQUFvQixjQUFwQixNQUF3QyxLQUE1QyxFQUFtRDtBQUMvQztBQUNIOztBQUVEeEcsWUFBTSxDQUFDMk0sU0FBUCxDQUFpQjNILEdBQUcsQ0FBQ0UsSUFBckIsRUFBMkJGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWW1RLGVBQXZDLEVBQXdELFlBQVc7QUFDL0QxSyxjQUFNLENBQUNvQixZQUFQLENBQW9CLGFBQXBCO0FBQ0gsT0FGRDtBQUlBeEcsWUFBTSxDQUFDb0UsV0FBUCxDQUFtQmEsT0FBbkIsRUFBNEIsbUJBQTVCO0FBQ0FqRixZQUFNLENBQUNvRSxXQUFQLENBQW1CYSxPQUFuQixFQUE0QixvQkFBNUI7QUFFQSxVQUFJcUssTUFBTSxHQUFHdFAsTUFBTSxDQUFDa0IsSUFBUCxDQUFZOEQsR0FBRyxDQUFDb0wsSUFBaEIsRUFBc0IsOEJBQXRCLENBQWI7O0FBQ0EsVUFBSWQsTUFBTSxJQUFJdFAsTUFBTSxDQUFDMUIsSUFBUCxDQUFZZ1IsTUFBWixFQUFvQmhLLEdBQXBCLENBQXdCLFNBQXhCLENBQWQsRUFBa0Q7QUFDOUN0RixjQUFNLENBQUMxQixJQUFQLENBQVlnUixNQUFaLEVBQW9CMU0sR0FBcEIsQ0FBd0IsU0FBeEIsRUFBbUMwTyxrQkFBbkMsQ0FBc0R0TSxHQUFHLENBQUNyRixPQUFKLENBQVlxUSxLQUFaLENBQWtCVixNQUFsQixDQUF5QlcsUUFBL0U7QUFDSDtBQUNKLEtBbFlROztBQW9ZVDs7O0FBR0FFLGNBQVUsRUFBRSxvQkFBU3RGLElBQVQsRUFBZTtBQUN2QixVQUFJMEcsQ0FBQyxHQUFHLEVBQVI7QUFDQSxVQUFJcEYsS0FBSyxHQUFHLEdBQVo7O0FBRUEsVUFBSXRCLElBQUksS0FBSyxLQUFULElBQW1CN0ssTUFBTSxDQUFDNEwsUUFBUCxDQUFnQjFHLElBQWhCLEVBQXNCLHFCQUF0QixLQUFnRGxGLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IzRyxPQUFoQixFQUF5QixxQkFBekIsQ0FBdkUsRUFBeUg7QUFDckhHLGNBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IscUJBQXBCO0FBRUF4RyxjQUFNLENBQUNvRSxXQUFQLENBQW1CYyxJQUFuQixFQUF5QixxQkFBekI7QUFDQWxGLGNBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJhLE9BQW5CLEVBQTRCLHFCQUE1QjtBQUVBRyxjQUFNLENBQUN5TCxjQUFQO0FBQ0F6TCxjQUFNLENBQUNrTCxhQUFQOztBQUVBLFlBQUl0TCxHQUFHLENBQUNxTCxJQUFSLEVBQWM7QUFDVnJRLGdCQUFNLENBQUNxQixHQUFQLENBQVcyRCxHQUFHLENBQUNFLElBQWYsRUFBcUIsZUFBckIsRUFBc0MsRUFBdEM7QUFDQWxGLGdCQUFNLENBQUNxQixHQUFQLENBQVcyRCxHQUFHLENBQUNxTCxJQUFmLEVBQXFCLFlBQXJCLEVBQW1DLEVBQW5DO0FBQ0g7O0FBRURqTCxjQUFNLENBQUNvQixZQUFQLENBQW9CLG9CQUFwQjtBQUNILE9BZkQsTUFlTztBQUNIcEIsY0FBTSxDQUFDb0IsWUFBUCxDQUFvQixvQkFBcEI7QUFFQXhHLGNBQU0sQ0FBQ1IsUUFBUCxDQUFnQnlGLE9BQWhCLEVBQXlCLHFCQUF6QjtBQUNBakYsY0FBTSxDQUFDUixRQUFQLENBQWdCMEYsSUFBaEIsRUFBc0IscUJBQXRCO0FBRUFFLGNBQU0sQ0FBQ3lMLGNBQVA7QUFDQXpMLGNBQU0sQ0FBQ2tMLGFBQVA7O0FBR0EsWUFBSXRMLEdBQUcsQ0FBQ3FMLElBQVIsRUFBYztBQUNWLGNBQUltQixPQUFPLEdBQUdoQyxRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVcyRCxHQUFHLENBQUNxTCxJQUFmLEVBQXFCLFFBQXJCLENBQUQsQ0FBdEI7QUFDQSxjQUFJb0IsT0FBTyxHQUFHakMsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXMkQsR0FBRyxDQUFDcUwsSUFBZixFQUFxQixRQUFyQixDQUFELENBQVIsR0FBMkNiLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ29MLElBQWYsRUFBcUIsUUFBckIsQ0FBRCxDQUFqRTtBQUNBcFEsZ0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ0UsSUFBZixFQUFxQixlQUFyQixFQUFzQ3NNLE9BQU8sR0FBRyxJQUFoRDtBQUNBeFIsZ0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzJELEdBQUcsQ0FBQ3FMLElBQWYsRUFBcUIsWUFBckIsRUFBbUMsTUFBTW9CLE9BQU4sR0FBZ0IsSUFBbkQ7QUFDSDs7QUFFRHJNLGNBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsbUJBQXBCO0FBQ0g7QUFDSixLQTdhUTs7QUErYVQ7OztBQUdBQSxnQkFBWSxFQUFFLHNCQUFTakMsSUFBVCxFQUFlO0FBQ3pCO0FBQ0EsV0FBSyxJQUFJa0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXaEUsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLFlBQUlDLEtBQUssR0FBRzFCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxDQUFaOztBQUNBLFlBQUlDLEtBQUssQ0FBQ25DLElBQU4sSUFBY0EsSUFBbEIsRUFBd0I7QUFDcEIsY0FBSW1DLEtBQUssQ0FBQ0MsR0FBTixJQUFhLElBQWpCLEVBQXVCO0FBQ25CLGdCQUFJRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxLQUFuQixFQUEwQjtBQUN0QjVCLGlCQUFHLENBQUNTLE1BQUosQ0FBV2dCLENBQVgsRUFBY0csS0FBZCxHQUFzQixJQUF0QjtBQUNBLHFCQUFPRixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLENBQVA7QUFDSDtBQUNKLFdBTEQsTUFLTztBQUNILG1CQUFPMEIsS0FBSyxDQUFDRyxPQUFOLENBQWNDLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUI5QixHQUF6QixDQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0FqY1E7QUFtY1RlLFlBQVEsRUFBRSxrQkFBU3hCLElBQVQsRUFBZXNDLE9BQWYsRUFBd0JGLEdBQXhCLEVBQTZCO0FBQ25DM0IsU0FBRyxDQUFDUyxNQUFKLENBQVdzQixJQUFYLENBQWdCO0FBQ1p4QyxZQUFJLEVBQUVBLElBRE07QUFFWnNDLGVBQU8sRUFBRUEsT0FGRztBQUdaRixXQUFHLEVBQUVBLEdBSE87QUFJWkMsYUFBSyxFQUFFO0FBSkssT0FBaEI7QUFPQSxhQUFPNUIsR0FBUDtBQUNIO0FBNWNRLEdBQWIsQ0F2Q3lDLENBc2Z6QztBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQUEsS0FBRyxDQUFDZ0MsV0FBSixHQUFrQixVQUFTckgsT0FBVCxFQUFrQjtBQUNoQ3dGLGtCQUFjLEdBQUd4RixPQUFqQjtBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUFxRixLQUFHLENBQUNoQyxNQUFKLEdBQWEsWUFBVztBQUNwQixXQUFPb0MsTUFBTSxDQUFDcEMsTUFBUCxDQUFjdkQsSUFBZCxDQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQXVGLEtBQUcsQ0FBQ3RFLFVBQUosR0FBaUIsWUFBVztBQUN4QixXQUFPMEUsTUFBTSxDQUFDMUUsVUFBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQXNFLEtBQUcsQ0FBQ3lMLFlBQUosR0FBbUIsWUFBVztBQUMxQixXQUFPckwsTUFBTSxDQUFDcUwsWUFBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQXpMLEtBQUcsQ0FBQzBMLFdBQUosR0FBa0IsWUFBVztBQUN6QixXQUFPdEwsTUFBTSxDQUFDc0wsV0FBUCxFQUFQO0FBQ0gsR0FGRDtBQUlIOzs7OztBQUdBMUwsS0FBRyxDQUFDME0sYUFBSixHQUFvQixZQUFXO0FBQzlCdE0sVUFBTSxDQUFDc0wsV0FBUDtBQUNBckksVUFBTSxDQUFDc0osbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUN2TSxNQUFNLENBQUNtTCxjQUE1QztBQUNBLEdBSEQ7QUFLRzs7Ozs7O0FBSUF2TCxLQUFHLENBQUMwRSxNQUFKLEdBQWEsWUFBVztBQUNwQixXQUFPdEUsTUFBTSxDQUFDc0UsTUFBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQTFFLEtBQUcsQ0FBQzhMLFVBQUosR0FBaUIsVUFBU3JSLElBQVQsRUFBZTtBQUM1QixXQUFPMkYsTUFBTSxDQUFDMEwsVUFBUCxDQUFrQnJSLElBQWxCLENBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7OztBQUlBdUYsS0FBRyxDQUFDc0ssTUFBSixHQUFhLFlBQVc7QUFDcEIsV0FBT2xLLE1BQU0sQ0FBQ2tLLE1BQVAsRUFBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUF0SyxLQUFHLENBQUNpTCxRQUFKLEdBQWUsWUFBVztBQUN0QixXQUFPN0ssTUFBTSxDQUFDNkssUUFBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQWpMLEtBQUcsQ0FBQ2tMLE1BQUosR0FBYSxZQUFXO0FBQ3BCLFdBQU85SyxNQUFNLENBQUM4SyxNQUFQLEVBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7OztBQUlBbEwsS0FBRyxDQUFDbUwsVUFBSixHQUFpQixZQUFXO0FBQ3hCLFdBQU8vSyxNQUFNLENBQUMrSyxVQUFQLENBQWtCLElBQWxCLENBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7OztBQUlBbkwsS0FBRyxDQUFDNE0sWUFBSixHQUFtQixZQUFXO0FBQzFCLFdBQU94TSxNQUFNLENBQUMrSyxVQUFQLENBQWtCLEtBQWxCLENBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7OztBQUlBbkwsS0FBRyxDQUFDK0wsT0FBSixHQUFjLFlBQVc7QUFDckIsV0FBTzNMLE1BQU0sQ0FBQzJMLE9BQVAsRUFBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUEvTCxLQUFHLENBQUNnTSxPQUFKLEdBQWMsWUFBVztBQUNyQixXQUFPNUwsTUFBTSxDQUFDNEwsT0FBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBaE0sS0FBRyxDQUFDNUYsRUFBSixHQUFTLFVBQVNtRixJQUFULEVBQWVzQyxPQUFmLEVBQXdCO0FBQzdCLFdBQU96QixNQUFNLENBQUNXLFFBQVAsQ0FBZ0J4QixJQUFoQixFQUFzQnNDLE9BQXRCLENBQVA7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0E3QixLQUFHLENBQUMyQixHQUFKLEdBQVUsVUFBU3BDLElBQVQsRUFBZXNDLE9BQWYsRUFBd0I7QUFDOUIsV0FBT3pCLE1BQU0sQ0FBQ1csUUFBUCxDQUFnQnhCLElBQWhCLEVBQXNCc0MsT0FBdEIsRUFBK0IsSUFBL0IsQ0FBUDtBQUNILEdBRkQsQ0E1bkJ5QyxDQWdvQnpDOzs7QUFDQXpCLFFBQU0sQ0FBQ0MsU0FBUCxDQUFpQjRCLEtBQWpCLENBQXVCakMsR0FBdkIsRUFBNEIsQ0FBQ3JGLE9BQUQsQ0FBNUI7QUFFQSxTQUFPcUYsR0FBUDtBQUNILENBcG9CRCxDLENBc29CQTs7O0FBQ0EsSUFBSSxTQUFpQyxPQUFPTixNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQjlFLFNBQWpCO0FBQ0gsQzs7Ozs7Ozs7Ozs7O0FDM29CWTs7QUFDYixJQUFJZ1MsV0FBVyxHQUFHLFNBQWRBLFdBQWMsQ0FBUzlNLFNBQVQsRUFBb0JwRixPQUFwQixFQUE2QjtBQUMzQztBQUNBLE1BQUlxRixHQUFHLEdBQUcsSUFBVjtBQUNBLE1BQUl0RCxJQUFJLEdBQUcsS0FBWCxDQUgyQyxDQUszQzs7QUFDQSxNQUFJdUQsT0FBTyxHQUFHakYsTUFBTSxDQUFDNEMsR0FBUCxDQUFXbUMsU0FBWCxDQUFkO0FBQ0EsTUFBSUcsSUFBSSxHQUFHbEYsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLE1BQVgsQ0FBWDs7QUFFQSxNQUFJLENBQUNxQyxPQUFMLEVBQWM7QUFDVjtBQUNILEdBWDBDLENBYTNDOzs7QUFDQSxNQUFJRSxjQUFjLEdBQUc7QUFDakJ3QyxVQUFNLEVBQUUsR0FEUztBQUVqQndFLFNBQUssRUFBRSxHQUZVO0FBR2pCMkYsZUFBVyxFQUFFO0FBSEksR0FBckIsQ0FkMkMsQ0FvQjNDO0FBQ0E7QUFDQTs7QUFFQSxNQUFJMU0sTUFBTSxHQUFHO0FBQ1Q7Ozs7QUFJQUMsYUFBUyxFQUFFLG1CQUFTMUYsT0FBVCxFQUFrQjtBQUN6QixVQUFJSyxNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCSyxHQUFyQixDQUF5QixXQUF6QixDQUFKLEVBQTJDO0FBQ3ZDTixXQUFHLEdBQUdoRixNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCckMsR0FBckIsQ0FBeUIsV0FBekIsQ0FBTjtBQUNILE9BRkQsTUFFTztBQUNIO0FBQ0F3QyxjQUFNLENBQUMxRCxJQUFQLENBQVkvQixPQUFaLEVBRkcsQ0FJSDs7QUFDQXlGLGNBQU0sQ0FBQ0csS0FBUDtBQUVBdkYsY0FBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQk8sR0FBckIsQ0FBeUIsV0FBekIsRUFBc0NSLEdBQXRDO0FBQ0g7O0FBRUQsYUFBT0EsR0FBUDtBQUNILEtBbkJROztBQXFCVDs7OztBQUlBdEQsUUFBSSxFQUFFLGNBQVMvQixPQUFULEVBQWtCO0FBQ3BCcUYsU0FBRyxDQUFDUyxNQUFKLEdBQWEsRUFBYixDQURvQixDQUdwQjs7QUFDQVQsU0FBRyxDQUFDckYsT0FBSixHQUFjSyxNQUFNLENBQUM4RixVQUFQLENBQWtCLEVBQWxCLEVBQXNCWCxjQUF0QixFQUFzQ3hGLE9BQXRDLENBQWQ7QUFDSCxLQTlCUTtBQWdDVDRGLFNBQUssRUFBRSxpQkFBVztBQUNkO0FBQ0EsVUFBSXdNLFNBQVMsQ0FBQ0MsU0FBVixDQUFvQkMsS0FBcEIsQ0FBMEIsbUJBQTFCLENBQUosRUFBb0Q7QUFDaEQ1SixjQUFNLENBQUNDLGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLFlBQVc7QUFDM0NsRCxnQkFBTSxDQUFDOE0sTUFBUDtBQUNILFNBRkQ7QUFJQTdKLGNBQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0IsYUFBeEIsRUFBdUMsWUFBVztBQUM5Q2xELGdCQUFNLENBQUM4TSxNQUFQO0FBQ0gsU0FGRDtBQUlBN0osY0FBTSxDQUFDQyxnQkFBUCxDQUF3QixZQUF4QixFQUFzQyxZQUFXO0FBQzdDbEQsZ0JBQU0sQ0FBQzhNLE1BQVA7QUFDSCxTQUZEO0FBR0gsT0FaRCxNQVlPO0FBQ0g3SixjQUFNLENBQUNDLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLFlBQVc7QUFDekNsRCxnQkFBTSxDQUFDOE0sTUFBUDtBQUNILFNBRkQ7QUFHSCxPQWxCYSxDQW9CZDs7O0FBQ0FsUyxZQUFNLENBQUMrRixRQUFQLENBQWdCZCxPQUFoQixFQUF5QixPQUF6QixFQUFrQ0csTUFBTSxDQUFDd0QsTUFBekM7QUFDSCxLQXREUTs7QUF3RFQ7OztBQUdBc0osVUFBTSxFQUFFLGtCQUFXO0FBQ2YsVUFBSUMsR0FBRyxHQUFHOUosTUFBTSxDQUFDK0osV0FBakIsQ0FEZSxDQUNlOztBQUM5QixVQUFJRCxHQUFHLEdBQUduTixHQUFHLENBQUNyRixPQUFKLENBQVlnSSxNQUF0QixFQUE4QjtBQUMxQjNILGNBQU0sQ0FBQ1IsUUFBUCxDQUFnQjBGLElBQWhCLEVBQXNCRixHQUFHLENBQUNyRixPQUFKLENBQVltUyxXQUFsQztBQUNILE9BRkQsTUFFTztBQUNIOVIsY0FBTSxDQUFDb0UsV0FBUCxDQUFtQmMsSUFBbkIsRUFBeUJGLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWW1TLFdBQXJDO0FBQ0g7QUFDSixLQWxFUTs7QUFvRVQ7OztBQUdBbEosVUFBTSxFQUFFLGdCQUFTNUgsQ0FBVCxFQUFZO0FBQ2hCQSxPQUFDLENBQUNnRixjQUFGO0FBRUFoRyxZQUFNLENBQUN3SyxTQUFQLENBQWlCLENBQWpCLEVBQW9CeEYsR0FBRyxDQUFDckYsT0FBSixDQUFZd00sS0FBaEM7QUFDSCxLQTNFUTs7QUE4RVQ7OztBQUdBM0YsZ0JBQVksRUFBRSxzQkFBU2pDLElBQVQsRUFBZW1FLElBQWYsRUFBcUI7QUFDL0IsV0FBSyxJQUFJakMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXaEUsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLFlBQUlDLEtBQUssR0FBRzFCLEdBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxDQUFaOztBQUNBLFlBQUlDLEtBQUssQ0FBQ25DLElBQU4sSUFBY0EsSUFBbEIsRUFBd0I7QUFDcEIsY0FBSW1DLEtBQUssQ0FBQ0MsR0FBTixJQUFhLElBQWpCLEVBQXVCO0FBQ25CLGdCQUFJRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxLQUFuQixFQUEwQjtBQUN0QjVCLGlCQUFHLENBQUNTLE1BQUosQ0FBV2dCLENBQVgsRUFBY0csS0FBZCxHQUFzQixJQUF0QjtBQUNBLHFCQUFPRixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLEVBQThCMEQsSUFBOUIsQ0FBUDtBQUNIO0FBQ0osV0FMRCxNQUtPO0FBQ0osbUJBQU9oQyxLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLEVBQThCMEQsSUFBOUIsQ0FBUDtBQUNGO0FBQ0o7QUFDSjtBQUNKLEtBL0ZRO0FBaUdUM0MsWUFBUSxFQUFFLGtCQUFTeEIsSUFBVCxFQUFlc0MsT0FBZixFQUF3QkYsR0FBeEIsRUFBNkI7QUFDbkMzQixTQUFHLENBQUNTLE1BQUosQ0FBV3NCLElBQVgsQ0FBZ0I7QUFDWnhDLFlBQUksRUFBRUEsSUFETTtBQUVac0MsZUFBTyxFQUFFQSxPQUZHO0FBR1pGLFdBQUcsRUFBRUEsR0FITztBQUlaQyxhQUFLLEVBQUU7QUFKSyxPQUFoQjtBQU1IO0FBeEdRLEdBQWIsQ0F4QjJDLENBbUkzQztBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTVCLEtBQUcsQ0FBQ2dDLFdBQUosR0FBa0IsVUFBU3JILE9BQVQsRUFBa0I7QUFDaEN3RixrQkFBYyxHQUFHeEYsT0FBakI7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0FxRixLQUFHLENBQUM1RixFQUFKLEdBQVMsVUFBU21GLElBQVQsRUFBZXNDLE9BQWYsRUFBd0I7QUFDN0IsV0FBT3pCLE1BQU0sQ0FBQ1csUUFBUCxDQUFnQnhCLElBQWhCLEVBQXNCc0MsT0FBdEIsQ0FBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7O0FBSUE3QixLQUFHLENBQUMyQixHQUFKLEdBQVUsVUFBU3BDLElBQVQsRUFBZXNDLE9BQWYsRUFBd0I7QUFDOUIsV0FBT3pCLE1BQU0sQ0FBQ1csUUFBUCxDQUFnQnhCLElBQWhCLEVBQXNCc0MsT0FBdEIsRUFBK0IsSUFBL0IsQ0FBUDtBQUNILEdBRkQsQ0ExSjJDLENBOEozQztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0F6QixRQUFNLENBQUNDLFNBQVAsQ0FBaUI0QixLQUFqQixDQUF1QmpDLEdBQXZCLEVBQTRCLENBQUNyRixPQUFELENBQTVCLEVBbksyQyxDQXFLM0M7O0FBQ0ErQixNQUFJLEdBQUcsSUFBUCxDQXRLMkMsQ0F3SzNDOztBQUNBLFNBQU9zRCxHQUFQO0FBQ0gsQ0ExS0QsQyxDQTRLQTs7O0FBQ0EsSUFBSSxTQUFpQyxPQUFPTixNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQmtOLFdBQWpCO0FBQ0gsQzs7Ozs7Ozs7Ozs7O0NDOUtEOztBQUNBLElBQUlRLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVN0TixTQUFULEVBQW9CcEYsT0FBcEIsRUFBNkI7QUFDeEM7QUFDQSxNQUFJcUYsR0FBRyxHQUFHLElBQVY7QUFDQSxNQUFJdEQsSUFBSSxHQUFHLEtBQVgsQ0FId0MsQ0FLeEM7O0FBQ0EsTUFBSXVELE9BQU8sR0FBR2pGLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV21DLFNBQVgsQ0FBZDtBQUNBLE1BQUlHLElBQUksR0FBR2xGLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxNQUFYLENBQVg7O0FBRUEsTUFBSSxDQUFDcUMsT0FBTCxFQUFjO0FBQ1Y7QUFDSCxHQVh1QyxDQWF4Qzs7O0FBQ0EsTUFBSUUsY0FBYyxHQUFHO0FBQ2pCbU4sZ0JBQVksRUFBRSxFQURHO0FBRWpCQyxlQUFXLEVBQUU7QUFGSSxHQUFyQixDQWR3QyxDQW1CeEM7QUFDQTtBQUNBOztBQUVBLE1BQUluTixNQUFNLEdBQUc7QUFDVDs7O0FBSUFDLGFBQVMsRUFBRSxtQkFBUzFGLE9BQVQsRUFBa0I7QUFDekIsVUFBSUssTUFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQkssR0FBckIsQ0FBeUIsUUFBekIsQ0FBSixFQUF3QztBQUNwQ04sV0FBRyxHQUFHaEYsTUFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQnJDLEdBQXJCLENBQXlCLFFBQXpCLENBQU47QUFDSCxPQUZELE1BRU87QUFDSDtBQUNBd0MsY0FBTSxDQUFDMUQsSUFBUCxDQUFZL0IsT0FBWixFQUZHLENBSUg7O0FBQ0F5RixjQUFNLENBQUNHLEtBQVA7QUFFQXZGLGNBQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJPLEdBQXJCLENBQXlCLFFBQXpCLEVBQW1DUixHQUFuQztBQUNIOztBQUVELGFBQU9BLEdBQVA7QUFDSCxLQW5CUTs7QUFxQlQ7OztBQUdBdEQsUUFBSSxFQUFFLGNBQVMvQixPQUFULEVBQWtCO0FBQ3BCcUYsU0FBRyxDQUFDQyxPQUFKLEdBQWNBLE9BQWQ7QUFDQUQsU0FBRyxDQUFDUyxNQUFKLEdBQWEsRUFBYixDQUZvQixDQUlwQjs7QUFDQVQsU0FBRyxDQUFDckYsT0FBSixHQUFjSyxNQUFNLENBQUM4RixVQUFQLENBQWtCLEVBQWxCLEVBQXNCWCxjQUF0QixFQUFzQ3hGLE9BQXRDLENBQWQ7QUFFQXFGLFNBQUcsQ0FBQy9ELE1BQUosR0FBYWpCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV29DLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWXNCLE1BQXZCLENBQWI7QUFDQStELFNBQUcsQ0FBQ3VOLFdBQUosR0FBa0J2TixHQUFHLENBQUNyRixPQUFKLENBQVk0UyxXQUE5QjtBQUNBdk4sU0FBRyxDQUFDc04sWUFBSixHQUFtQnROLEdBQUcsQ0FBQ3JGLE9BQUosQ0FBWTJTLFlBQS9CO0FBRUF0TixTQUFHLENBQUM5QyxLQUFKLEdBQVlsQyxNQUFNLENBQUM0SyxVQUFQLENBQWtCNUYsR0FBRyxDQUFDL0QsTUFBdEIsRUFBOEIrRCxHQUFHLENBQUN1TixXQUFsQyxJQUFpRCxJQUFqRCxHQUF3RCxLQUFwRTtBQUNILEtBcENROztBQXNDVDs7O0FBR0FoTixTQUFLLEVBQUUsaUJBQVc7QUFDZHZGLFlBQU0sQ0FBQytGLFFBQVAsQ0FBZ0JkLE9BQWhCLEVBQXlCLFNBQXpCLEVBQW9DRyxNQUFNLENBQUNrSyxNQUEzQztBQUNILEtBM0NROztBQTZDVDs7O0FBR0FBLFVBQU0sRUFBRSxnQkFBU3RPLENBQVQsRUFBWTtBQUNoQm9FLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsY0FBcEI7O0FBRUEsVUFBSXhCLEdBQUcsQ0FBQzlDLEtBQUosSUFBYSxLQUFqQixFQUF3QjtBQUNwQmtELGNBQU0sQ0FBQ29OLFFBQVA7QUFDSCxPQUZELE1BRU87QUFDSHBOLGNBQU0sQ0FBQ3FOLFNBQVA7QUFDSDs7QUFFRHJOLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsYUFBcEI7QUFFQXhGLE9BQUMsQ0FBQ2dGLGNBQUY7QUFFQSxhQUFPaEIsR0FBUDtBQUNILEtBOURROztBQWdFVDs7O0FBR0F3TixZQUFRLEVBQUUsb0JBQVc7QUFDakJwTixZQUFNLENBQUNvQixZQUFQLENBQW9CLFVBQXBCO0FBRUF4RyxZQUFNLENBQUNSLFFBQVAsQ0FBZ0J3RixHQUFHLENBQUMvRCxNQUFwQixFQUE0QitELEdBQUcsQ0FBQ3VOLFdBQWhDOztBQUVBLFVBQUl2TixHQUFHLENBQUNzTixZQUFSLEVBQXNCO0FBQ2xCdFMsY0FBTSxDQUFDUixRQUFQLENBQWdCeUYsT0FBaEIsRUFBeUJELEdBQUcsQ0FBQ3NOLFlBQTdCO0FBQ0g7O0FBRUR0TixTQUFHLENBQUM5QyxLQUFKLEdBQVksSUFBWjtBQUVBa0QsWUFBTSxDQUFDb0IsWUFBUCxDQUFvQixTQUFwQjtBQUVBcEIsWUFBTSxDQUFDb0IsWUFBUCxDQUFvQixRQUFwQjtBQUVBLGFBQU94QixHQUFQO0FBQ0gsS0FuRlE7O0FBcUZUOzs7QUFHQXlOLGFBQVMsRUFBRSxxQkFBVztBQUNsQnJOLFlBQU0sQ0FBQ29CLFlBQVAsQ0FBb0IsV0FBcEI7QUFFQXhHLFlBQU0sQ0FBQ29FLFdBQVAsQ0FBbUJZLEdBQUcsQ0FBQy9ELE1BQXZCLEVBQStCK0QsR0FBRyxDQUFDdU4sV0FBbkM7O0FBRUEsVUFBSXZOLEdBQUcsQ0FBQ3NOLFlBQVIsRUFBc0I7QUFDbEJ0UyxjQUFNLENBQUNvRSxXQUFQLENBQW1CYSxPQUFuQixFQUE0QkQsR0FBRyxDQUFDc04sWUFBaEM7QUFDSDs7QUFFRHROLFNBQUcsQ0FBQzlDLEtBQUosR0FBWSxLQUFaO0FBRUFrRCxZQUFNLENBQUNvQixZQUFQLENBQW9CLFVBQXBCO0FBRUFwQixZQUFNLENBQUNvQixZQUFQLENBQW9CLFFBQXBCO0FBRUEsYUFBT3hCLEdBQVA7QUFDSCxLQXhHUTs7QUEwR1Q7OztBQUdBd0IsZ0JBQVksRUFBRSxzQkFBU2pDLElBQVQsRUFBZTtBQUN6QixXQUFLLElBQUlrQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHekIsR0FBRyxDQUFDUyxNQUFKLENBQVdoRSxNQUEvQixFQUF1Q2dGLENBQUMsRUFBeEMsRUFBNEM7QUFDeEMsWUFBSUMsS0FBSyxHQUFHMUIsR0FBRyxDQUFDUyxNQUFKLENBQVdnQixDQUFYLENBQVo7O0FBRUEsWUFBSUMsS0FBSyxDQUFDbkMsSUFBTixJQUFjQSxJQUFsQixFQUF3QjtBQUNwQixjQUFJbUMsS0FBSyxDQUFDQyxHQUFOLElBQWEsSUFBakIsRUFBdUI7QUFDbkIsZ0JBQUlELEtBQUssQ0FBQ0UsS0FBTixJQUFlLEtBQW5CLEVBQTBCO0FBQ3RCNUIsaUJBQUcsQ0FBQ1MsTUFBSixDQUFXZ0IsQ0FBWCxFQUFjRyxLQUFkLEdBQXNCLElBQXRCO0FBQ0EscUJBQU9GLEtBQUssQ0FBQ0csT0FBTixDQUFjQyxJQUFkLENBQW1CLElBQW5CLEVBQXlCOUIsR0FBekIsQ0FBUDtBQUNIO0FBQ0osV0FMRCxNQUtPO0FBQ0gsbUJBQU8wQixLQUFLLENBQUNHLE9BQU4sQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixFQUF5QjlCLEdBQXpCLENBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQTVIUTtBQThIVGUsWUFBUSxFQUFFLGtCQUFTeEIsSUFBVCxFQUFlc0MsT0FBZixFQUF3QkYsR0FBeEIsRUFBNkI7QUFDbkMzQixTQUFHLENBQUNTLE1BQUosQ0FBV3NCLElBQVgsQ0FBZ0I7QUFDWnhDLFlBQUksRUFBRUEsSUFETTtBQUVac0MsZUFBTyxFQUFFQSxPQUZHO0FBR1pGLFdBQUcsRUFBRUEsR0FITztBQUlaQyxhQUFLLEVBQUU7QUFKSyxPQUFoQjtBQU9BLGFBQU81QixHQUFQO0FBQ0g7QUF2SVEsR0FBYixDQXZCd0MsQ0FpS3hDO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBQSxLQUFHLENBQUNnQyxXQUFKLEdBQWtCLFVBQVNySCxPQUFULEVBQWtCO0FBQ2hDd0Ysa0JBQWMsR0FBR3hGLE9BQWpCO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBcUYsS0FBRyxDQUFDME4sUUFBSixHQUFlLFlBQVc7QUFDdEIsV0FBTzFOLEdBQUcsQ0FBQzlDLEtBQVg7QUFDSCxHQUZEO0FBSUE7Ozs7O0FBR0E4QyxLQUFHLENBQUNzSyxNQUFKLEdBQWEsWUFBVztBQUNwQixXQUFPbEssTUFBTSxDQUFDa0ssTUFBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7OztBQUdBdEssS0FBRyxDQUFDd04sUUFBSixHQUFlLFlBQVc7QUFDdEIsV0FBT3BOLE1BQU0sQ0FBQ29OLFFBQVAsRUFBUDtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQXhOLEtBQUcsQ0FBQ3lOLFNBQUosR0FBZ0IsWUFBVztBQUN2QixXQUFPck4sTUFBTSxDQUFDcU4sU0FBUCxFQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQXpOLEtBQUcsQ0FBQzVGLEVBQUosR0FBUyxVQUFTbUYsSUFBVCxFQUFlc0MsT0FBZixFQUF3QjtBQUM3QixXQUFPekIsTUFBTSxDQUFDVyxRQUFQLENBQWdCeEIsSUFBaEIsRUFBc0JzQyxPQUF0QixDQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQTdCLEtBQUcsQ0FBQzJCLEdBQUosR0FBVSxVQUFTcEMsSUFBVCxFQUFlc0MsT0FBZixFQUF3QjtBQUM5QixXQUFPekIsTUFBTSxDQUFDVyxRQUFQLENBQWdCeEIsSUFBaEIsRUFBc0JzQyxPQUF0QixFQUErQixJQUEvQixDQUFQO0FBQ0gsR0FGRCxDQXJOd0MsQ0F5TnhDOzs7QUFDQXpCLFFBQU0sQ0FBQ0MsU0FBUCxDQUFpQjRCLEtBQWpCLENBQXVCakMsR0FBdkIsRUFBNEIsQ0FBQ3JGLE9BQUQsQ0FBNUI7QUFFQSxTQUFPcUYsR0FBUDtBQUNILENBN05ELEMsQ0ErTkE7OztBQUNBLElBQUksU0FBaUMsT0FBT04sTUFBTSxDQUFDQyxPQUFkLEtBQTBCLFdBQS9ELEVBQTRFO0FBQ3hFRCxRQUFNLENBQUNDLE9BQVAsR0FBaUIwTixRQUFqQjtBQUNILEM7Ozs7Ozs7Ozs7OztBQ3JPWTtBQUNiOzs7QUFJQTs7QUFDQTs7Ozs7OztBQUlBLElBQUksQ0FBQ00sT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUF2QixFQUFnQztBQUMvQkYsU0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixHQUE0QkYsT0FBTyxDQUFDQyxTQUFSLENBQWtCRSxpQkFBbEIsSUFBdUNILE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcscUJBQXJGO0FBQ0E7QUFFRDs7Ozs7O0FBSUEsSUFBSSxDQUFDSixPQUFPLENBQUNDLFNBQVIsQ0FBa0JwUyxPQUF2QixFQUFnQztBQUMvQixNQUFJLENBQUNtUyxPQUFPLENBQUNDLFNBQVIsQ0FBa0JDLE9BQXZCLEVBQWdDO0FBQy9CRixXQUFPLENBQUNDLFNBQVIsQ0FBa0JDLE9BQWxCLEdBQTRCRixPQUFPLENBQUNDLFNBQVIsQ0FBa0JFLGlCQUFsQixJQUF1Q0gsT0FBTyxDQUFDQyxTQUFSLENBQWtCRyxxQkFBckY7QUFDQTs7QUFDREosU0FBTyxDQUFDQyxTQUFSLENBQWtCcFMsT0FBbEIsR0FBNEIsVUFBVXdTLENBQVYsRUFBYTtBQUN4QyxRQUFJNVUsRUFBRSxHQUFHLElBQVQ7QUFDQSxRQUFJNlUsUUFBUSxHQUFHLElBQWY7QUFDQSxRQUFJLENBQUN2USxRQUFRLENBQUN3USxlQUFULENBQXlCL0YsUUFBekIsQ0FBa0MvTyxFQUFsQyxDQUFMLEVBQTRDLE9BQU8sSUFBUDs7QUFDNUMsT0FBRztBQUNGLFVBQUk2VSxRQUFRLENBQUNKLE9BQVQsQ0FBaUJHLENBQWpCLENBQUosRUFBeUIsT0FBT0MsUUFBUDtBQUN6QkEsY0FBUSxHQUFHQSxRQUFRLENBQUNFLGFBQXBCO0FBQ0EsS0FIRCxRQUdTRixRQUFRLEtBQUssSUFIdEI7O0FBSUEsV0FBTyxJQUFQO0FBQ0EsR0FURDtBQVVBO0FBRUQ7Ozs7Ozs7O0FBTUEsQ0FBQyxVQUFVRyxJQUFWLEVBQWdCO0FBQ2hCLE9BQUssSUFBSTNNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcyTSxJQUFJLENBQUMzUixNQUF6QixFQUFpQ2dGLENBQUMsRUFBbEMsRUFBc0M7QUFDckMsUUFBSSxDQUFDNEIsTUFBTSxDQUFDK0ssSUFBSSxDQUFDM00sQ0FBRCxDQUFMLENBQVAsSUFBb0IsWUFBWTRCLE1BQU0sQ0FBQytLLElBQUksQ0FBQzNNLENBQUQsQ0FBTCxDQUFOLENBQWdCbU0sU0FBcEQsRUFBK0Q7O0FBQy9EdkssVUFBTSxDQUFDK0ssSUFBSSxDQUFDM00sQ0FBRCxDQUFMLENBQU4sQ0FBZ0JtTSxTQUFoQixDQUEwQjVQLE1BQTFCLEdBQW1DLFlBQVk7QUFDOUMsV0FBSzhMLFVBQUwsQ0FBZ0J1RSxXQUFoQixDQUE0QixJQUE1QjtBQUNBLEtBRkQ7QUFHQTtBQUNELENBUEQsRUFPRyxDQUFDLFNBQUQsRUFBWSxlQUFaLEVBQTZCLGNBQTdCLENBUEgsRSxDQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsYUFBVztBQUNSLE1BQUlDLFFBQVEsR0FBRyxDQUFmO0FBQ0EsTUFBSUMsT0FBTyxHQUFHLENBQUMsUUFBRCxFQUFXLEtBQVgsQ0FBZDs7QUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELE9BQU8sQ0FBQzlSLE1BQVosSUFBc0IsQ0FBQzRHLE1BQU0sQ0FBQ29MLHFCQUE5QyxFQUFxRSxFQUFFRCxDQUF2RSxFQUEwRTtBQUN0RW5MLFVBQU0sQ0FBQ29MLHFCQUFQLEdBQStCcEwsTUFBTSxDQUFDa0wsT0FBTyxDQUFDQyxDQUFELENBQVAsR0FBYSx1QkFBZCxDQUFyQztBQUNBbkwsVUFBTSxDQUFDcUwsb0JBQVAsR0FDSXJMLE1BQU0sQ0FBQ2tMLE9BQU8sQ0FBQ0MsQ0FBRCxDQUFQLEdBQWEsc0JBQWQsQ0FBTixJQUErQ25MLE1BQU0sQ0FBQ2tMLE9BQU8sQ0FBQ0MsQ0FBRCxDQUFQLEdBQWEsNkJBQWQsQ0FEekQ7QUFFSDs7QUFFRCxNQUFJLENBQUNuTCxNQUFNLENBQUNvTCxxQkFBWixFQUNJcEwsTUFBTSxDQUFDb0wscUJBQVAsR0FBK0IsVUFBU0UsUUFBVCxFQUFtQjtBQUM5QyxRQUFJQyxRQUFRLEdBQUcsSUFBSW5HLElBQUosR0FBV0MsT0FBWCxFQUFmO0FBQ0EsUUFBSW1HLFVBQVUsR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU1ILFFBQVEsR0FBR04sUUFBakIsQ0FBWixDQUFqQjtBQUNBLFFBQUl6RCxFQUFFLEdBQUd4SCxNQUFNLENBQUNvRCxVQUFQLENBQWtCLFlBQVc7QUFDbENrSSxjQUFRLENBQUNDLFFBQVEsR0FBR0MsVUFBWixDQUFSO0FBQ0gsS0FGUSxFQUVOQSxVQUZNLENBQVQ7QUFHQVAsWUFBUSxHQUFHTSxRQUFRLEdBQUdDLFVBQXRCO0FBQ0EsV0FBT2hFLEVBQVA7QUFDSCxHQVJEO0FBVUosTUFBSSxDQUFDeEgsTUFBTSxDQUFDcUwsb0JBQVosRUFDSXJMLE1BQU0sQ0FBQ3FMLG9CQUFQLEdBQThCLFVBQVM3RCxFQUFULEVBQWE7QUFDdkN2RSxnQkFBWSxDQUFDdUUsRUFBRCxDQUFaO0FBQ0gsR0FGRDtBQUdQLENBeEJBLEdBQUQsQyxDQTBCQTs7O0FBQ0EsQ0FBQyxVQUFTbUUsR0FBVCxFQUFjO0FBQ1hBLEtBQUcsQ0FBQ0MsT0FBSixDQUFZLFVBQVM5SSxJQUFULEVBQWU7QUFDdkIsUUFBSUEsSUFBSSxDQUFDK0ksY0FBTCxDQUFvQixTQUFwQixDQUFKLEVBQW9DO0FBQ2hDO0FBQ0g7O0FBQ0RDLFVBQU0sQ0FBQ0MsY0FBUCxDQUFzQmpKLElBQXRCLEVBQTRCLFNBQTVCLEVBQXVDO0FBQ25Da0osa0JBQVksRUFBRSxJQURxQjtBQUVuQ0MsZ0JBQVUsRUFBRSxJQUZ1QjtBQUduQ0MsY0FBUSxFQUFFLElBSHlCO0FBSW5DaE8sV0FBSyxFQUFFLFNBQVMxRCxPQUFULEdBQW1CO0FBQ3RCLFlBQUkyUixNQUFNLEdBQUdDLEtBQUssQ0FBQzdCLFNBQU4sQ0FBZ0I4QixLQUFoQixDQUFzQjVOLElBQXRCLENBQTJCNk4sU0FBM0IsQ0FBYjtBQUFBLFlBQ0lDLE9BQU8sR0FBR2xTLFFBQVEsQ0FBQ21TLHNCQUFULEVBRGQ7QUFHQUwsY0FBTSxDQUFDUCxPQUFQLENBQWUsVUFBU2EsT0FBVCxFQUFrQjtBQUM3QixjQUFJQyxNQUFNLEdBQUdELE9BQU8sWUFBWUUsSUFBaEM7QUFDQUosaUJBQU8sQ0FBQ3ZOLFdBQVIsQ0FBb0IwTixNQUFNLEdBQUdELE9BQUgsR0FBYXBTLFFBQVEsQ0FBQ3VTLGNBQVQsQ0FBd0JDLE1BQU0sQ0FBQ0osT0FBRCxDQUE5QixDQUF2QztBQUNILFNBSEQ7QUFLQSxhQUFLSyxZQUFMLENBQWtCUCxPQUFsQixFQUEyQixLQUFLUSxVQUFoQztBQUNIO0FBZGtDLEtBQXZDO0FBZ0JILEdBcEJEO0FBcUJILENBdEJELEVBc0JHLENBQUN6QyxPQUFPLENBQUNDLFNBQVQsRUFBb0J5QyxRQUFRLENBQUN6QyxTQUE3QixFQUF3QzBDLGdCQUFnQixDQUFDMUMsU0FBekQsQ0F0QkgsRSxDQXdCQTs7O0FBQ0F2SyxNQUFNLENBQUNrTixzQkFBUCxHQUFnQyxFQUFoQztBQUNBbE4sTUFBTSxDQUFDbU4sd0JBQVAsR0FBa0MsQ0FBbEM7QUFDQW5OLE1BQU0sQ0FBQ29OLDRCQUFQLEdBQXNDLEVBQXRDOztBQUVBLElBQUl6VixNQUFNLEdBQUcsWUFBVztBQUNwQixNQUFJMFYsY0FBYyxHQUFHLEVBQXJCO0FBRUE7O0FBQ0EsTUFBSUMsV0FBVyxHQUFHO0FBQ2RDLE1BQUUsRUFBRSxHQURVO0FBQ0w7QUFDVEMsTUFBRSxFQUFFLEdBRlU7QUFFTDtBQUNUQyxNQUFFLEVBQUUsSUFIVTtBQUdKO0FBQ1ZDLE1BQUUsRUFBRSxJQUpVLENBSUw7O0FBSkssR0FBbEI7QUFPQTs7Ozs7QUFJQSxNQUFJQyxvQkFBb0IsR0FBRyxTQUF2QkEsb0JBQXVCLEdBQVc7QUFDbEMsUUFBSUMsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixHQUFXO0FBQ2hDO0FBQ0EsV0FBSyxJQUFJeFAsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lQLGNBQWMsQ0FBQ2pVLE1BQW5DLEVBQTJDZ0YsQ0FBQyxFQUE1QyxFQUFnRDtBQUM1QyxZQUFJMUgsSUFBSSxHQUFHMlcsY0FBYyxDQUFDalAsQ0FBRCxDQUF6QjtBQUNBMUgsWUFBSSxDQUFDK0gsSUFBTDtBQUNIO0FBQ0osS0FORDs7QUFRQSxRQUFJcUMsT0FBTyxHQUFHLEtBQWQsQ0FUa0MsQ0FTYjs7QUFDckIsUUFBSStNLEtBQUssR0FBRyxHQUFaLENBVmtDLENBVWpCOztBQUVqQjdOLFVBQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsWUFBVztBQUN6Q2dELGtCQUFZLENBQUNuQyxPQUFELENBQVo7QUFDQUEsYUFBTyxHQUFHc0MsVUFBVSxDQUFDLFlBQVc7QUFDNUJ3SywwQkFBa0I7QUFDckIsT0FGbUIsRUFFakJDLEtBRmlCLENBQXBCLENBRnlDLENBSTlCO0FBQ2QsS0FMRDtBQU1ILEdBbEJEOztBQW9CQSxTQUFPO0FBQ0g7Ozs7O0FBS0E7QUFDQXhVLFFBQUksRUFBRSxjQUFTL0IsT0FBVCxFQUFrQjtBQUNwQixVQUFJQSxPQUFPLElBQUlBLE9BQU8sQ0FBQ2dXLFdBQXZCLEVBQW9DO0FBQ2hDQSxtQkFBVyxHQUFHaFcsT0FBTyxDQUFDZ1csV0FBdEI7QUFDSDs7QUFFREssMEJBQW9CO0FBQ3ZCLEtBYkU7O0FBZUg7Ozs7QUFJQW5ILG9CQUFnQixFQUFFLDBCQUFTOEUsUUFBVCxFQUFtQjtBQUNqQytCLG9CQUFjLENBQUMzTyxJQUFmLENBQW9CNE0sUUFBcEI7QUFDSCxLQXJCRTs7QUF1Qkg7Ozs7QUFJQXdDLHVCQUFtQixFQUFFLDZCQUFTeEMsUUFBVCxFQUFtQjtBQUNwQyxXQUFLLElBQUlsTixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaVAsY0FBYyxDQUFDalUsTUFBbkMsRUFBMkNnRixDQUFDLEVBQTVDLEVBQWdEO0FBQzVDLFlBQUlrTixRQUFRLEtBQUsrQixjQUFjLENBQUNqUCxDQUFELENBQS9CLEVBQW9DO0FBQ2hDLGlCQUFPaVAsY0FBYyxDQUFDalAsQ0FBRCxDQUFyQjtBQUNIO0FBQ0o7QUFDSixLQWpDRTs7QUFtQ0g7OztBQUdBMlAscUJBQWlCLEVBQUUsNkJBQVc7QUFDMUJILHdCQUFrQjtBQUNyQixLQXhDRTtBQTBDSEksVUFBTSxFQUFFLGtCQUFXO0FBQ2YsVUFBSSxPQUFPQyxLQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQzlCO0FBQ0FqTyxjQUFNLENBQUNrTyxhQUFQLENBQXFCLElBQUlELEtBQUosQ0FBVSxRQUFWLENBQXJCO0FBQ0gsT0FIRCxNQUdPO0FBQ0g7QUFDQTtBQUNBLFlBQUlFLEdBQUcsR0FBR25PLE1BQU0sQ0FBQzNGLFFBQVAsQ0FBZ0IrVCxXQUFoQixDQUE0QixVQUE1QixDQUFWO0FBQ0FELFdBQUcsQ0FBQ0UsV0FBSixDQUFnQixRQUFoQixFQUEwQixJQUExQixFQUFnQyxLQUFoQyxFQUF1Q3JPLE1BQXZDLEVBQStDLENBQS9DO0FBQ0FBLGNBQU0sQ0FBQ2tPLGFBQVAsQ0FBcUJDLEdBQXJCO0FBQ0g7QUFDSixLQXJERTs7QUF1REg7Ozs7O0FBS0FHLGVBQVcsRUFBRSxxQkFBU0MsU0FBVCxFQUFvQjtBQUM3QixVQUFJQyxZQUFZLEdBQUd4TyxNQUFNLENBQUN5TyxRQUFQLENBQWdCQyxNQUFoQixDQUF1QkMsU0FBdkIsQ0FBaUMsQ0FBakMsQ0FBbkI7QUFBQSxVQUNJdlEsQ0FESjtBQUFBLFVBQ09uSCxHQURQO0FBQUEsVUFDWTJELE1BQU0sR0FBRzRULFlBQVksQ0FBQ0ksS0FBYixDQUFtQixHQUFuQixDQURyQjs7QUFHQSxXQUFLeFEsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHeEQsTUFBTSxDQUFDeEIsTUFBdkIsRUFBK0JnRixDQUFDLEVBQWhDLEVBQW9DO0FBQ2hDbkgsV0FBRyxHQUFHMkQsTUFBTSxDQUFDd0QsQ0FBRCxDQUFOLENBQVV3USxLQUFWLENBQWdCLEdBQWhCLENBQU47O0FBQ0EsWUFBSTNYLEdBQUcsQ0FBQyxDQUFELENBQUgsSUFBVXNYLFNBQWQsRUFBeUI7QUFDckIsaUJBQU9NLFFBQVEsQ0FBQzVYLEdBQUcsQ0FBQyxDQUFELENBQUosQ0FBZjtBQUNIO0FBQ0o7O0FBRUQsYUFBTyxJQUFQO0FBQ0gsS0F4RUU7O0FBMEVIOzs7O0FBSUE2WCxrQkFBYyxFQUFFLDBCQUFXO0FBQ3ZCLGFBQVEsS0FBS2pQLFdBQUwsR0FBbUIzSixLQUFuQixHQUEyQixLQUFLNlksYUFBTCxDQUFtQixJQUFuQixDQUEzQixHQUFzRCxJQUF0RCxHQUE2RCxLQUFyRTtBQUNILEtBaEZFOztBQWtGSDs7OztBQUlBQyxtQkFBZSxFQUFFLDJCQUFXO0FBQ3hCLGFBQU9yWCxNQUFNLENBQUNtWCxjQUFQLEtBQTBCLEtBQTFCLEdBQWtDLElBQXpDO0FBQ0gsS0F4RkU7O0FBMEZIOzs7OztBQUtBalAsZUFBVyxFQUFFLHVCQUFXO0FBQ3BCLFVBQUlsSCxDQUFDLEdBQUdxSCxNQUFSO0FBQUEsVUFDSWlQLENBQUMsR0FBRyxPQURSOztBQUVBLFVBQUksRUFBRSxnQkFBZ0JqUCxNQUFsQixDQUFKLEVBQStCO0FBQzNCaVAsU0FBQyxHQUFHLFFBQUo7QUFDQXRXLFNBQUMsR0FBRzBCLFFBQVEsQ0FBQ3dRLGVBQVQsSUFBNEJ4USxRQUFRLENBQUN3QyxJQUF6QztBQUNIOztBQUVELGFBQU87QUFDSDNHLGFBQUssRUFBRXlDLENBQUMsQ0FBQ3NXLENBQUMsR0FBRyxPQUFMLENBREw7QUFFSGpYLGNBQU0sRUFBRVcsQ0FBQyxDQUFDc1csQ0FBQyxHQUFHLFFBQUw7QUFGTixPQUFQO0FBSUgsS0EzR0U7O0FBNkdIOzs7Ozs7QUFNQWhYLHVCQUFtQixFQUFFLDZCQUFTdUssSUFBVCxFQUFlO0FBQ2hDLFVBQUkwTSxVQUFVLEdBQUcsS0FBS3JQLFdBQUwsR0FBbUIzSixLQUFwQzs7QUFFQSxVQUFJc00sSUFBSSxJQUFJLFNBQVosRUFBdUI7QUFDbkIsZUFBTyxJQUFQO0FBQ0gsT0FGRCxNQUVPLElBQUlBLElBQUksSUFBSSxTQUFSLElBQXFCME0sVUFBVSxJQUFLLEtBQUtILGFBQUwsQ0FBbUIsSUFBbkIsSUFBMkIsQ0FBbkUsRUFBdUU7QUFDMUUsZUFBTyxJQUFQO0FBQ0gsT0FGTSxNQUVBLElBQUl2TSxJQUFJLElBQUksUUFBUixJQUFxQjBNLFVBQVUsSUFBSyxLQUFLSCxhQUFMLENBQW1CLElBQW5CLElBQTJCLENBQTFDLElBQWdERyxVQUFVLEdBQUcsS0FBS0gsYUFBTCxDQUFtQixJQUFuQixDQUF0RixFQUFpSDtBQUNwSCxlQUFPLElBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSXZNLElBQUksSUFBSSxRQUFSLElBQW9CME0sVUFBVSxJQUFJLEtBQUtILGFBQUwsQ0FBbUIsSUFBbkIsQ0FBdEMsRUFBZ0U7QUFDbkUsZUFBTyxJQUFQO0FBQ0gsT0FGTSxNQUVBLElBQUl2TSxJQUFJLElBQUksb0JBQVIsSUFBZ0MwTSxVQUFVLElBQUssS0FBS0gsYUFBTCxDQUFtQixJQUFuQixJQUEyQixDQUE5RSxFQUFrRjtBQUNyRixlQUFPLElBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSXZNLElBQUksSUFBSSxtQkFBUixJQUErQjBNLFVBQVUsSUFBSSxLQUFLSCxhQUFMLENBQW1CLElBQW5CLENBQWpELEVBQTJFO0FBQzlFLGVBQU8sSUFBUDtBQUNILE9BRk0sTUFFQSxJQUFJdk0sSUFBSSxJQUFJLDJCQUFSLElBQXVDME0sVUFBVSxJQUFJLEtBQUtILGFBQUwsQ0FBbUIsSUFBbkIsQ0FBekQsRUFBbUY7QUFDdEYsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsYUFBTyxLQUFQO0FBQ0gsS0F2SUU7O0FBeUlIOzs7OztBQUtBNU4sZUFBVyxFQUFFLHFCQUFTZ08sTUFBVCxFQUFpQjtBQUMxQixhQUFPQSxNQUFNLEdBQUcxRCxJQUFJLENBQUMyRCxLQUFMLENBQVczRCxJQUFJLENBQUM0RCxNQUFMLEtBQWlCLElBQUlqSyxJQUFKLEVBQUQsQ0FBYUMsT0FBYixFQUEzQixDQUFoQjtBQUNILEtBaEpFOztBQWtKSDs7Ozs7QUFLQTBKLGlCQUFhLEVBQUUsdUJBQVN2TSxJQUFULEVBQWU7QUFDMUIsYUFBTzhLLFdBQVcsQ0FBQzlLLElBQUQsQ0FBbEI7QUFDSCxLQXpKRTs7QUEySkg7Ozs7OztBQU1BSCxTQUFLLEVBQUUsZUFBU2lOLEdBQVQsRUFBY0MsSUFBZCxFQUFvQjtBQUN2QixVQUFJQyxLQUFKO0FBRUFELFVBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7O0FBRUEsVUFBSUEsSUFBSSxDQUFDRSxPQUFMLENBQWEsR0FBYixNQUFzQixDQUFDLENBQTNCLEVBQThCO0FBQzFCLGNBQU0sSUFBSUMsS0FBSixDQUFVLG1DQUFWLENBQU47QUFDSDs7QUFFREgsVUFBSSxHQUFHQSxJQUFJLENBQUNYLEtBQUwsQ0FBVyxHQUFYLENBQVA7O0FBRUEsU0FBRztBQUNDLFlBQUlVLEdBQUcsS0FBS2xRLFNBQVosRUFBdUI7QUFDbkIsaUJBQU8sS0FBUDtBQUNIOztBQUVEb1EsYUFBSyxHQUFHRCxJQUFJLENBQUNJLEtBQUwsRUFBUjs7QUFFQSxZQUFJLENBQUNMLEdBQUcsQ0FBQ3pELGNBQUosQ0FBbUIyRCxLQUFuQixDQUFMLEVBQWdDO0FBQzVCLGlCQUFPLEtBQVA7QUFDSDs7QUFFREYsV0FBRyxHQUFHQSxHQUFHLENBQUNFLEtBQUQsQ0FBVDtBQUVILE9BYkQsUUFhU0QsSUFBSSxDQUFDblcsTUFiZDs7QUFlQSxhQUFPLElBQVA7QUFDSCxLQTVMRTs7QUE4TEg7Ozs7O0FBS0F3VyxvQkFBZ0IsRUFBRSwwQkFBUzdaLEVBQVQsRUFBYTtBQUMzQixVQUFJZ1YsSUFBSSxHQUFHcFQsTUFBTSxDQUFDNEMsR0FBUCxDQUFXeEUsRUFBWCxDQUFYO0FBQUEsVUFDSWtELFFBREo7QUFBQSxVQUNjaUYsS0FEZDs7QUFHQSxhQUFPNk0sSUFBSSxJQUFJQSxJQUFJLEtBQUsxUSxRQUF4QixFQUFrQztBQUM5QjtBQUNBO0FBQ0E7QUFDQXBCLGdCQUFRLEdBQUd0QixNQUFNLENBQUNxQixHQUFQLENBQVcrUixJQUFYLEVBQWlCLFVBQWpCLENBQVg7O0FBRUEsWUFBSTlSLFFBQVEsS0FBSyxVQUFiLElBQTJCQSxRQUFRLEtBQUssVUFBeEMsSUFBc0RBLFFBQVEsS0FBSyxPQUF2RSxFQUFnRjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBaUYsZUFBSyxHQUFHaUosUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXK1IsSUFBWCxFQUFpQixTQUFqQixDQUFELENBQWhCOztBQUVBLGNBQUksQ0FBQzVDLEtBQUssQ0FBQ2pLLEtBQUQsQ0FBTixJQUFpQkEsS0FBSyxLQUFLLENBQS9CLEVBQWtDO0FBQzlCLG1CQUFPQSxLQUFQO0FBQ0g7QUFDSjs7QUFFRDZNLFlBQUksR0FBR0EsSUFBSSxDQUFDdEUsVUFBWjtBQUNIOztBQUVELGFBQU8sSUFBUDtBQUNILEtBN05FOztBQStOSDs7Ozs7QUFLQW9KLDRCQUF3QixFQUFFLGtDQUFTOVosRUFBVCxFQUFhO0FBQ25DLFVBQUlrRCxRQUFKOztBQUVBLGFBQU9sRCxFQUFFLElBQUlBLEVBQUUsS0FBS3NFLFFBQXBCLEVBQThCO0FBQzFCcEIsZ0JBQVEsR0FBR3RCLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV2pELEVBQVgsRUFBZSxVQUFmLENBQVg7O0FBRUEsWUFBSWtELFFBQVEsS0FBSyxPQUFqQixFQUEwQjtBQUN0QixpQkFBTyxJQUFQO0FBQ0g7O0FBRURsRCxVQUFFLEdBQUdBLEVBQUUsQ0FBQzBRLFVBQVI7QUFDSDs7QUFFRCxhQUFPLEtBQVA7QUFDSCxLQWxQRTs7QUFvUEg7OztBQUdBcUosU0FBSyxFQUFFLGVBQVNDLFlBQVQsRUFBdUI7QUFDMUIsVUFBSUMsS0FBSyxHQUFHLElBQUk1SyxJQUFKLEdBQVdDLE9BQVgsRUFBWjs7QUFDQSxXQUFLLElBQUlqSCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEdBQXBCLEVBQXlCQSxDQUFDLEVBQTFCLEVBQThCO0FBQzFCLFlBQUssSUFBSWdILElBQUosR0FBV0MsT0FBWCxLQUF1QjJLLEtBQXhCLEdBQWlDRCxZQUFyQyxFQUFtRDtBQUMvQztBQUNIO0FBQ0o7QUFDSixLQTlQRTs7QUFnUUg7Ozs7OztBQU1BRSxnQkFBWSxFQUFFLHNCQUFTQyxHQUFULEVBQWN4RSxHQUFkLEVBQW1CO0FBQzdCLGFBQU9ELElBQUksQ0FBQzJELEtBQUwsQ0FBVzNELElBQUksQ0FBQzRELE1BQUwsTUFBaUIzRCxHQUFHLEdBQUd3RSxHQUFOLEdBQVksQ0FBN0IsQ0FBWCxJQUE4Q0EsR0FBckQ7QUFDSCxLQXhRRTs7QUEwUUg7Ozs7QUFJQUMsb0JBQWdCLEVBQUUsNEJBQVc7QUFDekIsYUFBT25RLE1BQU0sQ0FBQ29RLElBQVAsS0FBZ0JoUixTQUFoQixHQUE0QixJQUE1QixHQUFtQyxLQUExQztBQUNILEtBaFJFO0FBa1JIO0FBRUE7QUFDQTNCLGNBQVUsRUFBRSxvQkFBUzRTLEdBQVQsRUFBYztBQUN0QkEsU0FBRyxHQUFHQSxHQUFHLElBQUksRUFBYjs7QUFFQSxXQUFLLElBQUlqUyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa08sU0FBUyxDQUFDbFQsTUFBOUIsRUFBc0NnRixDQUFDLEVBQXZDLEVBQTJDO0FBQ3ZDLFlBQUlrUixHQUFHLEdBQUdoRCxTQUFTLENBQUNsTyxDQUFELENBQW5CO0FBRUEsWUFBSSxDQUFDa1IsR0FBTCxFQUNJOztBQUVKLGFBQUssSUFBSWdCLEdBQVQsSUFBZ0JoQixHQUFoQixFQUFxQjtBQUNqQixjQUFJQSxHQUFHLENBQUN6RCxjQUFKLENBQW1CeUUsR0FBbkIsQ0FBSixFQUE2QjtBQUN6QixnQkFBSSxRQUFPaEIsR0FBRyxDQUFDZ0IsR0FBRCxDQUFWLE1BQW9CLFFBQXhCLEVBQ0lELEdBQUcsQ0FBQ0MsR0FBRCxDQUFILEdBQVczWSxNQUFNLENBQUM4RixVQUFQLENBQWtCNFMsR0FBRyxDQUFDQyxHQUFELENBQXJCLEVBQTRCaEIsR0FBRyxDQUFDZ0IsR0FBRCxDQUEvQixDQUFYLENBREosS0FHSUQsR0FBRyxDQUFDQyxHQUFELENBQUgsR0FBV2hCLEdBQUcsQ0FBQ2dCLEdBQUQsQ0FBZDtBQUNQO0FBQ0o7QUFDSjs7QUFFRCxhQUFPRCxHQUFQO0FBQ0gsS0F6U0U7QUEyU0g7QUFDQTdXLFVBQU0sRUFBRSxnQkFBUzZXLEdBQVQsRUFBYztBQUNsQkEsU0FBRyxHQUFHQSxHQUFHLElBQUksRUFBYjs7QUFFQSxXQUFLLElBQUlqUyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa08sU0FBUyxDQUFDbFQsTUFBOUIsRUFBc0NnRixDQUFDLEVBQXZDLEVBQTJDO0FBQ3ZDLFlBQUksQ0FBQ2tPLFNBQVMsQ0FBQ2xPLENBQUQsQ0FBZCxFQUNJOztBQUVKLGFBQUssSUFBSWtTLEdBQVQsSUFBZ0JoRSxTQUFTLENBQUNsTyxDQUFELENBQXpCLEVBQThCO0FBQzFCLGNBQUlrTyxTQUFTLENBQUNsTyxDQUFELENBQVQsQ0FBYXlOLGNBQWIsQ0FBNEJ5RSxHQUE1QixDQUFKLEVBQ0lELEdBQUcsQ0FBQ0MsR0FBRCxDQUFILEdBQVdoRSxTQUFTLENBQUNsTyxDQUFELENBQVQsQ0FBYWtTLEdBQWIsQ0FBWDtBQUNQO0FBQ0o7O0FBRUQsYUFBT0QsR0FBUDtBQUNILEtBMVRFO0FBNFRIOVYsT0FBRyxFQUFFLGFBQVNvSixLQUFULEVBQWdCO0FBQ2pCLFVBQUk1TixFQUFKOztBQUVBLFVBQUk0TixLQUFLLEtBQUt0SixRQUFkLEVBQXdCO0FBQ3BCLGVBQU9BLFFBQVA7QUFDSDs7QUFFRCxVQUFJLENBQUMsRUFBRXNKLEtBQUssSUFBSUEsS0FBSyxDQUFDNE0sUUFBTixLQUFtQixDQUE5QixDQUFMLEVBQXVDO0FBQ25DLGVBQU81TSxLQUFQO0FBQ0g7O0FBRUQsVUFBSTVOLEVBQUUsR0FBR3NFLFFBQVEsQ0FBQ21XLGNBQVQsQ0FBd0I3TSxLQUF4QixDQUFULEVBQXlDO0FBQ3JDLGVBQU81TixFQUFQO0FBQ0gsT0FGRCxNQUVPLElBQUlBLEVBQUUsR0FBR3NFLFFBQVEsQ0FBQ29XLG9CQUFULENBQThCOU0sS0FBOUIsQ0FBVCxFQUErQztBQUNsRCxlQUFPNU4sRUFBRSxDQUFDLENBQUQsQ0FBVDtBQUNILE9BRk0sTUFFQSxJQUFJQSxFQUFFLEdBQUdzRSxRQUFRLENBQUNxVyxzQkFBVCxDQUFnQy9NLEtBQWhDLENBQVQsRUFBaUQ7QUFDcEQsZUFBTzVOLEVBQUUsQ0FBQyxDQUFELENBQVQ7QUFDSCxPQUZNLE1BRUE7QUFDSCxlQUFPLElBQVA7QUFDSDtBQUNKLEtBaFZFO0FBa1ZINGEsV0FBTyxFQUFFLGlCQUFTaE4sS0FBVCxFQUFnQjtBQUNyQixVQUFJLENBQUMsRUFBRUEsS0FBSyxJQUFJQSxLQUFLLENBQUM0TSxRQUFOLEtBQW1CLENBQTlCLENBQUwsRUFBdUM7QUFDbkMsZUFBTzVNLEtBQVA7QUFDSDs7QUFFRCxhQUFPdEosUUFBUSxDQUFDbVcsY0FBVCxDQUF3QjdNLEtBQXhCLENBQVA7QUFDSCxLQXhWRTtBQTBWSGlOLFlBQVEsRUFBRSxrQkFBU2pOLEtBQVQsRUFBZ0I7QUFDdEIsVUFBSTVOLEVBQUo7O0FBRUEsVUFBSUEsRUFBRSxHQUFHc0UsUUFBUSxDQUFDb1csb0JBQVQsQ0FBOEI5TSxLQUE5QixDQUFULEVBQStDO0FBQzNDLGVBQU81TixFQUFFLENBQUMsQ0FBRCxDQUFUO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxJQUFQO0FBQ0g7QUFDSixLQWxXRTtBQW9XSDhhLGNBQVUsRUFBRSxvQkFBU2xOLEtBQVQsRUFBZ0I7QUFDeEIsVUFBSTVOLEVBQUo7O0FBRUEsVUFBSUEsRUFBRSxHQUFHc0UsUUFBUSxDQUFDcVcsc0JBQVQsQ0FBZ0MvTSxLQUFoQyxDQUFULEVBQWlEO0FBQzdDLGVBQU81TixFQUFFLENBQUMsQ0FBRCxDQUFUO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxJQUFQO0FBQ0g7QUFDSixLQTVXRTs7QUE4V0g7Ozs7OztBQU1Bd00sY0FBVSxFQUFFLG9CQUFTeE0sRUFBVCxFQUFhcUUsT0FBYixFQUFzQjtBQUM5QixVQUFJLENBQUNyRSxFQUFMLEVBQVM7QUFDTDtBQUNIOztBQUVELFVBQUkrYSxVQUFVLEdBQUcxVyxPQUFPLENBQUN3VSxLQUFSLENBQWMsR0FBZCxDQUFqQjs7QUFFQSxXQUFLLElBQUl4USxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMFMsVUFBVSxDQUFDMVgsTUFBL0IsRUFBdUNnRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLFlBQUl6RyxNQUFNLENBQUM0TCxRQUFQLENBQWdCeE4sRUFBaEIsRUFBb0I0QixNQUFNLENBQUNvWixJQUFQLENBQVlELFVBQVUsQ0FBQzFTLENBQUQsQ0FBdEIsQ0FBcEIsS0FBbUQsS0FBdkQsRUFBOEQ7QUFDMUQsaUJBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBRUQsYUFBTyxJQUFQO0FBQ0gsS0FsWUU7QUFvWUhtRixZQUFRLEVBQUUsa0JBQVN4TixFQUFULEVBQWFpYixTQUFiLEVBQXdCO0FBQzlCLFVBQUksQ0FBQ2piLEVBQUwsRUFBUztBQUNMO0FBQ0g7O0FBRUQsYUFBT0EsRUFBRSxDQUFDa2IsU0FBSCxHQUFlbGIsRUFBRSxDQUFDa2IsU0FBSCxDQUFhbk0sUUFBYixDQUFzQmtNLFNBQXRCLENBQWYsR0FBa0QsSUFBSUUsTUFBSixDQUFXLFFBQVFGLFNBQVIsR0FBb0IsS0FBL0IsRUFBc0NHLElBQXRDLENBQTJDcGIsRUFBRSxDQUFDaWIsU0FBOUMsQ0FBekQ7QUFDSCxLQTFZRTtBQTRZSDdaLFlBQVEsRUFBRSxrQkFBU3BCLEVBQVQsRUFBYWliLFNBQWIsRUFBd0I7QUFDOUIsVUFBSSxDQUFDamIsRUFBRCxJQUFPLE9BQU9pYixTQUFQLEtBQXFCLFdBQWhDLEVBQTZDO0FBQ3pDO0FBQ0g7O0FBRUQsVUFBSUksVUFBVSxHQUFHSixTQUFTLENBQUNwQyxLQUFWLENBQWdCLEdBQWhCLENBQWpCOztBQUVBLFVBQUk3WSxFQUFFLENBQUNrYixTQUFQLEVBQWtCO0FBQ2QsYUFBSyxJQUFJN1MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dULFVBQVUsQ0FBQ2hZLE1BQS9CLEVBQXVDZ0YsQ0FBQyxFQUF4QyxFQUE0QztBQUN4QyxjQUFJZ1QsVUFBVSxDQUFDaFQsQ0FBRCxDQUFWLElBQWlCZ1QsVUFBVSxDQUFDaFQsQ0FBRCxDQUFWLENBQWNoRixNQUFkLEdBQXVCLENBQTVDLEVBQStDO0FBQzNDckQsY0FBRSxDQUFDa2IsU0FBSCxDQUFhSSxHQUFiLENBQWlCMVosTUFBTSxDQUFDb1osSUFBUCxDQUFZSyxVQUFVLENBQUNoVCxDQUFELENBQXRCLENBQWpCO0FBQ0g7QUFDSjtBQUNKLE9BTkQsTUFNTyxJQUFJLENBQUN6RyxNQUFNLENBQUM0TCxRQUFQLENBQWdCeE4sRUFBaEIsRUFBb0JpYixTQUFwQixDQUFMLEVBQXFDO0FBQ3hDLGFBQUssSUFBSTdGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpRyxVQUFVLENBQUNoWSxNQUEvQixFQUF1QytSLENBQUMsRUFBeEMsRUFBNEM7QUFDeENwVixZQUFFLENBQUNpYixTQUFILElBQWdCLE1BQU1yWixNQUFNLENBQUNvWixJQUFQLENBQVlLLFVBQVUsQ0FBQ2pHLENBQUQsQ0FBdEIsQ0FBdEI7QUFDSDtBQUNKO0FBQ0osS0E5WkU7QUFnYUhwUCxlQUFXLEVBQUUscUJBQVNoRyxFQUFULEVBQWFpYixTQUFiLEVBQXdCO0FBQ25DLFVBQUksQ0FBQ2piLEVBQUQsSUFBTyxPQUFPaWIsU0FBUCxLQUFxQixXQUFoQyxFQUE2QztBQUN2QztBQUNIOztBQUVELFVBQUlJLFVBQVUsR0FBR0osU0FBUyxDQUFDcEMsS0FBVixDQUFnQixHQUFoQixDQUFqQjs7QUFFQSxVQUFJN1ksRUFBRSxDQUFDa2IsU0FBUCxFQUFrQjtBQUNkLGFBQUssSUFBSTdTLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnVCxVQUFVLENBQUNoWSxNQUEvQixFQUF1Q2dGLENBQUMsRUFBeEMsRUFBNEM7QUFDeENySSxZQUFFLENBQUNrYixTQUFILENBQWF0VyxNQUFiLENBQW9CaEQsTUFBTSxDQUFDb1osSUFBUCxDQUFZSyxVQUFVLENBQUNoVCxDQUFELENBQXRCLENBQXBCO0FBQ0g7QUFDSixPQUpELE1BSU8sSUFBSXpHLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0J4TixFQUFoQixFQUFvQmliLFNBQXBCLENBQUosRUFBb0M7QUFDdkMsYUFBSyxJQUFJN0YsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lHLFVBQVUsQ0FBQ2hZLE1BQS9CLEVBQXVDK1IsQ0FBQyxFQUF4QyxFQUE0QztBQUN4Q3BWLFlBQUUsQ0FBQ2liLFNBQUgsR0FBZWpiLEVBQUUsQ0FBQ2liLFNBQUgsQ0FBYU0sT0FBYixDQUFxQixJQUFJSixNQUFKLENBQVcsUUFBUXZaLE1BQU0sQ0FBQ29aLElBQVAsQ0FBWUssVUFBVSxDQUFDakcsQ0FBRCxDQUF0QixDQUFSLEdBQXFDLEtBQWhELEVBQXVELEdBQXZELENBQXJCLEVBQWtGLEVBQWxGLENBQWY7QUFDSDtBQUNKO0FBQ0osS0FoYkU7QUFrYkhvRyxzQkFBa0IsRUFBRSw0QkFBU3hiLEVBQVQsRUFBYXliLFNBQWIsRUFBd0J2YixJQUF4QixFQUE4QjtBQUM5QyxVQUFJb0ksS0FBSjs7QUFDQSxVQUFJMkIsTUFBTSxDQUFDeVIsV0FBWCxFQUF3QjtBQUNwQnBULGFBQUssR0FBRyxJQUFJb1QsV0FBSixDQUFnQkQsU0FBaEIsRUFBMkI7QUFDL0JFLGdCQUFNLEVBQUV6YjtBQUR1QixTQUEzQixDQUFSO0FBR0gsT0FKRCxNQUlPO0FBQ0hvSSxhQUFLLEdBQUdoRSxRQUFRLENBQUMrVCxXQUFULENBQXFCLGFBQXJCLENBQVI7QUFDQS9QLGFBQUssQ0FBQ3NULGVBQU4sQ0FBc0JILFNBQXRCLEVBQWlDLElBQWpDLEVBQXVDLElBQXZDLEVBQTZDdmIsSUFBN0M7QUFDSDs7QUFFREYsUUFBRSxDQUFDbVksYUFBSCxDQUFpQjdQLEtBQWpCO0FBQ0gsS0E5YkU7QUFnY0h1VCxnQkFBWSxFQUFFLHNCQUFTQyxJQUFULEVBQWVMLFNBQWYsRUFBMEI7QUFDcEM7QUFDQSxVQUFJTSxHQUFKOztBQUNBLFVBQUlELElBQUksQ0FBQ0UsYUFBVCxFQUF3QjtBQUNwQkQsV0FBRyxHQUFHRCxJQUFJLENBQUNFLGFBQVg7QUFDSCxPQUZELE1BRU8sSUFBSUYsSUFBSSxDQUFDdEIsUUFBTCxJQUFpQixDQUFyQixFQUF3QjtBQUMzQjtBQUNBdUIsV0FBRyxHQUFHRCxJQUFOO0FBQ0gsT0FITSxNQUdBO0FBQ0gsY0FBTSxJQUFJbkMsS0FBSixDQUFVLHVDQUF1Q21DLElBQUksQ0FBQ3JLLEVBQXRELENBQU47QUFDSDs7QUFFRCxVQUFJcUssSUFBSSxDQUFDM0QsYUFBVCxFQUF3QjtBQUNwQjtBQUNBLFlBQUk4RCxVQUFVLEdBQUcsRUFBakIsQ0FGb0IsQ0FJcEI7QUFDQTtBQUNBOztBQUNBLGdCQUFRUixTQUFSO0FBQ0EsZUFBSyxPQUFMLENBREEsQ0FDYzs7QUFDZCxlQUFLLFlBQUw7QUFDQSxlQUFLLFlBQUw7QUFDQSxlQUFLLFdBQUw7QUFDQSxlQUFLLFNBQUw7QUFDSVEsc0JBQVUsR0FBRyxhQUFiO0FBQ0E7O0FBRUosZUFBSyxPQUFMO0FBQ0EsZUFBSyxRQUFMO0FBQ0EsZUFBSyxNQUFMO0FBQ0EsZUFBSyxRQUFMO0FBQ0lBLHNCQUFVLEdBQUcsWUFBYjtBQUNBOztBQUVKO0FBQ0ksa0JBQU0sd0RBQXdEUixTQUF4RCxHQUFvRSxJQUExRTtBQUNBO0FBbEJKOztBQW9CQSxZQUFJblQsS0FBSyxHQUFHeVQsR0FBRyxDQUFDMUQsV0FBSixDQUFnQjRELFVBQWhCLENBQVo7QUFFQSxZQUFJQyxPQUFPLEdBQUdULFNBQVMsSUFBSSxRQUFiLEdBQXdCLEtBQXhCLEdBQWdDLElBQTlDO0FBQ0FuVCxhQUFLLENBQUM2VCxTQUFOLENBQWdCVixTQUFoQixFQUEyQlMsT0FBM0IsRUFBb0MsSUFBcEMsRUE5Qm9CLENBOEJ1Qjs7QUFFM0M1VCxhQUFLLENBQUM4VCxTQUFOLEdBQWtCLElBQWxCLENBaENvQixDQWdDSTtBQUN4Qjs7QUFDQU4sWUFBSSxDQUFDM0QsYUFBTCxDQUFtQjdQLEtBQW5CLEVBQTBCLElBQTFCO0FBQ0gsT0FuQ0QsTUFtQ08sSUFBSXdULElBQUksQ0FBQ08sU0FBVCxFQUFvQjtBQUN2QjtBQUNBLFlBQUkvVCxLQUFLLEdBQUd5VCxHQUFHLENBQUNPLGlCQUFKLEVBQVo7QUFDQWhVLGFBQUssQ0FBQzhULFNBQU4sR0FBa0IsSUFBbEIsQ0FIdUIsQ0FHQzs7QUFDeEJOLFlBQUksQ0FBQ08sU0FBTCxDQUFlLE9BQU9aLFNBQXRCLEVBQWlDblQsS0FBakM7QUFDSDtBQUNKLEtBcmZFO0FBdWZIaVUsU0FBSyxFQUFFLGVBQVVDLEdBQVYsRUFBZTtBQUNsQkEsU0FBRyxHQUFHNWEsTUFBTSxDQUFDNEMsR0FBUCxDQUFXZ1ksR0FBWCxDQUFOO0FBQ0EsVUFBSUMsQ0FBQyxHQUFHRCxHQUFHLENBQUM5TCxVQUFKLENBQWV2QyxRQUF2QjtBQUFBLFVBQWlDOUYsQ0FBQyxHQUFHLENBQXJDOztBQUNBLGFBQU1BLENBQUMsR0FBR29VLENBQUMsQ0FBQ3BaLE1BQVosRUFBb0JnRixDQUFDLEVBQXJCO0FBQ0ksWUFBSW9VLENBQUMsQ0FBQ3BVLENBQUQsQ0FBRCxJQUFRbVUsR0FBWixFQUFrQixPQUFPblUsQ0FBUDtBQUR0QjtBQUVILEtBNWZFO0FBOGZIMlMsUUFBSSxFQUFFLGNBQVMwQixNQUFULEVBQWlCO0FBQ25CLGFBQU9BLE1BQU0sQ0FBQzFCLElBQVAsRUFBUDtBQUNILEtBaGdCRTtBQWtnQkgyQixrQkFBYyxFQUFFLHdCQUFTL1osQ0FBVCxFQUFZO0FBQ3hCLFVBQUlBLENBQUMsQ0FBQ2dhLGFBQUYsQ0FBZ0JDLE9BQWhCLENBQXdCQyxTQUE1QixFQUF1QztBQUNuQyxlQUFPLElBQVA7QUFDSCxPQUZELE1BRU87QUFDSGxhLFNBQUMsQ0FBQ2dhLGFBQUYsQ0FBZ0JDLE9BQWhCLENBQXdCQyxTQUF4QixHQUFvQyxJQUFwQztBQUVBLGVBQU8sS0FBUDtBQUNIO0FBQ0osS0ExZ0JFO0FBNGdCSGxZLFVBQU0sRUFBRSxnQkFBUzVFLEVBQVQsRUFBYTtBQUNqQixVQUFJQSxFQUFFLElBQUlBLEVBQUUsQ0FBQzBRLFVBQWIsRUFBeUI7QUFDckIxUSxVQUFFLENBQUMwUSxVQUFILENBQWN1RSxXQUFkLENBQTBCalYsRUFBMUI7QUFDSDtBQUNKLEtBaGhCRTtBQWtoQkg4QyxRQUFJLEVBQUUsY0FBU2lhLE1BQVQsRUFBaUJuUCxLQUFqQixFQUF3QjtBQUMxQm1QLFlBQU0sR0FBR25iLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV3VZLE1BQVgsQ0FBVDs7QUFDQSxVQUFJQSxNQUFKLEVBQVk7QUFDUixlQUFPQSxNQUFNLENBQUNDLGFBQVAsQ0FBcUJwUCxLQUFyQixDQUFQO0FBQ0g7QUFDSixLQXZoQkU7QUF5aEJIaEIsV0FBTyxFQUFFLGlCQUFTbVEsTUFBVCxFQUFpQm5QLEtBQWpCLEVBQXdCO0FBQzdCbVAsWUFBTSxHQUFHbmIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXdVksTUFBWCxDQUFUOztBQUNBLFVBQUlBLE1BQUosRUFBWTtBQUNSLGVBQU9BLE1BQU0sQ0FBQ3BQLGdCQUFQLENBQXdCQyxLQUF4QixDQUFQO0FBQ0g7QUFDSixLQTloQkU7QUFnaUJIMkQsZUFBVyxFQUFFLHFCQUFTdlIsRUFBVCxFQUFhaWQsYUFBYixFQUE0QjtBQUNyQyxhQUFPQSxhQUFhLENBQUN2TSxVQUFkLENBQXlCcUcsWUFBekIsQ0FBc0MvVyxFQUF0QyxFQUEwQ2lkLGFBQWEsQ0FBQ0MsV0FBeEQsQ0FBUDtBQUNILEtBbGlCRTtBQW9pQkgxTixXQUFPLEVBQUUsaUJBQVN3RixJQUFULEVBQWVtSSxRQUFmLEVBQXlCO0FBQzlCO0FBQ0EsVUFBSSxDQUFDNUksT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUF2QixFQUFnQztBQUM1QkYsZUFBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixHQUNJRixPQUFPLENBQUNDLFNBQVIsQ0FBa0I0SSxlQUFsQixJQUNBN0ksT0FBTyxDQUFDQyxTQUFSLENBQWtCNkksa0JBRGxCLElBRUE5SSxPQUFPLENBQUNDLFNBQVIsQ0FBa0JFLGlCQUZsQixJQUdBSCxPQUFPLENBQUNDLFNBQVIsQ0FBa0I4SSxnQkFIbEIsSUFJQS9JLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcscUJBSmxCLElBS0EsVUFBU0MsQ0FBVCxFQUFZO0FBQ1IsY0FBSUgsT0FBTyxHQUFHLENBQUMsS0FBS25RLFFBQUwsSUFBaUIsS0FBSzBYLGFBQXZCLEVBQXNDck8sZ0JBQXRDLENBQXVEaUgsQ0FBdkQsQ0FBZDtBQUFBLGNBQ0l2TSxDQUFDLEdBQUdvTSxPQUFPLENBQUNwUixNQURoQjs7QUFFQSxpQkFBTyxFQUFFZ0YsQ0FBRixJQUFPLENBQVAsSUFBWW9NLE9BQU8sQ0FBQzFILElBQVIsQ0FBYTFFLENBQWIsTUFBb0IsSUFBdkMsRUFBNkMsQ0FBRTs7QUFDL0MsaUJBQU9BLENBQUMsR0FBRyxDQUFDLENBQVo7QUFDSCxTQVhMO0FBWUgsT0FmNkIsQ0FpQjlCOzs7QUFDQSxVQUFJbUgsT0FBTyxHQUFHLEVBQWQsQ0FsQjhCLENBb0I5Qjs7QUFDQSxhQUFRd0YsSUFBSSxJQUFJQSxJQUFJLEtBQUsxUSxRQUF6QixFQUFtQzBRLElBQUksR0FBR0EsSUFBSSxDQUFDdEUsVUFBL0MsRUFBNEQ7QUFDeEQsWUFBSXlNLFFBQUosRUFBYztBQUNWLGNBQUluSSxJQUFJLENBQUNQLE9BQUwsQ0FBYTBJLFFBQWIsQ0FBSixFQUE0QjtBQUN4QjNOLG1CQUFPLENBQUM3RyxJQUFSLENBQWFxTSxJQUFiO0FBQ0g7O0FBQ0Q7QUFDSDs7QUFDRHhGLGVBQU8sQ0FBQzdHLElBQVIsQ0FBYXFNLElBQWI7QUFDSCxPQTdCNkIsQ0ErQjlCOzs7QUFDQSxhQUFPeEYsT0FBUDtBQUNILEtBcmtCRTtBQXVrQkhyQixZQUFRLEVBQUUsa0JBQVNuTyxFQUFULEVBQWFtZCxRQUFiLEVBQXVCSSxHQUF2QixFQUE0QjtBQUNsQyxVQUFJLENBQUN2ZCxFQUFELElBQU8sQ0FBQ0EsRUFBRSxDQUFDd2QsVUFBZixFQUEyQjtBQUN2QjtBQUNIOztBQUVELFVBQUl2VixNQUFNLEdBQUcsRUFBYjtBQUFBLFVBQ0lJLENBQUMsR0FBRyxDQURSO0FBQUEsVUFFSW9WLENBQUMsR0FBR3pkLEVBQUUsQ0FBQ3dkLFVBQUgsQ0FBY25hLE1BRnRCOztBQUlBLFdBQUssSUFBSWdGLENBQVQsRUFBWUEsQ0FBQyxHQUFHb1YsQ0FBaEIsRUFBbUIsRUFBRXBWLENBQXJCLEVBQXdCO0FBQ3BCLFlBQUlySSxFQUFFLENBQUN3ZCxVQUFILENBQWNuVixDQUFkLEVBQWlCbVMsUUFBakIsSUFBNkIsQ0FBN0IsSUFBa0M1WSxNQUFNLENBQUM2UyxPQUFQLENBQWV6VSxFQUFFLENBQUN3ZCxVQUFILENBQWNuVixDQUFkLENBQWYsRUFBaUM4VSxRQUFqQyxFQUEyQ0ksR0FBM0MsQ0FBdEMsRUFBdUY7QUFDbkZ0VixnQkFBTSxDQUFDVSxJQUFQLENBQVkzSSxFQUFFLENBQUN3ZCxVQUFILENBQWNuVixDQUFkLENBQVo7QUFDSDtBQUNKOztBQUVELGFBQU9KLE1BQVA7QUFDSCxLQXZsQkU7QUF5bEJINkYsU0FBSyxFQUFFLGVBQVM5TixFQUFULEVBQWFtZCxRQUFiLEVBQXVCSSxHQUF2QixFQUE0QjtBQUMvQixVQUFJcFAsUUFBUSxHQUFHdk0sTUFBTSxDQUFDdU0sUUFBUCxDQUFnQm5PLEVBQWhCLEVBQW9CbWQsUUFBcEIsRUFBOEJJLEdBQTlCLENBQWY7QUFFQSxhQUFPcFAsUUFBUSxHQUFHQSxRQUFRLENBQUMsQ0FBRCxDQUFYLEdBQWlCLElBQWhDO0FBQ0gsS0E3bEJFO0FBK2xCSHNHLFdBQU8sRUFBRSxpQkFBU3pVLEVBQVQsRUFBYW1kLFFBQWIsRUFBdUJJLEdBQXZCLEVBQTRCO0FBQ2pDLFVBQUlHLENBQUMsR0FBR25KLE9BQU8sQ0FBQ0MsU0FBaEI7O0FBQ0EsVUFBSW1KLENBQUMsR0FBR0QsQ0FBQyxDQUFDakosT0FBRixJQUFhaUosQ0FBQyxDQUFDL0kscUJBQWYsSUFBd0MrSSxDQUFDLENBQUNMLGtCQUExQyxJQUFnRUssQ0FBQyxDQUFDaEosaUJBQWxFLElBQXVGLFVBQVNFLENBQVQsRUFBWTtBQUN2RyxlQUFPLEdBQUc4RSxPQUFILENBQVdoUixJQUFYLENBQWdCcEUsUUFBUSxDQUFDcUosZ0JBQVQsQ0FBMEJpSCxDQUExQixDQUFoQixFQUE4QyxJQUE5QyxNQUF3RCxDQUFDLENBQWhFO0FBQ0gsT0FGRDs7QUFJQSxVQUFJNVUsRUFBRSxJQUFJQSxFQUFFLENBQUM0ZCxPQUFiLEVBQXNCO0FBQ2xCLGVBQU9ELENBQUMsQ0FBQ2pWLElBQUYsQ0FBTzFJLEVBQVAsRUFBV21kLFFBQVgsQ0FBUDtBQUNILE9BRkQsTUFFTztBQUNILGVBQU8sS0FBUDtBQUNIO0FBQ0osS0ExbUJFO0FBNG1CSGpkLFFBQUksRUFBRSxjQUFTMkcsT0FBVCxFQUFrQjtBQUNwQkEsYUFBTyxHQUFHakYsTUFBTSxDQUFDNEMsR0FBUCxDQUFXcUMsT0FBWCxDQUFWO0FBRUEsYUFBTztBQUNITyxXQUFHLEVBQUUsYUFBU2pCLElBQVQsRUFBZWpHLElBQWYsRUFBcUI7QUFDdEIsY0FBSTJHLE9BQU8sS0FBS3dDLFNBQWhCLEVBQTJCO0FBQ3ZCO0FBQ0g7O0FBRUQsY0FBSXhDLE9BQU8sQ0FBQ2dYLGFBQVIsS0FBMEJ4VSxTQUE5QixFQUF5QztBQUNyQ1ksa0JBQU0sQ0FBQ21OLHdCQUFQO0FBQ0F2USxtQkFBTyxDQUFDZ1gsYUFBUixHQUF3QjVULE1BQU0sQ0FBQ21OLHdCQUEvQjtBQUNIOztBQUVELGNBQUluTixNQUFNLENBQUNrTixzQkFBUCxDQUE4QnRRLE9BQU8sQ0FBQ2dYLGFBQXRDLE1BQXlEeFUsU0FBN0QsRUFBd0U7QUFDcEVZLGtCQUFNLENBQUNrTixzQkFBUCxDQUE4QnRRLE9BQU8sQ0FBQ2dYLGFBQXRDLElBQXVELEVBQXZEO0FBQ0g7O0FBRUQ1VCxnQkFBTSxDQUFDa04sc0JBQVAsQ0FBOEJ0USxPQUFPLENBQUNnWCxhQUF0QyxFQUFxRDFYLElBQXJELElBQTZEakcsSUFBN0Q7QUFDSCxTQWhCRTtBQWtCSHNFLFdBQUcsRUFBRSxhQUFTMkIsSUFBVCxFQUFlO0FBQ2hCLGNBQUlVLE9BQU8sS0FBS3dDLFNBQWhCLEVBQTJCO0FBQ3ZCO0FBQ0g7O0FBRUQsY0FBSXhDLE9BQU8sQ0FBQ2dYLGFBQVIsS0FBMEJ4VSxTQUE5QixFQUF5QztBQUNyQyxtQkFBTyxJQUFQO0FBQ0g7O0FBRUQsaUJBQU8sS0FBS25DLEdBQUwsQ0FBU2YsSUFBVCxJQUFpQjhELE1BQU0sQ0FBQ2tOLHNCQUFQLENBQThCdFEsT0FBTyxDQUFDZ1gsYUFBdEMsRUFBcUQxWCxJQUFyRCxDQUFqQixHQUE4RSxJQUFyRjtBQUNILFNBNUJFO0FBOEJIZSxXQUFHLEVBQUUsYUFBU2YsSUFBVCxFQUFlO0FBQ2hCLGNBQUlVLE9BQU8sS0FBS3dDLFNBQWhCLEVBQTJCO0FBQ3ZCLG1CQUFPLEtBQVA7QUFDSDs7QUFFRCxjQUFJeEMsT0FBTyxDQUFDZ1gsYUFBUixLQUEwQnhVLFNBQTlCLEVBQXlDO0FBQ3JDLG1CQUFPLEtBQVA7QUFDSDs7QUFFRCxpQkFBUVksTUFBTSxDQUFDa04sc0JBQVAsQ0FBOEJ0USxPQUFPLENBQUNnWCxhQUF0QyxLQUF3RDVULE1BQU0sQ0FBQ2tOLHNCQUFQLENBQThCdFEsT0FBTyxDQUFDZ1gsYUFBdEMsRUFBcUQxWCxJQUFyRCxDQUF6RCxHQUF1SCxJQUF2SCxHQUE4SCxLQUFySTtBQUNILFNBeENFO0FBMENIdkIsY0FBTSxFQUFFLGdCQUFTdUIsSUFBVCxFQUFlO0FBQ25CLGNBQUlVLE9BQU8sSUFBSSxLQUFLSyxHQUFMLENBQVNmLElBQVQsQ0FBZixFQUErQjtBQUMzQixtQkFBTzhELE1BQU0sQ0FBQ2tOLHNCQUFQLENBQThCdFEsT0FBTyxDQUFDZ1gsYUFBdEMsRUFBcUQxWCxJQUFyRCxDQUFQO0FBQ0g7QUFDSjtBQTlDRSxPQUFQO0FBZ0RILEtBL3BCRTtBQWlxQkgyWCxjQUFVLEVBQUUsb0JBQVM5ZCxFQUFULEVBQWErZCxNQUFiLEVBQXFCO0FBQzdCLFVBQUk1ZCxLQUFKOztBQUVBLFVBQUk0ZCxNQUFNLEtBQUssSUFBZixFQUFxQjtBQUNqQjVkLGFBQUssR0FBRzZkLFVBQVUsQ0FBQ2hlLEVBQUUsQ0FBQ2llLFdBQUosQ0FBbEI7QUFDQTlkLGFBQUssSUFBSTZkLFVBQVUsQ0FBQ3BjLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV2pELEVBQVgsRUFBZSxhQUFmLENBQUQsQ0FBVixHQUE0Q2dlLFVBQVUsQ0FBQ3BjLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV2pELEVBQVgsRUFBZSxjQUFmLENBQUQsQ0FBL0Q7QUFFQSxlQUFPZ2UsVUFBVSxDQUFDN2QsS0FBRCxDQUFqQjtBQUNILE9BTEQsTUFLTztBQUNIQSxhQUFLLEdBQUc2ZCxVQUFVLENBQUNoZSxFQUFFLENBQUNpZSxXQUFKLENBQWxCO0FBRUEsZUFBTzlkLEtBQVA7QUFDSDtBQUNKLEtBOXFCRTtBQWdyQkhvSixVQUFNLEVBQUUsZ0JBQVN5TCxJQUFULEVBQWU7QUFDbkIsVUFBSWtKLElBQUosRUFBVUMsR0FBVjtBQUNBbkosVUFBSSxHQUFHcFQsTUFBTSxDQUFDNEMsR0FBUCxDQUFXd1EsSUFBWCxDQUFQOztBQUVBLFVBQUssQ0FBQ0EsSUFBTixFQUFhO0FBQ1Q7QUFDSCxPQU5rQixDQVFuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsVUFBSyxDQUFDQSxJQUFJLENBQUNvSixjQUFMLEdBQXNCL2EsTUFBNUIsRUFBcUM7QUFDakMsZUFBTztBQUFFeUIsYUFBRyxFQUFFLENBQVA7QUFBVUMsY0FBSSxFQUFFO0FBQWhCLFNBQVA7QUFDSCxPQWZrQixDQWlCbkI7OztBQUNBbVosVUFBSSxHQUFHbEosSUFBSSxDQUFDcUoscUJBQUwsRUFBUDtBQUNBRixTQUFHLEdBQUduSixJQUFJLENBQUNnSCxhQUFMLENBQW1Cc0MsV0FBekI7QUFFQSxhQUFPO0FBQ0h4WixXQUFHLEVBQUVvWixJQUFJLENBQUNwWixHQUFMLEdBQVdxWixHQUFHLENBQUNuSyxXQURqQjtBQUVIalAsWUFBSSxFQUFFbVosSUFBSSxDQUFDblosSUFBTCxHQUFZb1osR0FBRyxDQUFDSTtBQUZuQixPQUFQO0FBSUgsS0F6c0JFO0FBMnNCSHRjLFVBQU0sRUFBRSxnQkFBU2pDLEVBQVQsRUFBYTtBQUNqQixhQUFPNEIsTUFBTSxDQUFDcUIsR0FBUCxDQUFXakQsRUFBWCxFQUFlLFFBQWYsQ0FBUDtBQUNILEtBN3NCRTtBQStzQkh3ZSxXQUFPLEVBQUUsaUJBQVN4ZSxFQUFULEVBQWE7QUFDbEIsYUFBTyxFQUFFQSxFQUFFLENBQUNpZSxXQUFILEtBQW1CLENBQW5CLElBQXdCamUsRUFBRSxDQUFDeWUsWUFBSCxLQUFvQixDQUE5QyxDQUFQO0FBQ0gsS0FqdEJFO0FBbXRCSDFZLFFBQUksRUFBRSxjQUFTL0YsRUFBVCxFQUFhbUcsSUFBYixFQUFtQmdDLEtBQW5CLEVBQTBCO0FBQzVCbkksUUFBRSxHQUFHNEIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXeEUsRUFBWCxDQUFMOztBQUVBLFVBQUlBLEVBQUUsSUFBSXFKLFNBQVYsRUFBcUI7QUFDakI7QUFDSDs7QUFFRCxVQUFJbEIsS0FBSyxLQUFLa0IsU0FBZCxFQUF5QjtBQUNyQnJKLFVBQUUsQ0FBQ3VOLFlBQUgsQ0FBZ0JwSCxJQUFoQixFQUFzQmdDLEtBQXRCO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBT25JLEVBQUUsQ0FBQ2dOLFlBQUgsQ0FBZ0I3RyxJQUFoQixDQUFQO0FBQ0g7QUFDSixLQS90QkU7QUFpdUJIa0csV0FBTyxFQUFFLGlCQUFTck0sRUFBVCxFQUFhbUcsSUFBYixFQUFtQjtBQUN4Qm5HLFFBQUUsR0FBRzRCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV3hFLEVBQVgsQ0FBTDs7QUFFQSxVQUFJQSxFQUFFLElBQUlxSixTQUFWLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRUQsYUFBT3JKLEVBQUUsQ0FBQ2dOLFlBQUgsQ0FBZ0I3RyxJQUFoQixJQUF3QixJQUF4QixHQUErQixLQUF0QztBQUNILEtBenVCRTtBQTJ1QkhGLGNBQVUsRUFBRSxvQkFBU2pHLEVBQVQsRUFBYW1HLElBQWIsRUFBbUI7QUFDM0JuRyxRQUFFLEdBQUc0QixNQUFNLENBQUM0QyxHQUFQLENBQVd4RSxFQUFYLENBQUw7O0FBRUEsVUFBSUEsRUFBRSxJQUFJcUosU0FBVixFQUFxQjtBQUNqQjtBQUNIOztBQUVEckosUUFBRSxDQUFDaU4sZUFBSCxDQUFtQjlHLElBQW5CO0FBQ0gsS0FudkJFO0FBcXZCSHVZLFdBQU8sRUFBRSxpQkFBU0MsSUFBVCxFQUFlQyxFQUFmLEVBQW1CQyxRQUFuQixFQUE2QnhULE1BQTdCLEVBQXFDeVQsTUFBckMsRUFBNkNDLElBQTdDLEVBQW1EO0FBQ3hEOzs7O0FBSUEsVUFBSUMsT0FBTyxHQUFHLEVBQWQ7QUFDQSxVQUFJRixNQUFKOztBQUVBRSxhQUFPLENBQUNDLE1BQVIsR0FBaUIsVUFBU0MsQ0FBVCxFQUFZQyxDQUFaLEVBQWUxQyxDQUFmLEVBQWtCdEosQ0FBbEIsRUFBcUI7QUFDbEMsZUFBT3NKLENBQUMsR0FBR3lDLENBQUosR0FBUS9MLENBQVIsR0FBWWdNLENBQW5CO0FBQ0gsT0FGRDs7QUFJQUwsWUFBTSxHQUFHRSxPQUFPLENBQUNDLE1BQWpCLENBWndELENBY3hEOztBQUNBLFVBQUksT0FBT04sSUFBUCxLQUFnQixRQUFoQixJQUNBLE9BQU9DLEVBQVAsS0FBYyxRQURkLElBRUEsT0FBT0MsUUFBUCxLQUFvQixRQUZwQixJQUdBLE9BQU94VCxNQUFQLEtBQWtCLFVBSHRCLEVBR2tDO0FBQzlCO0FBQ0gsT0FwQnVELENBc0J4RDs7O0FBQ0EsVUFBSSxPQUFPMFQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM1QkEsWUFBSSxHQUFHLGdCQUFXLENBQUUsQ0FBcEI7QUFDSCxPQXpCdUQsQ0EyQnhEOzs7QUFDQSxVQUFJSyxHQUFHLEdBQUduVixNQUFNLENBQUNvTCxxQkFBUCxJQUFnQyxVQUFTRSxRQUFULEVBQW1CO0FBQ3pEdEwsY0FBTSxDQUFDb0QsVUFBUCxDQUFrQmtJLFFBQWxCLEVBQTRCLE9BQU8sRUFBbkM7QUFDSCxPQUZELENBNUJ3RCxDQWdDeEQ7OztBQUNBLFVBQUk4SixRQUFRLEdBQUcsS0FBZjtBQUNBLFVBQUlDLE1BQU0sR0FBR1YsRUFBRSxHQUFHRCxJQUFsQjs7QUFFQSxlQUFTWSxJQUFULENBQWNDLFNBQWQsRUFBeUI7QUFDckIsWUFBSXBTLElBQUksR0FBRyxDQUFDb1MsU0FBUyxJQUFJLENBQUMsSUFBSW5RLElBQUosRUFBZixJQUE2QjRLLEtBQXhDOztBQUVBLFlBQUk3TSxJQUFJLElBQUksQ0FBWixFQUFlO0FBQ1gvQixnQkFBTSxDQUFDeVQsTUFBTSxDQUFDMVIsSUFBRCxFQUFPdVIsSUFBUCxFQUFhVyxNQUFiLEVBQXFCVCxRQUFyQixDQUFQLENBQU47QUFDSDs7QUFDRCxZQUFJelIsSUFBSSxJQUFJLENBQVIsSUFBYUEsSUFBSSxJQUFJeVIsUUFBekIsRUFBbUM7QUFDL0J4VCxnQkFBTSxDQUFDdVQsRUFBRCxDQUFOO0FBQ0FHLGNBQUk7QUFDUCxTQUhELE1BR087QUFDSEssYUFBRyxDQUFDRyxJQUFELENBQUg7QUFDSDtBQUNKOztBQUVEbFUsWUFBTSxDQUFDc1QsSUFBRCxDQUFOLENBbER3RCxDQW9EeEQ7O0FBQ0EsVUFBSTFFLEtBQUssR0FBR2hRLE1BQU0sQ0FBQ3dWLFdBQVAsSUFBc0J4VixNQUFNLENBQUN3VixXQUFQLENBQW1CQyxHQUF6QyxHQUErQ3pWLE1BQU0sQ0FBQ3dWLFdBQVAsQ0FBbUJDLEdBQW5CLEVBQS9DLEdBQTBFLENBQUMsSUFBSXJRLElBQUosRUFBdkY7QUFFQStQLFNBQUcsQ0FBQ0csSUFBRCxDQUFIO0FBQ0gsS0E3eUJFO0FBK3lCSEksYUFBUyxFQUFFLG1CQUFTM2YsRUFBVCxFQUFhNGYsSUFBYixFQUFtQkMsS0FBbkIsRUFBMEI7QUFDakM3ZixRQUFFLEdBQUc0QixNQUFNLENBQUM0QyxHQUFQLENBQVd4RSxFQUFYLENBQUw7QUFDQSxVQUFJaUQsR0FBRyxHQUFHLEVBQVY7O0FBRUEsVUFBSWpELEVBQUUsWUFBWThmLFdBQWQsS0FBOEIsS0FBbEMsRUFBeUM7QUFDckM7QUFDSDs7QUFFRCxVQUFJLENBQUM5ZixFQUFFLENBQUNnTixZQUFILENBQWdCLFlBQVk0UyxJQUE1QixDQUFELElBQXNDQyxLQUFLLEtBQUssS0FBcEQsRUFBMkQ7QUFDdkQsWUFBSTFYLEtBQUosQ0FEdUQsQ0FHdkQ7QUFDQTs7QUFDQWxGLFdBQUcsR0FBR2pELEVBQUUsQ0FBQytmLEtBQUgsQ0FBU0MsT0FBZjtBQUNBaGdCLFVBQUUsQ0FBQytmLEtBQUgsQ0FBU0MsT0FBVCxHQUFtQix5REFBbkI7O0FBRUEsWUFBSUosSUFBSSxJQUFJLE9BQVosRUFBcUI7QUFDakJ6WCxlQUFLLEdBQUduSSxFQUFFLENBQUNpZSxXQUFYO0FBQ0gsU0FGRCxNQUVPLElBQUkyQixJQUFJLElBQUksUUFBWixFQUFzQjtBQUN6QnpYLGVBQUssR0FBR25JLEVBQUUsQ0FBQ3llLFlBQVg7QUFDSDs7QUFFRHplLFVBQUUsQ0FBQytmLEtBQUgsQ0FBU0MsT0FBVCxHQUFtQi9jLEdBQW5CLENBZHVELENBZ0J2RDs7QUFDQWpELFVBQUUsQ0FBQ3VOLFlBQUgsQ0FBZ0IsWUFBWXFTLElBQTVCLEVBQWtDelgsS0FBbEM7QUFFQSxlQUFPNlYsVUFBVSxDQUFDN1YsS0FBRCxDQUFqQjtBQUNILE9BcEJELE1Bb0JPO0FBQ0g7QUFDQSxlQUFPNlYsVUFBVSxDQUFDaGUsRUFBRSxDQUFDZ04sWUFBSCxDQUFnQixZQUFZNFMsSUFBNUIsQ0FBRCxDQUFqQjtBQUNIO0FBQ0osS0EvMEJFO0FBaTFCSEssZ0JBQVksRUFBRSxzQkFBU2pnQixFQUFULEVBQWE2ZixLQUFiLEVBQW9CO0FBQzlCLGFBQU9qZSxNQUFNLENBQUMrZCxTQUFQLENBQWlCM2YsRUFBakIsRUFBcUIsUUFBckIsRUFBK0I2ZixLQUEvQixDQUFQO0FBQ0gsS0FuMUJFO0FBcTFCSGxiLGVBQVcsRUFBRSxxQkFBUzNFLEVBQVQsRUFBYTZmLEtBQWIsRUFBb0I7QUFDN0IsYUFBT2plLE1BQU0sQ0FBQytkLFNBQVAsQ0FBaUIzZixFQUFqQixFQUFxQixPQUFyQixFQUE4QjZmLEtBQTlCLENBQVA7QUFDSCxLQXYxQkU7QUF5MUJISyxhQUFTLEVBQUUsbUJBQVNyWixPQUFULEVBQWtCc1osTUFBbEIsRUFBMEI7QUFDakM7QUFDQUEsWUFBTSxHQUFHLFdBQVdBLE1BQXBCO0FBQ0EsYUFBUXRaLE9BQU8sSUFBSW9ELE1BQVgsSUFBcUJwRCxPQUFPLElBQUl2QyxRQUFqQyxHQUNIOGIsSUFBSSxDQUFFRCxNQUFNLElBQUksV0FBWCxHQUEwQixhQUExQixHQUEwQyxhQUEzQyxDQUFKLElBQ0NFLHVCQUF1QixJQUFJL2IsUUFBUSxDQUFDd1EsZUFBVCxDQUF5QnFMLE1BQXpCLENBRDVCLElBRUE3YixRQUFRLENBQUN3QyxJQUFULENBQWNxWixNQUFkLENBSEcsR0FJSHRaLE9BQU8sQ0FBQ3NaLE1BQUQsQ0FKWDtBQUtILEtBajJCRTtBQW0yQkhsZCxPQUFHLEVBQUUsYUFBU2pELEVBQVQsRUFBYXNnQixTQUFiLEVBQXdCblksS0FBeEIsRUFBK0I7QUFDaENuSSxRQUFFLEdBQUc0QixNQUFNLENBQUM0QyxHQUFQLENBQVd4RSxFQUFYLENBQUw7O0FBRUEsVUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDTDtBQUNIOztBQUVELFVBQUltSSxLQUFLLEtBQUtrQixTQUFkLEVBQXlCO0FBQ3JCckosVUFBRSxDQUFDK2YsS0FBSCxDQUFTTyxTQUFULElBQXNCblksS0FBdEI7QUFDSCxPQUZELE1BRU87QUFDSCxZQUFJbVcsV0FBVyxHQUFHLENBQUN0ZSxFQUFFLENBQUNnYyxhQUFILElBQW9CMVgsUUFBckIsRUFBK0JnYSxXQUFqRCxDQURHLENBRUg7O0FBQ0EsWUFBSUEsV0FBVyxJQUFJQSxXQUFXLENBQUNpQyxnQkFBL0IsRUFBaUQ7QUFDN0M7QUFDQTtBQUNBRCxtQkFBUyxHQUFHQSxTQUFTLENBQUMvRSxPQUFWLENBQWtCLFVBQWxCLEVBQThCLEtBQTlCLEVBQXFDaUYsV0FBckMsRUFBWjtBQUNBLGlCQUFPbEMsV0FBVyxDQUFDaUMsZ0JBQVosQ0FBNkJ2Z0IsRUFBN0IsRUFBaUMsSUFBakMsRUFBdUN5Z0IsZ0JBQXZDLENBQXdESCxTQUF4RCxDQUFQO0FBQ0gsU0FMRCxNQUtPLElBQUl0Z0IsRUFBRSxDQUFDMGdCLFlBQVAsRUFBcUI7QUFBRTtBQUMxQjtBQUNBSixtQkFBUyxHQUFHQSxTQUFTLENBQUMvRSxPQUFWLENBQWtCLFNBQWxCLEVBQTZCLFVBQVNvRixHQUFULEVBQWNDLE1BQWQsRUFBc0I7QUFDM0QsbUJBQU9BLE1BQU0sQ0FBQ0MsV0FBUCxFQUFQO0FBQ0gsV0FGVyxDQUFaO0FBR0ExWSxlQUFLLEdBQUduSSxFQUFFLENBQUMwZ0IsWUFBSCxDQUFnQkosU0FBaEIsQ0FBUixDQUx3QixDQU14Qjs7QUFDQSxjQUFJLHNCQUFzQmxGLElBQXRCLENBQTJCalQsS0FBM0IsQ0FBSixFQUF1QztBQUNuQyxtQkFBUSxVQUFTQSxLQUFULEVBQWdCO0FBQ3BCLGtCQUFJMlksT0FBTyxHQUFHOWdCLEVBQUUsQ0FBQytmLEtBQUgsQ0FBU2hiLElBQXZCO0FBQUEsa0JBQ0lnYyxTQUFTLEdBQUcvZ0IsRUFBRSxDQUFDZ2hCLFlBQUgsQ0FBZ0JqYyxJQURoQztBQUVBL0UsZ0JBQUUsQ0FBQ2doQixZQUFILENBQWdCamMsSUFBaEIsR0FBdUIvRSxFQUFFLENBQUMwZ0IsWUFBSCxDQUFnQjNiLElBQXZDO0FBQ0EvRSxnQkFBRSxDQUFDK2YsS0FBSCxDQUFTaGIsSUFBVCxHQUFnQm9ELEtBQUssSUFBSSxDQUF6QjtBQUNBQSxtQkFBSyxHQUFHbkksRUFBRSxDQUFDK2YsS0FBSCxDQUFTa0IsU0FBVCxHQUFxQixJQUE3QjtBQUNBamhCLGdCQUFFLENBQUMrZixLQUFILENBQVNoYixJQUFULEdBQWdCK2IsT0FBaEI7QUFDQTlnQixnQkFBRSxDQUFDZ2hCLFlBQUgsQ0FBZ0JqYyxJQUFoQixHQUF1QmdjLFNBQXZCO0FBQ0EscUJBQU81WSxLQUFQO0FBQ0gsYUFUTSxDQVNKQSxLQVRJLENBQVA7QUFVSDs7QUFDRCxpQkFBT0EsS0FBUDtBQUNIO0FBQ0o7QUFDSixLQTE0QkU7QUE0NEJIK1ksU0FBSyxFQUFFLGVBQVNsaEIsRUFBVCxFQUFhbWhCLEdBQWIsRUFBa0JwVCxLQUFsQixFQUF5QndILFFBQXpCLEVBQW1DNkwsZUFBbkMsRUFBb0Q7QUFDdkQsVUFBSSxDQUFDcGhCLEVBQUQsSUFBUW1oQixHQUFHLElBQUksSUFBUCxJQUFldmYsTUFBTSxDQUFDNGMsT0FBUCxDQUFleGUsRUFBZixNQUF1QixLQUE5QyxJQUF5RG1oQixHQUFHLElBQUksTUFBUCxJQUFpQnZmLE1BQU0sQ0FBQzRjLE9BQVAsQ0FBZXhlLEVBQWYsTUFBdUIsSUFBckcsRUFBNEc7QUFDeEc7QUFDSDs7QUFFRCtOLFdBQUssR0FBSUEsS0FBSyxHQUFHQSxLQUFILEdBQVcsR0FBekI7QUFDQSxVQUFJc1QsVUFBVSxHQUFHemYsTUFBTSxDQUFDcWUsWUFBUCxDQUFvQmpnQixFQUFwQixDQUFqQjtBQUNBLFVBQUlzaEIsY0FBYyxHQUFHLEtBQXJCO0FBQ0EsVUFBSUMsaUJBQWlCLEdBQUcsS0FBeEI7O0FBRUEsVUFBSTNmLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV2pELEVBQVgsRUFBZSxhQUFmLEtBQWlDNEIsTUFBTSxDQUFDMUIsSUFBUCxDQUFZRixFQUFaLEVBQWdCa0gsR0FBaEIsQ0FBb0IsbUJBQXBCLE1BQTZDLElBQWxGLEVBQXdGO0FBQ3BGdEYsY0FBTSxDQUFDMUIsSUFBUCxDQUFZRixFQUFaLEVBQWdCb0gsR0FBaEIsQ0FBb0IsbUJBQXBCLEVBQXlDeEYsTUFBTSxDQUFDcUIsR0FBUCxDQUFXakQsRUFBWCxFQUFlLGFBQWYsQ0FBekM7QUFDSDs7QUFFRCxVQUFJNEIsTUFBTSxDQUFDcUIsR0FBUCxDQUFXakQsRUFBWCxFQUFlLGdCQUFmLEtBQW9DNEIsTUFBTSxDQUFDMUIsSUFBUCxDQUFZRixFQUFaLEVBQWdCa0gsR0FBaEIsQ0FBb0Isc0JBQXBCLE1BQWdELElBQXhGLEVBQThGO0FBQzFGdEYsY0FBTSxDQUFDMUIsSUFBUCxDQUFZRixFQUFaLEVBQWdCb0gsR0FBaEIsQ0FBb0Isc0JBQXBCLEVBQTRDeEYsTUFBTSxDQUFDcUIsR0FBUCxDQUFXakQsRUFBWCxFQUFlLGdCQUFmLENBQTVDO0FBQ0g7O0FBRUQsVUFBSTRCLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWUYsRUFBWixFQUFnQmtILEdBQWhCLENBQW9CLG1CQUFwQixDQUFKLEVBQThDO0FBQzFDb2Esc0JBQWMsR0FBR2xRLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWUYsRUFBWixFQUFnQndFLEdBQWhCLENBQW9CLG1CQUFwQixDQUFELENBQXpCO0FBQ0g7O0FBRUQsVUFBSTVDLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWUYsRUFBWixFQUFnQmtILEdBQWhCLENBQW9CLHNCQUFwQixDQUFKLEVBQWlEO0FBQzdDcWEseUJBQWlCLEdBQUduUSxRQUFRLENBQUN4UCxNQUFNLENBQUMxQixJQUFQLENBQVlGLEVBQVosRUFBZ0J3RSxHQUFoQixDQUFvQixzQkFBcEIsQ0FBRCxDQUE1QjtBQUNIOztBQUVELFVBQUkyYyxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUFFO0FBQ2ZuaEIsVUFBRSxDQUFDK2YsS0FBSCxDQUFTQyxPQUFULEdBQW1CLG1DQUFuQjs7QUFFQSxZQUFJc0IsY0FBSixFQUFvQjtBQUNoQjFmLGdCQUFNLENBQUM4YyxPQUFQLENBQWUsQ0FBZixFQUFrQjRDLGNBQWxCLEVBQWtDdlQsS0FBbEMsRUFBeUMsVUFBUzVGLEtBQVQsRUFBZ0I7QUFDckRuSSxjQUFFLENBQUMrZixLQUFILENBQVN5QixVQUFULEdBQXVCRixjQUFjLEdBQUduWixLQUFsQixHQUEyQixJQUFqRDtBQUNILFdBRkQsRUFFRyxRQUZIO0FBR0g7O0FBRUQsWUFBSW9aLGlCQUFKLEVBQXVCO0FBQ25CM2YsZ0JBQU0sQ0FBQzhjLE9BQVAsQ0FBZSxDQUFmLEVBQWtCNkMsaUJBQWxCLEVBQXFDeFQsS0FBckMsRUFBNEMsVUFBUzVGLEtBQVQsRUFBZ0I7QUFDeERuSSxjQUFFLENBQUMrZixLQUFILENBQVMwQixhQUFULEdBQTBCRixpQkFBaUIsR0FBR3BaLEtBQXJCLEdBQThCLElBQXZEO0FBQ0gsV0FGRCxFQUVHLFFBRkg7QUFHSDs7QUFFRHZHLGNBQU0sQ0FBQzhjLE9BQVAsQ0FBZSxDQUFmLEVBQWtCMkMsVUFBbEIsRUFBOEJ0VCxLQUE5QixFQUFxQyxVQUFTNUYsS0FBVCxFQUFnQjtBQUNqRG5JLFlBQUUsQ0FBQytmLEtBQUgsQ0FBUzlkLE1BQVQsR0FBbUJvZixVQUFVLEdBQUdsWixLQUFkLEdBQXVCLElBQXpDO0FBQ0gsU0FGRCxFQUVHLFFBRkgsRUFFYSxZQUFXO0FBQ3BCb04sa0JBQVE7QUFDUnZWLFlBQUUsQ0FBQytmLEtBQUgsQ0FBUzlkLE1BQVQsR0FBa0IsRUFBbEI7QUFDQWpDLFlBQUUsQ0FBQytmLEtBQUgsQ0FBUzJCLE9BQVQsR0FBbUIsTUFBbkI7QUFDSCxTQU5EO0FBU0gsT0F4QkQsTUF3Qk8sSUFBSVAsR0FBRyxJQUFJLE1BQVgsRUFBbUI7QUFBRTtBQUN4Qm5oQixVQUFFLENBQUMrZixLQUFILENBQVNDLE9BQVQsR0FBbUIsbUNBQW5COztBQUVBLFlBQUlzQixjQUFKLEVBQW9CO0FBQ2hCMWYsZ0JBQU0sQ0FBQzhjLE9BQVAsQ0FBZSxDQUFmLEVBQWtCNEMsY0FBbEIsRUFBa0N2VCxLQUFsQyxFQUF5QyxVQUFTNUYsS0FBVCxFQUFnQjtBQUNyRG5JLGNBQUUsQ0FBQytmLEtBQUgsQ0FBU3lCLFVBQVQsR0FBc0JyWixLQUFLLEdBQUcsSUFBOUI7QUFDSCxXQUZELEVBRUcsUUFGSCxFQUVhLFlBQVc7QUFDcEJuSSxjQUFFLENBQUMrZixLQUFILENBQVN5QixVQUFULEdBQXNCLEVBQXRCO0FBQ0gsV0FKRDtBQUtIOztBQUVELFlBQUlELGlCQUFKLEVBQXVCO0FBQ25CM2YsZ0JBQU0sQ0FBQzhjLE9BQVAsQ0FBZSxDQUFmLEVBQWtCNkMsaUJBQWxCLEVBQXFDeFQsS0FBckMsRUFBNEMsVUFBUzVGLEtBQVQsRUFBZ0I7QUFDeERuSSxjQUFFLENBQUMrZixLQUFILENBQVMwQixhQUFULEdBQXlCdFosS0FBSyxHQUFHLElBQWpDO0FBQ0gsV0FGRCxFQUVHLFFBRkgsRUFFYSxZQUFXO0FBQ3BCbkksY0FBRSxDQUFDK2YsS0FBSCxDQUFTMEIsYUFBVCxHQUF5QixFQUF6QjtBQUNILFdBSkQ7QUFLSDs7QUFFRDdmLGNBQU0sQ0FBQzhjLE9BQVAsQ0FBZSxDQUFmLEVBQWtCMkMsVUFBbEIsRUFBOEJ0VCxLQUE5QixFQUFxQyxVQUFTNUYsS0FBVCxFQUFnQjtBQUNqRG5JLFlBQUUsQ0FBQytmLEtBQUgsQ0FBUzlkLE1BQVQsR0FBa0JrRyxLQUFLLEdBQUcsSUFBMUI7QUFDSCxTQUZELEVBRUcsUUFGSCxFQUVhLFlBQVc7QUFDcEJvTixrQkFBUTtBQUNSdlYsWUFBRSxDQUFDK2YsS0FBSCxDQUFTOWQsTUFBVCxHQUFrQixFQUFsQjtBQUNBakMsWUFBRSxDQUFDK2YsS0FBSCxDQUFTMkIsT0FBVCxHQUFtQixFQUFuQjtBQUNBMWhCLFlBQUUsQ0FBQytmLEtBQUgsQ0FBUzRCLFFBQVQsR0FBb0IsRUFBcEI7QUFDSCxTQVBEO0FBUUg7QUFDSixLQTE5QkU7QUE0OUJIclQsV0FBTyxFQUFFLGlCQUFTdE8sRUFBVCxFQUFhK04sS0FBYixFQUFvQndILFFBQXBCLEVBQThCO0FBQ25DM1QsWUFBTSxDQUFDc2YsS0FBUCxDQUFhbGhCLEVBQWIsRUFBaUIsSUFBakIsRUFBdUIrTixLQUF2QixFQUE4QndILFFBQTlCO0FBQ0gsS0E5OUJFO0FBZytCSGhILGFBQVMsRUFBRSxtQkFBU3ZPLEVBQVQsRUFBYStOLEtBQWIsRUFBb0J3SCxRQUFwQixFQUE4QjtBQUNyQzNULFlBQU0sQ0FBQ3NmLEtBQVAsQ0FBYWxoQixFQUFiLEVBQWlCLE1BQWpCLEVBQXlCK04sS0FBekIsRUFBZ0N3SCxRQUFoQztBQUNILEtBbCtCRTtBQW8rQkh4TSxRQUFJLEVBQUUsY0FBUy9JLEVBQVQsRUFBYTBoQixPQUFiLEVBQXNCO0FBQ3hCLFVBQUksT0FBTzFoQixFQUFQLEtBQWMsV0FBbEIsRUFBK0I7QUFDM0JBLFVBQUUsQ0FBQytmLEtBQUgsQ0FBUzJCLE9BQVQsR0FBb0JBLE9BQU8sR0FBR0EsT0FBSCxHQUFhLE9BQXhDO0FBQ0g7QUFDSixLQXgrQkU7QUEwK0JIcmYsUUFBSSxFQUFFLGNBQVNyQyxFQUFULEVBQWE7QUFDZixVQUFJLE9BQU9BLEVBQVAsS0FBYyxXQUFsQixFQUErQjtBQUMzQkEsVUFBRSxDQUFDK2YsS0FBSCxDQUFTMkIsT0FBVCxHQUFtQixNQUFuQjtBQUNIO0FBQ0osS0E5K0JFO0FBZy9CSC9aLFlBQVEsRUFBRSxrQkFBUzNILEVBQVQsRUFBYTRELElBQWIsRUFBbUI2RSxPQUFuQixFQUE0QkYsR0FBNUIsRUFBaUM7QUFDdkN2SSxRQUFFLEdBQUc0QixNQUFNLENBQUM0QyxHQUFQLENBQVd4RSxFQUFYLENBQUw7O0FBQ0EsVUFBSSxPQUFPQSxFQUFQLEtBQWMsV0FBbEIsRUFBK0I7QUFDM0JBLFVBQUUsQ0FBQ2tLLGdCQUFILENBQW9CdEcsSUFBcEIsRUFBMEI2RSxPQUExQjtBQUNIO0FBQ0osS0FyL0JFO0FBdS9CSDRILGVBQVcsRUFBRSxxQkFBU3JRLEVBQVQsRUFBYTRELElBQWIsRUFBbUI2RSxPQUFuQixFQUE0QjtBQUNyQ3pJLFFBQUUsR0FBRzRCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV3hFLEVBQVgsQ0FBTDtBQUNBQSxRQUFFLENBQUN1VCxtQkFBSCxDQUF1QjNQLElBQXZCLEVBQTZCNkUsT0FBN0I7QUFDSCxLQTEvQkU7QUE0L0JIekgsTUFBRSxFQUFFLFlBQVM2RixPQUFULEVBQWtCc1csUUFBbEIsRUFBNEI3VSxLQUE1QixFQUFtQ0csT0FBbkMsRUFBNEM7QUFDNUMsVUFBSSxDQUFDMFUsUUFBTCxFQUFlO0FBQ1g7QUFDSDs7QUFFRCxVQUFJeUUsT0FBTyxHQUFHaGdCLE1BQU0sQ0FBQ3dKLFdBQVAsQ0FBbUIsT0FBbkIsQ0FBZDs7QUFFQW5CLFlBQU0sQ0FBQ29OLDRCQUFQLENBQW9DdUssT0FBcEMsSUFBK0MsVUFBU2hmLENBQVQsRUFBWTtBQUN2RCxZQUFJaWYsT0FBTyxHQUFHaGIsT0FBTyxDQUFDOEcsZ0JBQVIsQ0FBeUJ3UCxRQUF6QixDQUFkO0FBQ0EsWUFBSXRhLE1BQU0sR0FBR0QsQ0FBQyxDQUFDQyxNQUFmOztBQUVBLGVBQU9BLE1BQU0sSUFBSUEsTUFBTSxLQUFLZ0UsT0FBNUIsRUFBcUM7QUFDakMsZUFBSyxJQUFJd0IsQ0FBQyxHQUFHLENBQVIsRUFBV3VHLENBQUMsR0FBR2lULE9BQU8sQ0FBQ3hlLE1BQTVCLEVBQW9DZ0YsQ0FBQyxHQUFHdUcsQ0FBeEMsRUFBMkN2RyxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDLGdCQUFJeEYsTUFBTSxLQUFLZ2YsT0FBTyxDQUFDeFosQ0FBRCxDQUF0QixFQUEyQjtBQUN2QkkscUJBQU8sQ0FBQ0MsSUFBUixDQUFhN0YsTUFBYixFQUFxQkQsQ0FBckI7QUFDSDtBQUNKOztBQUVEQyxnQkFBTSxHQUFHQSxNQUFNLENBQUM2TixVQUFoQjtBQUNIO0FBQ0osT0FiRDs7QUFlQTlPLFlBQU0sQ0FBQytGLFFBQVAsQ0FBZ0JkLE9BQWhCLEVBQXlCeUIsS0FBekIsRUFBZ0MyQixNQUFNLENBQUNvTiw0QkFBUCxDQUFvQ3VLLE9BQXBDLENBQWhDO0FBRUEsYUFBT0EsT0FBUDtBQUNILEtBcmhDRTtBQXVoQ0h6WCxPQUFHLEVBQUUsYUFBU3RELE9BQVQsRUFBa0J5QixLQUFsQixFQUF5QnNaLE9BQXpCLEVBQWtDO0FBQ25DLFVBQUksQ0FBQy9hLE9BQUQsSUFBWSxDQUFDb0QsTUFBTSxDQUFDb04sNEJBQVAsQ0FBb0N1SyxPQUFwQyxDQUFqQixFQUErRDtBQUMzRDtBQUNIOztBQUVEaGdCLFlBQU0sQ0FBQ3lPLFdBQVAsQ0FBbUJ4SixPQUFuQixFQUE0QnlCLEtBQTVCLEVBQW1DMkIsTUFBTSxDQUFDb04sNEJBQVAsQ0FBb0N1SyxPQUFwQyxDQUFuQztBQUVBLGFBQU8zWCxNQUFNLENBQUNvTiw0QkFBUCxDQUFvQ3VLLE9BQXBDLENBQVA7QUFDSCxLQS9oQ0U7QUFpaUNIclosT0FBRyxFQUFFLFNBQVN1WixPQUFULENBQWlCOWhCLEVBQWpCLEVBQXFCNEQsSUFBckIsRUFBMkIyUixRQUEzQixFQUFxQztBQUN0Q3ZWLFFBQUUsR0FBRzRCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV3hFLEVBQVgsQ0FBTDtBQUVBQSxRQUFFLENBQUNrSyxnQkFBSCxDQUFvQnRHLElBQXBCLEVBQTBCLFNBQVNtZSxNQUFULENBQWdCbmYsQ0FBaEIsRUFBbUI7QUFDekM7QUFDQSxZQUFJQSxDQUFDLENBQUNDLE1BQUYsSUFBWUQsQ0FBQyxDQUFDQyxNQUFGLENBQVMwUSxtQkFBekIsRUFBOEM7QUFDMUMzUSxXQUFDLENBQUNDLE1BQUYsQ0FBUzBRLG1CQUFULENBQTZCM1EsQ0FBQyxDQUFDZ0IsSUFBL0IsRUFBcUNtZSxNQUFyQztBQUNILFNBSndDLENBTXpDOzs7QUFDQSxlQUFPeE0sUUFBUSxDQUFDM1MsQ0FBRCxDQUFmO0FBQ0gsT0FSRDtBQVNILEtBN2lDRTtBQStpQ0hvZixRQUFJLEVBQUUsY0FBU3JCLEdBQVQsRUFBYztBQUNoQixVQUFJcUIsSUFBSSxHQUFHLENBQVg7QUFBQSxVQUNJM1osQ0FESjtBQUFBLFVBQ080WixHQURQO0FBR0EsVUFBSXRCLEdBQUcsQ0FBQ3RkLE1BQUosS0FBZSxDQUFuQixFQUFzQixPQUFPMmUsSUFBUDs7QUFDdEIsV0FBSzNaLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3NZLEdBQUcsQ0FBQ3RkLE1BQXBCLEVBQTRCZ0YsQ0FBQyxFQUE3QixFQUFpQztBQUM3QjRaLFdBQUcsR0FBR3RCLEdBQUcsQ0FBQ3VCLFVBQUosQ0FBZTdaLENBQWYsQ0FBTjtBQUNBMlosWUFBSSxHQUFJLENBQUNBLElBQUksSUFBSSxDQUFULElBQWNBLElBQWYsR0FBdUJDLEdBQTlCO0FBQ0FELFlBQUksSUFBSSxDQUFSLENBSDZCLENBR2xCO0FBQ2Q7O0FBRUQsYUFBT0EsSUFBUDtBQUNILEtBM2pDRTtBQTZqQ0hHLGdCQUFZLEVBQUUsc0JBQVNuaUIsRUFBVCxFQUFhb2lCLGFBQWIsRUFBNEI3TSxRQUE1QixFQUFzQztBQUNoRCxVQUFJOE0sU0FBSjtBQUNBLFVBQUlDLFVBQVUsR0FBRztBQUNiRCxpQkFBUyxFQUFFLGNBREU7QUFFYkUsa0JBQVUsRUFBRSxlQUZDO0FBR2JDLG9CQUFZLEVBQUUsaUJBSEQ7QUFJYkMsdUJBQWUsRUFBRSxvQkFKSjtBQUtiQyxtQkFBVyxFQUFFO0FBTEEsT0FBakI7O0FBUUEsV0FBSyxJQUFJeEQsQ0FBVCxJQUFjb0QsVUFBZCxFQUEwQjtBQUN0QixZQUFJdGlCLEVBQUUsQ0FBQytmLEtBQUgsQ0FBU2IsQ0FBVCxNQUFnQjdWLFNBQXBCLEVBQStCO0FBQzNCZ1osbUJBQVMsR0FBR0MsVUFBVSxDQUFDcEQsQ0FBRCxDQUF0QjtBQUNIO0FBQ0o7O0FBRUR0ZCxZQUFNLENBQUNSLFFBQVAsQ0FBZ0JwQixFQUFoQixFQUFvQixjQUFjb2lCLGFBQWxDO0FBRUF4Z0IsWUFBTSxDQUFDMkcsR0FBUCxDQUFXdkksRUFBWCxFQUFlcWlCLFNBQWYsRUFBMEIsWUFBVztBQUNqQ3pnQixjQUFNLENBQUNvRSxXQUFQLENBQW1CaEcsRUFBbkIsRUFBdUIsY0FBY29pQixhQUFyQztBQUNILE9BRkQ7O0FBSUEsVUFBSTdNLFFBQUosRUFBYztBQUNWM1QsY0FBTSxDQUFDMkcsR0FBUCxDQUFXdkksRUFBWCxFQUFlcWlCLFNBQWYsRUFBMEI5TSxRQUExQjtBQUNIO0FBQ0osS0F0bENFO0FBd2xDSC9ELGlCQUFhLEVBQUUsdUJBQVN4UixFQUFULEVBQWF1VixRQUFiLEVBQXVCO0FBQ2xDLFVBQUlvTixVQUFKO0FBQ0EsVUFBSUMsV0FBVyxHQUFHO0FBQ2RELGtCQUFVLEVBQUUsZUFERTtBQUVkRSxtQkFBVyxFQUFFLGdCQUZDO0FBR2RDLHFCQUFhLEVBQUUsa0JBSEQ7QUFJZEMsd0JBQWdCLEVBQUUscUJBSko7QUFLZEMsb0JBQVksRUFBRTtBQUxBLE9BQWxCOztBQVFBLFdBQUssSUFBSTlELENBQVQsSUFBYzBELFdBQWQsRUFBMkI7QUFDdkIsWUFBSTVpQixFQUFFLENBQUMrZixLQUFILENBQVNiLENBQVQsTUFBZ0I3VixTQUFwQixFQUErQjtBQUMzQnNaLG9CQUFVLEdBQUdDLFdBQVcsQ0FBQzFELENBQUQsQ0FBeEI7QUFDSDtBQUNKOztBQUVEdGQsWUFBTSxDQUFDMkcsR0FBUCxDQUFXdkksRUFBWCxFQUFlMmlCLFVBQWYsRUFBMkJwTixRQUEzQjtBQUNILEtBem1DRTtBQTJtQ0gwTixnQkFBWSxFQUFFLHNCQUFTampCLEVBQVQsRUFBYXVWLFFBQWIsRUFBdUI7QUFDakMsVUFBSThNLFNBQUo7QUFDQSxVQUFJQyxVQUFVLEdBQUc7QUFDYkQsaUJBQVMsRUFBRSxjQURFO0FBRWJFLGtCQUFVLEVBQUUsZUFGQztBQUdiQyxvQkFBWSxFQUFFLGlCQUhEO0FBSWJDLHVCQUFlLEVBQUUsb0JBSko7QUFLYkMsbUJBQVcsRUFBRTtBQUxBLE9BQWpCOztBQVFBLFdBQUssSUFBSXhELENBQVQsSUFBY29ELFVBQWQsRUFBMEI7QUFDdEIsWUFBSXRpQixFQUFFLENBQUMrZixLQUFILENBQVNiLENBQVQsTUFBZ0I3VixTQUFwQixFQUErQjtBQUMzQmdaLG1CQUFTLEdBQUdDLFVBQVUsQ0FBQ3BELENBQUQsQ0FBdEI7QUFDSDtBQUNKOztBQUVEdGQsWUFBTSxDQUFDMkcsR0FBUCxDQUFXdkksRUFBWCxFQUFlcWlCLFNBQWYsRUFBMEI5TSxRQUExQjtBQUNILEtBNW5DRTtBQThuQ0gyTixnQkFBWSxFQUFFLHNCQUFTbGpCLEVBQVQsRUFBYW1JLEtBQWIsRUFBb0I7QUFDOUIsVUFBSWdOLE9BQU8sR0FBRyxDQUFDLFNBQUQsRUFBWSxNQUFaLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLENBQWQ7O0FBQ0EsV0FBSyxJQUFJOU0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzhNLE9BQU8sQ0FBQzlSLE1BQTVCLEVBQW9DZ0YsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQ3pHLGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBV2pELEVBQVgsRUFBZW1WLE9BQU8sQ0FBQzlNLENBQUQsQ0FBUCxHQUFhLGlCQUE1QixFQUErQ0YsS0FBL0M7QUFDSDtBQUNKLEtBbm9DRTtBQXFvQ0hnYixtQkFBZSxFQUFFLHlCQUFTbmpCLEVBQVQsRUFBYW1JLEtBQWIsRUFBb0I7QUFDakMsVUFBSWdOLE9BQU8sR0FBRyxDQUFDLFNBQUQsRUFBWSxNQUFaLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLENBQWQ7O0FBQ0EsV0FBSyxJQUFJOU0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzhNLE9BQU8sQ0FBQzlSLE1BQTVCLEVBQW9DZ0YsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQ3pHLGNBQU0sQ0FBQ3FCLEdBQVAsQ0FBV2pELEVBQVgsRUFBZW1WLE9BQU8sQ0FBQzlNLENBQUQsQ0FBUCxHQUFhLG9CQUE1QixFQUFrREYsS0FBbEQ7QUFDSDtBQUNKLEtBMW9DRTtBQTRvQ0hzRyxZQUFRLEVBQUUsa0JBQVM1TCxNQUFULEVBQWlCMEcsTUFBakIsRUFBeUJzVixRQUF6QixFQUFtQztBQUN6QyxVQUFJQSxRQUFRLEdBQUdBLFFBQVEsR0FBR0EsUUFBSCxHQUFjLEdBQXJDO0FBQ0EsVUFBSWhjLE1BQU0sR0FBR2pCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVzNCLE1BQVgsQ0FBYjtBQUNBLFVBQUl1Z0IsU0FBUyxHQUFHdmdCLE1BQU0sR0FBR2pCLE1BQU0sQ0FBQzJILE1BQVAsQ0FBYzFHLE1BQWQsRUFBc0JpQyxHQUF6QixHQUErQixDQUFyRDtBQUNBLFVBQUl1ZSxTQUFTLEdBQUdwWixNQUFNLENBQUMrSixXQUFQLElBQXNCMVAsUUFBUSxDQUFDd1EsZUFBVCxDQUF5QjFJLFNBQS9DLElBQTREOUgsUUFBUSxDQUFDd0MsSUFBVCxDQUFjc0YsU0FBMUUsSUFBdUYsQ0FBdkc7QUFDQSxVQUFJdVMsSUFBSixFQUFVQyxFQUFWOztBQUVBLFVBQUl3RSxTQUFTLEdBQUdDLFNBQWhCLEVBQTJCO0FBQ3ZCMUUsWUFBSSxHQUFHeUUsU0FBUDtBQUNBeEUsVUFBRSxHQUFHeUUsU0FBTDtBQUNILE9BSEQsTUFHTztBQUNIMUUsWUFBSSxHQUFHMEUsU0FBUDtBQUNBekUsVUFBRSxHQUFHd0UsU0FBTDtBQUNIOztBQUVELFVBQUk3WixNQUFKLEVBQVk7QUFDUnFWLFVBQUUsSUFBSXJWLE1BQU47QUFDSDs7QUFFRDNILFlBQU0sQ0FBQzhjLE9BQVAsQ0FBZUMsSUFBZixFQUFxQkMsRUFBckIsRUFBeUJDLFFBQXpCLEVBQW1DLFVBQVMxVyxLQUFULEVBQWdCO0FBQy9DN0QsZ0JBQVEsQ0FBQ3dRLGVBQVQsQ0FBeUIxSSxTQUF6QixHQUFxQ2pFLEtBQXJDO0FBQ0E3RCxnQkFBUSxDQUFDd0MsSUFBVCxDQUFjNEosVUFBZCxDQUF5QnRFLFNBQXpCLEdBQXFDakUsS0FBckM7QUFDQTdELGdCQUFRLENBQUN3QyxJQUFULENBQWNzRixTQUFkLEdBQTBCakUsS0FBMUI7QUFDSCxPQUpELEVBbkJ5QyxDQXVCckM7QUFDUCxLQXBxQ0U7QUFzcUNIaUUsYUFBUyxFQUFFLG1CQUFTN0MsTUFBVCxFQUFpQnNWLFFBQWpCLEVBQTJCO0FBQ2xDamQsWUFBTSxDQUFDNk0sUUFBUCxDQUFnQixJQUFoQixFQUFzQmxGLE1BQXRCLEVBQThCc1YsUUFBOUI7QUFDSCxLQXhxQ0U7QUEwcUNIeUUsV0FBTyxFQUFFLGlCQUFTL0osR0FBVCxFQUFjO0FBQ25CLGFBQU9BLEdBQUcsSUFBSWxELEtBQUssQ0FBQ2lOLE9BQU4sQ0FBYy9KLEdBQWQsQ0FBZDtBQUNILEtBNXFDRTtBQThxQ0g5UyxTQUFLLEVBQUUsZUFBUzhPLFFBQVQsRUFBbUI7QUFDdEIsVUFBSWpSLFFBQVEsQ0FBQ2lmLFdBQVQsR0FBdUJqZixRQUFRLENBQUNrZixVQUFULEtBQXdCLFVBQS9DLEdBQTREbGYsUUFBUSxDQUFDa2YsVUFBVCxLQUF3QixTQUF4RixFQUFtRztBQUMvRmpPLGdCQUFRO0FBQ1gsT0FGRCxNQUVPO0FBQ0hqUixnQkFBUSxDQUFDNEYsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDcUwsUUFBOUM7QUFDSDtBQUNKLEtBcHJDRTtBQXNyQ0hrTyxXQUFPLEVBQUUsaUJBQVNsSyxHQUFULEVBQWM7QUFDbkIsV0FBSyxJQUFJcUcsSUFBVCxJQUFpQnJHLEdBQWpCLEVBQXNCO0FBQ2xCLFlBQUlBLEdBQUcsQ0FBQ3pELGNBQUosQ0FBbUI4SixJQUFuQixDQUFKLEVBQThCO0FBQzFCLGlCQUFPLEtBQVA7QUFDSDtBQUNKOztBQUVELGFBQU8sSUFBUDtBQUNILEtBOXJDRTtBQWdzQ0g4RCxnQkFBWSxFQUFFLHNCQUFTQyxJQUFULEVBQWU7QUFDekJBLFVBQUksSUFBSSxFQUFSO0FBQ0EsVUFBSXZPLENBQUMsR0FBR3VPLElBQUksQ0FBQzlLLEtBQUwsQ0FBVyxHQUFYLENBQVI7QUFDQSxVQUFJK0ssRUFBRSxHQUFHeE8sQ0FBQyxDQUFDLENBQUQsQ0FBVjtBQUNBLFVBQUl5TyxFQUFFLEdBQUd6TyxDQUFDLENBQUMvUixNQUFGLEdBQVcsQ0FBWCxHQUFlLE1BQU0rUixDQUFDLENBQUMsQ0FBRCxDQUF0QixHQUE0QixFQUFyQztBQUNBLFVBQUkwTyxHQUFHLEdBQUcsY0FBVjs7QUFDQSxhQUFPQSxHQUFHLENBQUMxSSxJQUFKLENBQVN3SSxFQUFULENBQVAsRUFBcUI7QUFDakJBLFVBQUUsR0FBR0EsRUFBRSxDQUFDckksT0FBSCxDQUFXdUksR0FBWCxFQUFnQixPQUFPLEdBQVAsR0FBYSxJQUE3QixDQUFMO0FBQ0g7O0FBQ0QsYUFBT0YsRUFBRSxHQUFHQyxFQUFaO0FBQ0gsS0Exc0NFO0FBNHNDSEUsWUFBUSxFQUFFLG9CQUFXO0FBQ2pCLFVBQUlDLEVBQUUsR0FBRy9aLE1BQU0sQ0FBQzBKLFNBQVAsQ0FBaUJDLFNBQTFCLENBRGlCLENBR2pCO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQSxVQUFJcVEsSUFBSSxHQUFHRCxFQUFFLENBQUN0SyxPQUFILENBQVcsT0FBWCxDQUFYOztBQUNBLFVBQUl1SyxJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1Y7QUFDQSxlQUFPN1MsUUFBUSxDQUFDNFMsRUFBRSxDQUFDcEwsU0FBSCxDQUFhcUwsSUFBSSxHQUFHLENBQXBCLEVBQXVCRCxFQUFFLENBQUN0SyxPQUFILENBQVcsR0FBWCxFQUFnQnVLLElBQWhCLENBQXZCLENBQUQsRUFBZ0QsRUFBaEQsQ0FBZjtBQUNIOztBQUVELFVBQUlDLE9BQU8sR0FBR0YsRUFBRSxDQUFDdEssT0FBSCxDQUFXLFVBQVgsQ0FBZDs7QUFDQSxVQUFJd0ssT0FBTyxHQUFHLENBQWQsRUFBaUI7QUFDYjtBQUNBLFlBQUlDLEVBQUUsR0FBR0gsRUFBRSxDQUFDdEssT0FBSCxDQUFXLEtBQVgsQ0FBVDtBQUNBLGVBQU90SSxRQUFRLENBQUM0UyxFQUFFLENBQUNwTCxTQUFILENBQWF1TCxFQUFFLEdBQUcsQ0FBbEIsRUFBcUJILEVBQUUsQ0FBQ3RLLE9BQUgsQ0FBVyxHQUFYLEVBQWdCeUssRUFBaEIsQ0FBckIsQ0FBRCxFQUE0QyxFQUE1QyxDQUFmO0FBQ0g7O0FBRUQsVUFBSUMsSUFBSSxHQUFHSixFQUFFLENBQUN0SyxPQUFILENBQVcsT0FBWCxDQUFYOztBQUNBLFVBQUkwSyxJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1Y7QUFDQSxlQUFPaFQsUUFBUSxDQUFDNFMsRUFBRSxDQUFDcEwsU0FBSCxDQUFhd0wsSUFBSSxHQUFHLENBQXBCLEVBQXVCSixFQUFFLENBQUN0SyxPQUFILENBQVcsR0FBWCxFQUFnQjBLLElBQWhCLENBQXZCLENBQUQsRUFBZ0QsRUFBaEQsQ0FBZjtBQUNILE9BbENnQixDQW9DakI7OztBQUNBLGFBQU8sS0FBUDtBQUNILEtBbHZDRTtBQW92Q0hDLFNBQUssRUFBRSxpQkFBVztBQUNkLGFBQVF6aUIsTUFBTSxDQUFDbUUsSUFBUCxDQUFZbkUsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLE1BQVgsQ0FBWixFQUFnQyxXQUFoQyxLQUFnRCxLQUF4RDtBQUNILEtBdHZDRTtBQXd2Q0g7QUFFQTtBQUNBM0MsY0FBVSxFQUFFLG9CQUFTZ0YsT0FBVCxFQUFrQnRGLE9BQWxCLEVBQTJCO0FBQ25DLFVBQUcsQ0FBQ3NGLE9BQUosRUFBYSxPQURzQixDQUVuQzs7QUFDQSxlQUFTdkQsSUFBVCxHQUFnQjtBQUNaLFlBQUlnaEIsRUFBSjtBQUNBLFlBQUlyaUIsTUFBSjs7QUFFQSxZQUFJVixPQUFPLENBQUNVLE1BQVIsWUFBMEJzUSxRQUE5QixFQUF3QztBQUNwQ3RRLGdCQUFNLEdBQUdtUCxRQUFRLENBQUM3UCxPQUFPLENBQUNVLE1BQVIsQ0FBZXlHLElBQWYsRUFBRCxDQUFqQjtBQUNILFNBRkQsTUFFTztBQUNIekcsZ0JBQU0sR0FBR21QLFFBQVEsQ0FBQzdQLE9BQU8sQ0FBQ1UsTUFBVCxDQUFqQjtBQUNILFNBUlcsQ0FVWjs7O0FBQ0EsWUFBSSxDQUFDVixPQUFPLENBQUNPLGtCQUFSLElBQThCUCxPQUFPLENBQUNnakIsZ0JBQXZDLEtBQTREM2lCLE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsbUJBQTNCLENBQWhFLEVBQWlIO0FBQzdHb2lCLFlBQUUsR0FBRzFpQixNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCckMsR0FBckIsQ0FBeUIsSUFBekIsQ0FBTDs7QUFDQSxjQUFJOGYsRUFBSixFQUFRO0FBQ0osZ0JBQUkvaUIsT0FBTyxDQUFDMkssb0JBQVosRUFBa0M7QUFDOUJ0SyxvQkFBTSxDQUFDcUIsR0FBUCxDQUFXNEQsT0FBWCxFQUFvQixRQUFwQixFQUE4QixNQUE5QjtBQUNILGFBRkQsTUFFTztBQUNIakYsb0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzRELE9BQVgsRUFBb0IsVUFBcEIsRUFBZ0MsTUFBaEM7O0FBQ0Esa0JBQUk1RSxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNaTCxzQkFBTSxDQUFDcUIsR0FBUCxDQUFXNEQsT0FBWCxFQUFvQixRQUFwQixFQUE4QjVFLE1BQU0sR0FBRyxJQUF2QztBQUNIO0FBQ0o7O0FBRURxaUIsY0FBRSxDQUFDRSxPQUFIO0FBQ0FGLGNBQUUsR0FBRzFpQixNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCakMsTUFBckIsQ0FBNEIsSUFBNUIsQ0FBTDtBQUNILFdBWkQsTUFZTyxJQUFJM0MsTUFBTSxHQUFHLENBQWIsRUFBZTtBQUNsQkwsa0JBQU0sQ0FBQ3FCLEdBQVAsQ0FBVzRELE9BQVgsRUFBb0IsVUFBcEIsRUFBZ0MsTUFBaEM7QUFDQWpGLGtCQUFNLENBQUNxQixHQUFQLENBQVc0RCxPQUFYLEVBQW9CLFFBQXBCLEVBQThCNUUsTUFBTSxHQUFHLElBQXZDO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRCxZQUFJQSxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNaTCxnQkFBTSxDQUFDcUIsR0FBUCxDQUFXNEQsT0FBWCxFQUFvQixRQUFwQixFQUE4QjVFLE1BQU0sR0FBRyxJQUF2QztBQUNIOztBQUVELFlBQUlWLE9BQU8sQ0FBQ2tqQixtQkFBWixFQUFpQztBQUM3QjdpQixnQkFBTSxDQUFDcUIsR0FBUCxDQUFXNEQsT0FBWCxFQUFvQixVQUFwQixFQUFnQyxNQUFoQztBQUNBO0FBQ0gsU0F4Q1csQ0EwQ1o7OztBQUNBakYsY0FBTSxDQUFDcUIsR0FBUCxDQUFXNEQsT0FBWCxFQUFvQixVQUFwQixFQUFnQyxRQUFoQztBQUVBeWQsVUFBRSxHQUFHMWlCLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJyQyxHQUFyQixDQUF5QixJQUF6QixDQUFMOztBQUNBLFlBQUk4ZixFQUFKLEVBQVE7QUFDSkEsWUFBRSxDQUFDalosTUFBSDtBQUNILFNBRkQsTUFFTztBQUNIekosZ0JBQU0sQ0FBQ1IsUUFBUCxDQUFnQnlGLE9BQWhCLEVBQXlCLFFBQXpCO0FBQ0F5ZCxZQUFFLEdBQUcsSUFBSUksZ0JBQUosQ0FBcUI3ZCxPQUFyQixFQUE4QjtBQUMvQjhkLHNCQUFVLEVBQUUsR0FEbUI7QUFFL0JDLHVCQUFXLEVBQUUsSUFGa0I7QUFHL0JDLDRCQUFnQixFQUFHdGpCLE9BQU8sQ0FBQzBLLFlBQVIsS0FBeUIsS0FBekIsR0FBaUMsS0FBakMsR0FBeUMsSUFIN0I7QUFJL0I2WSw4QkFBa0IsRUFBRSxFQUpXO0FBSy9CQyw4QkFBa0IsRUFBRSxHQUxXO0FBTS9CQywyQkFBZSxFQUFFcGpCLE1BQU0sQ0FBQ21FLElBQVAsQ0FBWWMsT0FBWixFQUFxQixlQUFyQixLQUF5QyxNQUF6QyxHQUFrRCxJQUFsRCxHQUF5RDtBQU4zQyxXQUE5QixDQUFMO0FBU0FqRixnQkFBTSxDQUFDMUIsSUFBUCxDQUFZMkcsT0FBWixFQUFxQk8sR0FBckIsQ0FBeUIsSUFBekIsRUFBK0JrZCxFQUEvQjtBQUNILFNBNURXLENBOERaOzs7QUFDQSxZQUFJblosR0FBRyxHQUFHdkosTUFBTSxDQUFDbUUsSUFBUCxDQUFZYyxPQUFaLEVBQXFCLElBQXJCLENBQVY7O0FBRUEsWUFBSXRGLE9BQU8sQ0FBQ1MsZ0JBQVIsS0FBNkIsSUFBN0IsSUFBcUNpakIsT0FBckMsSUFBZ0Q5WixHQUFwRCxFQUF5RDtBQUNyRCxjQUFJOFosT0FBTyxDQUFDemdCLEdBQVIsQ0FBWTJHLEdBQVosQ0FBSixFQUFzQjtBQUNsQixnQkFBSTRJLEdBQUcsR0FBRzNDLFFBQVEsQ0FBQzZULE9BQU8sQ0FBQ3pnQixHQUFSLENBQVkyRyxHQUFaLENBQUQsQ0FBbEI7O0FBRUEsZ0JBQUk0SSxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ1RsTixxQkFBTyxDQUFDdUYsU0FBUixHQUFvQjJILEdBQXBCO0FBQ0g7QUFDSjs7QUFFRGxOLGlCQUFPLENBQUNxRCxnQkFBUixDQUF5QixhQUF6QixFQUF3QyxZQUFXO0FBQy9DK2EsbUJBQU8sQ0FBQzdkLEdBQVIsQ0FBWStELEdBQVosRUFBaUJ0RSxPQUFPLENBQUN1RixTQUF6QjtBQUNILFdBRkQ7QUFHSDtBQUNKLE9BakZrQyxDQW1GbkM7OztBQUNBOUksVUFBSSxHQXBGK0IsQ0FzRm5DOztBQUNBLFVBQUkvQixPQUFPLENBQUNRLGtCQUFaLEVBQWdDO0FBQzVCSCxjQUFNLENBQUM2TyxnQkFBUCxDQUF3QixZQUFXO0FBQy9Cbk4sY0FBSTtBQUNQLFNBRkQ7QUFHSDtBQUNKLEtBdjFDRTtBQXkxQ0g2SSxnQkFBWSxFQUFFLHNCQUFTdEYsT0FBVCxFQUFrQjtBQUM1QixVQUFJeWQsRUFBRSxHQUFHMWlCLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJyQyxHQUFyQixDQUF5QixJQUF6QixDQUFUOztBQUNBLFVBQUk4ZixFQUFKLEVBQVE7QUFDSkEsVUFBRSxDQUFDalosTUFBSDtBQUNIO0FBQ0osS0E5MUNFO0FBZzJDSDZaLG1CQUFlLEVBQUUseUJBQVNuSSxNQUFULEVBQWlCO0FBQzlCLFVBQUlvSSxTQUFTLEdBQUd2akIsTUFBTSxDQUFDZ0wsT0FBUCxDQUFlbVEsTUFBZixFQUF1QixLQUF2QixDQUFoQjs7QUFDQSxXQUFLLElBQUkxVSxDQUFDLEdBQUcsQ0FBUixFQUFXd0UsR0FBRyxHQUFHc1ksU0FBUyxDQUFDOWhCLE1BQWhDLEVBQXdDZ0YsQ0FBQyxHQUFHd0UsR0FBNUMsRUFBaUR4RSxDQUFDLEVBQWxELEVBQXNEO0FBQ2xEekcsY0FBTSxDQUFDd2pCLGNBQVAsQ0FBc0JELFNBQVMsQ0FBQzljLENBQUQsQ0FBL0I7QUFDSDtBQUNKLEtBcjJDRTtBQXUyQ0gyRCxpQkFBYSxFQUFFLHVCQUFTbkYsT0FBVCxFQUFrQjtBQUM3QixVQUFJeWQsRUFBRSxHQUFHMWlCLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJHLE9BQVosRUFBcUJyQyxHQUFyQixDQUF5QixJQUF6QixDQUFUOztBQUNBLFVBQUk4ZixFQUFKLEVBQVE7QUFDSkEsVUFBRSxDQUFDRSxPQUFIO0FBQ0FGLFVBQUUsR0FBRzFpQixNQUFNLENBQUMxQixJQUFQLENBQVkyRyxPQUFaLEVBQXFCakMsTUFBckIsQ0FBNEIsSUFBNUIsQ0FBTDtBQUNIO0FBQ0osS0E3MkNFO0FBKzJDSG9FLFdBQU8sRUFBRSxpQkFBU2hKLEVBQVQsRUFBYXFCLElBQWIsRUFBbUI7QUFDeEIsVUFBSU8sTUFBTSxDQUFDNEMsR0FBUCxDQUFXeEUsRUFBWCxDQUFKLEVBQW9CO0FBQ2hCNEIsY0FBTSxDQUFDNEMsR0FBUCxDQUFXeEUsRUFBWCxFQUFlMEUsU0FBZixHQUEyQnJELElBQTNCO0FBQ0g7QUFDSixLQW4zQ0U7QUFxM0NIZ2tCLFdBQU8sRUFBRSxpQkFBU3JsQixFQUFULEVBQWE7QUFDbEIsVUFBSTRCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBV3hFLEVBQVgsQ0FBSixFQUFvQjtBQUNoQixlQUFPNEIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXeEUsRUFBWCxFQUFlMEUsU0FBdEI7QUFDSDtBQUNKLEtBejNDRTtBQTIzQ0hzRixxQkFBaUIsRUFBRSw2QkFBVztBQUMxQixVQUFJbEQsSUFBSSxHQUFHeEMsUUFBUSxDQUFDd0MsSUFBcEI7QUFDQSxVQUFJekYsSUFBSSxHQUFHaUQsUUFBUSxDQUFDd1EsZUFBcEI7QUFFQSxhQUFPWSxJQUFJLENBQUNDLEdBQUwsQ0FBVTdPLElBQUksQ0FBQ3dlLFlBQWYsRUFBNkJ4ZSxJQUFJLENBQUMyWCxZQUFsQyxFQUFnRHBkLElBQUksQ0FBQ2trQixZQUFyRCxFQUFtRWxrQixJQUFJLENBQUNpa0IsWUFBeEUsRUFBc0Zqa0IsSUFBSSxDQUFDb2QsWUFBM0YsQ0FBUDtBQUNILEtBaDRDRTtBQWs0Q0hwVSxnQkFBWSxFQUFFLHdCQUFXO0FBQ3JCLGFBQVEsQ0FBQy9GLFFBQVEsQ0FBQ2toQixnQkFBVCxJQUE2QmxoQixRQUFRLENBQUN3USxlQUF2QyxFQUF3RDFJLFNBQWhFO0FBQ0g7QUFwNENFLEdBQVA7QUFzNENILENBejZDWSxFQUFiLEMsQ0EyNkNBOzs7QUFDQSxJQUFJLFNBQWlDLE9BQU85RixNQUFNLENBQUNDLE9BQWQsS0FBMEIsV0FBL0QsRUFBNEU7QUFDeEVELFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQjNFLE1BQWpCO0FBQ0gsQyxDQUVEOzs7QUFDQUEsTUFBTSxDQUFDNkUsS0FBUCxDQUFhLFlBQVc7QUFDcEI3RSxRQUFNLENBQUMwQixJQUFQO0FBQ0gsQ0FGRCxFLENBSUE7O0FBQ0EyRyxNQUFNLENBQUNqQyxNQUFQLEdBQWdCLFlBQVc7QUFDdkJwRyxRQUFNLENBQUNvRSxXQUFQLENBQW1CcEUsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLE1BQVgsQ0FBbkIsRUFBdUMsZUFBdkM7QUFDSCxDQUZELEM7Ozs7Ozs7Ozs7OztBQ3hpRGE7O0FBQ2IsSUFBSWloQixRQUFRLEdBQUcsWUFBVztBQUN0QixNQUFJM2UsSUFBSjtBQUVBLE1BQUk0ZSxLQUFKO0FBQ0EsTUFBSUMsU0FBSjtBQUNBLE1BQUlDLGtCQUFKO0FBRUEsTUFBSXhaLFNBQUo7QUFFQSxNQUFJeVosaUJBQUosQ0FUc0IsQ0FXdEI7O0FBQ0EsTUFBSUMsVUFBUyxHQUFHLFNBQVpBLFNBQVksR0FBVztBQUN2QkosU0FBSyxHQUFHOWpCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxPQUFYLENBQVIsQ0FEdUIsQ0FHdkI7O0FBQ0FvaEIsc0JBQWtCLEdBQUcsSUFBSWpWLFdBQUosQ0FBZ0IsT0FBaEIsRUFBeUI7QUFDMUNHLGVBQVMsRUFBRSxPQUQrQjtBQUUxQ0YsYUFBTyxFQUFFLElBRmlDO0FBRzFDTyxhQUFPLEVBQUUsaUJBSGlDO0FBSTFDRixjQUFRLEVBQUU7QUFDTnBPLGNBQU0sRUFBRSxzQkFERjtBQUVOaUIsYUFBSyxFQUFFO0FBRkQ7QUFKZ0MsS0FBekIsQ0FBckIsQ0FKdUIsQ0FjdkI7O0FBQ0EsUUFBSWlpQixJQUFJLEdBQUdua0IsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLFlBQVgsQ0FBWDtBQUNBLFFBQUl1aEIsSUFBSSxHQUFHbmtCLE1BQU0sQ0FBQ2daLE9BQVAsQ0FBZSxZQUFmLENBQVg7QUFDQSxRQUFJb0wsZUFBZSxHQUFJcGtCLE1BQU0sQ0FBQ21FLElBQVAsQ0FBWWdnQixJQUFaLEVBQWtCLHNCQUFsQixNQUE4QyxHQUE5QyxHQUFvRCxVQUFwRCxHQUFpRSxXQUF4RixDQWpCdUIsQ0FtQnZCOztBQUNBLFFBQUl2YixNQUFKOztBQUNBLFFBQUk1SSxNQUFNLENBQUNtRSxJQUFQLENBQVlnZ0IsSUFBWixFQUFrQixvQkFBbEIsTUFBNEMsR0FBaEQsRUFBcUQ7QUFDakR2YixZQUFNLEdBQUc7QUFDTHhJLHdCQUFnQixFQUFFLElBRGI7QUFDbUI7QUFDeEJDLGNBQU0sRUFBRSxrQkFBVztBQUFHO0FBQ2xCO0FBQ0EsY0FBSUEsTUFBSixDQUZlLENBSWY7O0FBQ0EsY0FBSWdrQixZQUFZLEdBQUc3VSxRQUFRLENBQUN4UCxNQUFNLENBQUNrSSxXQUFQLEdBQXFCN0gsTUFBdEIsQ0FBM0IsQ0FMZSxDQU9mOztBQUNBLGNBQUlpa0IsU0FBUyxHQUFHdGtCLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTRpQixLQUFaLEVBQW1CLG1CQUFuQixDQUFoQjtBQUNBLGNBQUlTLG1CQUFtQixHQUFHL1UsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXaWpCLFNBQVgsRUFBc0IsYUFBdEIsQ0FBRCxDQUFsQztBQUNBLGNBQUlFLHNCQUFzQixHQUFHaFYsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXaWpCLFNBQVgsRUFBc0IsZ0JBQXRCLENBQUQsQ0FBckMsQ0FWZSxDQVlmOztBQUNBLGNBQUlwaEIsR0FBRyxHQUFHbEQsTUFBTSxDQUFDa0IsSUFBUCxDQUFZNGlCLEtBQVosRUFBbUIsdUJBQW5CLENBQVY7QUFDQSxjQUFJVyxTQUFTLEdBQUdqVixRQUFRLENBQUN4UCxNQUFNLENBQUNLLE1BQVAsQ0FBYzZDLEdBQWQsQ0FBRCxDQUF4QixDQWRlLENBZ0JmOztBQUNBLGNBQUl3aEIsTUFBTSxHQUFHMWtCLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTRpQixLQUFaLEVBQW1CLDBCQUFuQixDQUFiO0FBQ0EsY0FBSWEsZ0JBQWdCLEdBQUduVixRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVdxakIsTUFBWCxFQUFtQixhQUFuQixDQUFELENBQS9CO0FBQ0EsY0FBSUUsbUJBQW1CLEdBQUdwVixRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVdxakIsTUFBWCxFQUFtQixnQkFBbkIsQ0FBRCxDQUFsQyxDQW5CZSxDQXFCZjs7QUFDQXJrQixnQkFBTSxHQUFHZ2tCLFlBQVksR0FBR0ksU0FBZixHQUEyQkUsZ0JBQTNCLEdBQThDQyxtQkFBOUMsR0FBb0VMLG1CQUFwRSxHQUEwRkMsc0JBQW5HO0FBRUEsaUJBQU9ua0IsTUFBUDtBQUNIO0FBM0JJLE9BQVQ7QUE2QkgsS0FuRHNCLENBcUR2Qjs7O0FBQ0EwakIsYUFBUyxHQUFHLElBQUlwYixNQUFKLENBQVcsWUFBWCxFQUF5QjtBQUNqQztBQUNBQyxZQUFNLEVBQUVBLE1BRnlCO0FBSWpDO0FBQ0ErQixhQUFPLEVBQUU7QUFDTDlDLGVBQU8sRUFBRTtBQUNMO0FBQ0EscUJBQVN1YyxlQUZKO0FBR0w7QUFDQWxpQixlQUFLLEVBQUU7QUFDSGdELGdCQUFJLEVBQUUsaUJBREg7QUFFSDJGLGdCQUFJLEVBQUU7QUFGSDtBQUpGLFNBREo7QUFVTEMsY0FBTSxFQUFFLFdBVkg7QUFVZ0I7QUFDckJsRCxjQUFNLEVBQUUsV0FYSCxDQVdlOztBQVhmLE9BTHdCO0FBbUJqQztBQUNBaUIsZUFBUyxFQUFFO0FBQ1BJLGlCQUFTLEVBQUUsS0FESixDQUNVOztBQURWO0FBcEJzQixLQUF6QixDQUFaO0FBd0JILEdBOUVELENBWnNCLENBNEZ0Qjs7O0FBQ0EsTUFBSTRiLGNBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsR0FBVztBQUMzQixRQUFJQyxTQUFTLEdBQUcsSUFBSWpULFdBQUosQ0FBZ0IsV0FBaEIsRUFBNkI7QUFDekNsSyxZQUFNLEVBQUUsR0FEaUM7QUFFekN3RSxXQUFLLEVBQUU7QUFGa0MsS0FBN0IsQ0FBaEI7QUFJSCxHQUxELENBN0ZzQixDQW9HdEI7OztBQUNBLE1BQUk0WSxzQkFBcUIsR0FBRyxTQUF4QkEscUJBQXdCLEdBQVc7QUFDbkMsUUFBSUMsaUJBQWlCLEdBQUcsRUFBeEI7QUFDQSxRQUFJQyxtQkFBbUIsR0FBRyxHQUExQjtBQUVBLFdBQU8sSUFBSXBsQixTQUFKLENBQWMsY0FBZCxFQUE4QjtBQUNqQ2MsWUFBTSxFQUFFO0FBQ0pnSCxjQUFNLEVBQUUsRUFESjtBQUVKbEUsY0FBTSxFQUFFLEVBRko7QUFHSm5DLGdCQUFRLEVBQUU7QUFDTjRCLGFBQUcsRUFBRSxlQUFXO0FBQ1osZ0JBQUlpUCxHQUFHLEdBQUcsQ0FBVjs7QUFFQSxnQkFBSW5TLE1BQU0sQ0FBQ00sbUJBQVAsQ0FBMkIsU0FBM0IsQ0FBSixFQUEyQztBQUN2QyxrQkFBSU4sTUFBTSxDQUFDNEwsUUFBUCxDQUFnQjFHLElBQWhCLEVBQXNCLGtCQUF0QixDQUFKLEVBQStDO0FBQzNDaU4sbUJBQUcsR0FBR0EsR0FBRyxHQUFHM0MsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFZckIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLFdBQVgsQ0FBWixFQUFxQyxRQUFyQyxDQUFELENBQXBCO0FBQ0g7QUFDSixhQUpELE1BSU87QUFDSCxrQkFBSTVDLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0IxRyxJQUFoQixFQUFzQixzQkFBdEIsQ0FBSixFQUFtRDtBQUMvQ2lOLG1CQUFHLEdBQUdBLEdBQUcsR0FBRzNDLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBWXJCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxlQUFYLENBQVosRUFBeUMsUUFBekMsQ0FBRCxDQUFwQjtBQUNIO0FBQ0o7O0FBRUQsbUJBQU91UCxHQUFQO0FBQ0gsV0FmSztBQWdCTmhQLGNBQUksRUFBRSxjQUFTdkQsT0FBVCxFQUFrQjtBQUN0QyxnQkFBSXNsQixRQUFRLEdBQUd0bEIsT0FBTyxDQUFDb1IsT0FBUixFQUFmO0FBRUEsbUJBQU9oUixNQUFNLENBQUMySCxNQUFQLENBQWN1ZCxRQUFkLEVBQXdCL2hCLElBQS9CO0FBQ0EsV0FwQm9CO0FBcUJyQnlOLGVBQUssRUFBRSxlQUFTaFIsT0FBVCxFQUFrQjtBQUN4QixnQkFBSXNsQixRQUFRLEdBQUd0bEIsT0FBTyxDQUFDb1IsT0FBUixFQUFmO0FBRUEsZ0JBQUltVSxZQUFZLEdBQUczVixRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVc2akIsUUFBWCxFQUFxQixPQUFyQixDQUFELENBQTNCO0FBQ0EsZ0JBQUlFLFNBQVMsR0FBRzVWLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV3JCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxNQUFYLENBQVgsRUFBK0IsT0FBL0IsQ0FBRCxDQUF4QjtBQUNBLGdCQUFJeWlCLGlCQUFpQixHQUFHcmxCLE1BQU0sQ0FBQzJILE1BQVAsQ0FBY3VkLFFBQWQsRUFBd0IvaEIsSUFBaEQ7QUFFQSxtQkFBT2lpQixTQUFTLEdBQUdELFlBQVosR0FBMkJFLGlCQUFsQztBQUNBO0FBN0JvQjtBQUhOO0FBRHlCLEtBQTlCLENBQVA7QUFxQ0gsR0F6Q0Q7O0FBMkNBLFNBQU87QUFDSDNqQixRQUFJLEVBQUUsZ0JBQVc7QUFDYndELFVBQUksR0FBR2xGLE1BQU0sQ0FBQ2laLFFBQVAsQ0FBZ0IsTUFBaEIsQ0FBUDtBQUVBLFdBQUtpTCxTQUFMO0FBQ0EsV0FBS1csYUFBTDtBQUNBLFdBQUtFLHFCQUFMLEdBTGEsQ0FPYjs7QUFDQWptQixPQUFDLENBQUMsMkJBQUQsQ0FBRCxDQUErQk0sRUFBL0IsQ0FBa0MsT0FBbEMsRUFBMkMsMENBQTNDLEVBQXVGLFVBQVM0QixDQUFULEVBQVk7QUFDL0Zza0IsWUFBSSxDQUFDLEVBQUQsRUFBSyxrREFBTCxDQUFKO0FBRUF0a0IsU0FBQyxDQUFDZ0YsY0FBRjtBQUNILE9BSkQ7QUFLSCxLQWRFO0FBZ0JIa2UsYUFBUyxFQUFFLHFCQUFXO0FBQ2xCQSxnQkFBUztBQUNaLEtBbEJFO0FBb0JIVyxpQkFBYSxFQUFFLHlCQUFXO0FBQ3RCQSxvQkFBYTtBQUNoQixLQXRCRTtBQXdCSEUseUJBQXFCLEVBQUUsaUNBQVc7QUFDOUIsVUFBSSxDQUFDL2tCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxjQUFYLENBQUwsRUFBaUM7QUFDN0I7QUFDSDs7QUFFRHFoQix1QkFBaUIsR0FBR2Msc0JBQXFCLEVBQXpDO0FBQ0FkLHVCQUFpQixDQUFDdmpCLFVBQWxCO0FBRUFWLFlBQU0sQ0FBQzZPLGdCQUFQLENBQXdCLFlBQVU7QUFDOUJvVix5QkFBaUIsQ0FBQ3hULFlBQWxCO0FBQ0gsT0FGRDs7QUFJQXNVLDRCQUFxQjtBQUN4QixLQXJDRTtBQXVDSFEsZ0JBQVksRUFBRSx3QkFBVztBQUNyQixhQUFPeEIsU0FBUDtBQUNILEtBekNFO0FBMkNIeUIsaUNBQTZCLEVBQUUseUNBQVc7QUFDdEMsVUFBSXhsQixNQUFNLENBQUNtWCxjQUFQLEVBQUosRUFBNkI7QUFDekI2TSwwQkFBa0IsQ0FBQ3ZqQixJQUFuQjtBQUNIO0FBQ0osS0EvQ0U7QUFpREhnbEIsa0NBQThCLEVBQUUsMENBQVc7QUFDdkMsVUFBSXpsQixNQUFNLENBQUNtWCxjQUFQLEVBQUosRUFBNkI7QUFDekJ1TywyQkFBbUIsQ0FBQ2psQixJQUFwQjtBQUNIO0FBQ0o7QUFyREUsR0FBUDtBQXVESCxDQXZNYyxFQUFmLEMsQ0F5TUE7OztBQUNBLElBQUksSUFBSixFQUFtQztBQUMvQmlFLFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQmtmLFFBQWpCO0FBQ0gsQyxDQUVEOzs7QUFDQTdqQixNQUFNLENBQUM2RSxLQUFQLENBQWEsWUFBVztBQUNwQmdmLFVBQVEsQ0FBQ25pQixJQUFUO0FBQ0gsQ0FGRCxFOzs7Ozs7Ozs7OztBQ2hOQTtBQUNBLElBQUlpa0IsS0FBSyxHQUFHLFlBQVc7QUFFbkIsU0FBTztBQUNIQyxpQkFBYSxFQUFFLHVCQUFTL2YsR0FBVCxFQUFjdkgsSUFBZCxFQUFvQnVuQixLQUFwQixFQUEyQnppQixNQUEzQixFQUFtQzBpQixJQUFuQyxFQUF5Q3BuQixPQUF6QyxFQUFrRDtBQUM3RCxVQUFJbUgsR0FBRyxDQUFDcEUsTUFBSixLQUFlLENBQW5CLEVBQXNCO0FBQ2xCO0FBQ0gsT0FINEQsQ0FLN0Q7OztBQUNBcWtCLFVBQUksR0FBSSxPQUFPQSxJQUFQLEtBQWdCLFdBQWpCLEdBQWdDQSxJQUFoQyxHQUF1QyxLQUE5QztBQUNBcG5CLGFBQU8sR0FBSSxPQUFPQSxPQUFQLEtBQW1CLFdBQXBCLEdBQW1DQSxPQUFuQyxHQUE2QyxLQUF2RDtBQUVBLFVBQUlxbkIsTUFBTSxHQUFHO0FBQ1QvakIsWUFBSSxFQUFFLE1BREc7QUFFVDFELFlBQUksRUFBRTtBQUNGMG5CLGdCQUFNLEVBQUUsQ0FBQyxTQUFELEVBQVksVUFBWixFQUF3QixPQUF4QixFQUFpQyxPQUFqQyxFQUEwQyxLQUExQyxFQUFpRCxNQUFqRCxFQUF5RCxNQUF6RCxFQUFpRSxRQUFqRSxFQUEyRSxXQUEzRSxFQUF3RixTQUF4RixDQUROO0FBRUZDLGtCQUFRLEVBQUUsQ0FBQztBQUNQQyxpQkFBSyxFQUFFLEVBREE7QUFFUEMsdUJBQVcsRUFBRU4sS0FGTjtBQUdQTyx1QkFBVyxFQUFFaGpCLE1BSE47QUFJUGlqQiw0QkFBZ0IsRUFBRSxDQUpYO0FBS1BDLGlDQUFxQixFQUFFLENBTGhCO0FBTVBDLGdDQUFvQixFQUFFQyxLQUFLLENBQUNDLE9BQU4sQ0FBY1osS0FBZCxDQUFvQixTQUFwQixFQUErQmEsS0FBL0IsQ0FBcUMsQ0FBckMsRUFBd0NDLFNBQXhDLEVBTmY7QUFPUEMsNEJBQWdCLEVBQUVKLEtBQUssQ0FBQ0MsT0FBTixDQUFjWixLQUFkLENBQW9CLFNBQXBCLEVBQStCYSxLQUEvQixDQUFxQyxDQUFyQyxFQUF3Q0MsU0FBeEMsRUFQWDtBQVFQRSxxQ0FBeUIsRUFBRTVvQixLQUFLLENBQUNxRyxhQUFOLENBQW9CLE9BQXBCLENBUnBCO0FBU1B3aUIsaUNBQXFCLEVBQUVOLEtBQUssQ0FBQ0MsT0FBTixDQUFjWixLQUFkLENBQW9CLFNBQXBCLEVBQStCYSxLQUEvQixDQUFxQyxHQUFyQyxFQUEwQ0MsU0FBMUMsRUFUaEI7QUFVUGIsZ0JBQUksRUFBRUEsSUFWQztBQVdQeGlCLDJCQUFlLEVBQUV1aUIsS0FYVjtBQVlQdm5CLGdCQUFJLEVBQUVBO0FBWkMsV0FBRDtBQUZSLFNBRkc7QUFtQlRxQixlQUFPLEVBQUU7QUFDTHlPLGVBQUssRUFBRTtBQUNIMFIsbUJBQU8sRUFBRTtBQUROLFdBREY7QUFJTC9QLGtCQUFRLEVBQUdyUixPQUFPLEdBQUc7QUFDakJxb0IsbUJBQU8sRUFBRSxJQURRO0FBRWpCQyxxQkFBUyxFQUFFLEtBRk07QUFHakJuYyxnQkFBSSxFQUFFLFNBSFc7QUFJakJvYyx1QkFBVyxFQUFFLENBSkk7QUFLakJDLG9CQUFRLEVBQUUsRUFMTztBQU1qQkMsb0JBQVEsRUFBRSxFQU5PO0FBT2pCQyx3QkFBWSxFQUFFLENBUEc7QUFRakJDLHlCQUFhLEVBQUUsS0FSRTtBQVNqQi9qQiwyQkFBZSxFQUFFckYsS0FBSyxDQUFDcUcsYUFBTixDQUFvQixPQUFwQixDQVRBO0FBVWpCZ2pCLDBCQUFjLEVBQUUsU0FWQztBQVdqQkMsd0JBQVksRUFBRSxDQVhHO0FBWWpCQyx5QkFBYSxFQUFFLENBWkU7QUFhakJDLHdCQUFZLEVBQUU7QUFiRyxXQUFILEdBY2QsS0FsQkM7QUFtQkxDLGdCQUFNLEVBQUU7QUFDSjVILG1CQUFPLEVBQUUsS0FETDtBQUVKa0csa0JBQU0sRUFBRTtBQUNKMkIsMkJBQWEsRUFBRTtBQURYO0FBRkosV0FuQkg7QUF5QkxDLG9CQUFVLEVBQUUsS0F6QlA7QUEwQkxDLDZCQUFtQixFQUFFLElBMUJoQjtBQTJCTEMsZUFBSyxFQUFFO0FBQ0hqZCxnQkFBSSxFQUFFO0FBREgsV0EzQkY7QUE4QkxrZCxnQkFBTSxFQUFFO0FBQ0pDLGlCQUFLLEVBQUUsQ0FBQztBQUNKbEkscUJBQU8sRUFBRSxLQURMO0FBRUptSSx1QkFBUyxFQUFFLEtBRlA7QUFHSkMsd0JBQVUsRUFBRTtBQUNScEksdUJBQU8sRUFBRSxLQUREO0FBRVJxSSwyQkFBVyxFQUFFO0FBRkw7QUFIUixhQUFELENBREg7QUFTSkMsaUJBQUssRUFBRSxDQUFDO0FBQ0p0SSxxQkFBTyxFQUFFLEtBREw7QUFFSm1JLHVCQUFTLEVBQUUsS0FGUDtBQUdKQyx3QkFBVSxFQUFFO0FBQ1JwSSx1QkFBTyxFQUFFLEtBREQ7QUFFUnFJLDJCQUFXLEVBQUU7QUFGTDtBQUhSLGFBQUQ7QUFUSCxXQTlCSDtBQWlETEUsa0JBQVEsRUFBRTtBQUNOQyxnQkFBSSxFQUFFO0FBQ0ZDLHFCQUFPLEVBQUU7QUFEUCxhQURBO0FBSU5DLGlCQUFLLEVBQUU7QUFDSEMsb0JBQU0sRUFBRSxDQURMO0FBRUhyQyx5QkFBVyxFQUFFO0FBRlY7QUFKRCxXQWpETDtBQTJETHNDLGdCQUFNLEVBQUU7QUFDSnJsQixtQkFBTyxFQUFFO0FBQ0xGLGtCQUFJLEVBQUUsQ0FERDtBQUVMeU4sbUJBQUssRUFBRSxDQUZGO0FBR0wxTixpQkFBRyxFQUFFLENBSEE7QUFJTHdoQixvQkFBTSxFQUFFO0FBSkg7QUFETDtBQTNESDtBQW5CQSxPQUFiO0FBeUZBLFVBQUlpRSxLQUFLLEdBQUcsSUFBSW5DLEtBQUosQ0FBVTNnQixHQUFWLEVBQWVrZ0IsTUFBZixDQUFaO0FBQ0gsS0FwR0U7QUFzR0g2QyxtQkFBZSxFQUFFLHlCQUFTL2lCLEdBQVQsRUFBY3ZILElBQWQsRUFBb0J5VixHQUFwQixFQUF5QjhSLEtBQXpCLEVBQWdDemlCLE1BQWhDLEVBQXdDO0FBQ3JELFVBQUksQ0FBQ1YsUUFBUSxDQUFDbVcsY0FBVCxDQUF3QmhULEdBQXhCLENBQUwsRUFBbUM7QUFDL0I7QUFDSDs7QUFFRCxVQUFJekMsTUFBTSxHQUFHQSxNQUFNLEdBQUdBLE1BQUgsR0FBWSxDQUEvQixDQUxxRCxDQU9yRDs7QUFDQSxVQUFJeWxCLEdBQUcsR0FBR25tQixRQUFRLENBQUNtVyxjQUFULENBQXdCaFQsR0FBeEIsRUFBNkJpakIsVUFBN0IsQ0FBd0MsSUFBeEMsQ0FBVjtBQUVBLFVBQUlDLFFBQVEsR0FBR0YsR0FBRyxDQUFDRyxvQkFBSixDQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxHQUFsQyxDQUFmO0FBQ0FELGNBQVEsQ0FBQ0UsWUFBVCxDQUFzQixDQUF0QixFQUF5QnpDLEtBQUssQ0FBQ0MsT0FBTixDQUFjWixLQUFkLENBQW9CQSxLQUFwQixFQUEyQmEsS0FBM0IsQ0FBaUMsR0FBakMsRUFBc0NDLFNBQXRDLEVBQXpCO0FBQ0FvQyxjQUFRLENBQUNFLFlBQVQsQ0FBc0IsQ0FBdEIsRUFBeUJ6QyxLQUFLLENBQUNDLE9BQU4sQ0FBY1osS0FBZCxDQUFvQkEsS0FBcEIsRUFBMkJhLEtBQTNCLENBQWlDLENBQWpDLEVBQW9DQyxTQUFwQyxFQUF6QjtBQUVBLFVBQUl1QyxVQUFVLEdBQUc7QUFDYmxuQixZQUFJLEVBQUUsTUFETztBQUViMUQsWUFBSSxFQUFFO0FBQ0YwbkIsZ0JBQU0sRUFBRSxDQUFDLFNBQUQsRUFBWSxVQUFaLEVBQXdCLE9BQXhCLEVBQWlDLE9BQWpDLEVBQTBDLEtBQTFDLEVBQWlELE1BQWpELEVBQXlELE1BQXpELEVBQWlFLFFBQWpFLEVBQTJFLFdBQTNFLEVBQXdGLFNBQXhGLENBRE47QUFFRkMsa0JBQVEsRUFBRSxDQUFDO0FBQ1BDLGlCQUFLLEVBQUUsUUFEQTtBQUVQQyx1QkFBVyxFQUFFTixLQUZOO0FBR1BPLHVCQUFXLEVBQUVoakIsTUFITjtBQUlQRSwyQkFBZSxFQUFFeWxCLFFBSlY7QUFLUHhDLGdDQUFvQixFQUFFdG9CLEtBQUssQ0FBQ3FHLGFBQU4sQ0FBb0IsT0FBcEIsQ0FMZjtBQU1QaEcsZ0JBQUksRUFBRUE7QUFOQyxXQUFEO0FBRlIsU0FGTztBQWFicUIsZUFBTyxFQUFFO0FBQ0xpb0Isb0JBQVUsRUFBRSxJQURQO0FBRUxDLDZCQUFtQixFQUFFLEtBRmhCO0FBR0x6WixlQUFLLEVBQUU7QUFDSDBSLG1CQUFPLEVBQUUsS0FETjtBQUVIM1IsZ0JBQUksRUFBRTtBQUZILFdBSEY7QUFPTDRCLGtCQUFRLEVBQUU7QUFDTmdYLG1CQUFPLEVBQUUsSUFESDtBQUVOQyxxQkFBUyxFQUFFLEtBRkw7QUFHTm5jLGdCQUFJLEVBQUUsU0FIQTtBQUlOb2MsdUJBQVcsRUFBRSxDQUpQO0FBS05DLG9CQUFRLEVBQUUsRUFMSjtBQU1OQyxvQkFBUSxFQUFFLEVBTko7QUFPTkMsd0JBQVksRUFBRSxDQVBSO0FBUU5DLHlCQUFhLEVBQUUsS0FSVDtBQVNOL2pCLDJCQUFlLEVBQUVyRixLQUFLLENBQUNxRyxhQUFOLENBQW9CLE9BQXBCLENBVFg7QUFVTmdqQiwwQkFBYyxFQUFFLFNBVlY7QUFXTkMsd0JBQVksRUFBRSxDQVhSO0FBWU5DLHlCQUFhLEVBQUUsQ0FaVDtBQWFOQyx3QkFBWSxFQUFFO0FBYlIsV0FQTDtBQXNCTEMsZ0JBQU0sRUFBRTtBQUNKNUgsbUJBQU8sRUFBRSxLQURMO0FBRUprRyxrQkFBTSxFQUFFO0FBQ0oyQiwyQkFBYSxFQUFFO0FBRFg7QUFGSixXQXRCSDtBQTRCTEcsZUFBSyxFQUFFO0FBQ0hqZCxnQkFBSSxFQUFFO0FBREgsV0E1QkY7QUErQkxrZCxnQkFBTSxFQUFFO0FBQ0pDLGlCQUFLLEVBQUUsQ0FBQztBQUNKbEkscUJBQU8sRUFBRSxLQURMO0FBRUpvSSx3QkFBVSxFQUFFO0FBQ1JwSSx1QkFBTyxFQUFFLEtBREQ7QUFFUnFJLDJCQUFXLEVBQUU7QUFGTCxlQUZSO0FBTUpnQixtQkFBSyxFQUFFO0FBQ0hySix1QkFBTyxFQUFFLEtBRE47QUFFSHNKLDJCQUFXLEVBQUU7QUFGVjtBQU5ILGFBQUQsQ0FESDtBQVlKaEIsaUJBQUssRUFBRSxDQUFDO0FBQ0p0SSxxQkFBTyxFQUFFLEtBREw7QUFFSm9JLHdCQUFVLEVBQUU7QUFDUnBJLHVCQUFPLEVBQUUsS0FERDtBQUVScUksMkJBQVcsRUFBRTtBQUZMLGVBRlI7QUFNSkYsdUJBQVMsRUFBRTtBQUNQcEMscUJBQUssRUFBRSxTQURBO0FBRVB3RCwwQkFBVSxFQUFFLEtBRkw7QUFHUEMsK0JBQWUsRUFBRSxJQUhWO0FBSVBDLHlCQUFTLEVBQUU7QUFKSixlQU5QO0FBWUpKLG1CQUFLLEVBQUU7QUFDSHBWLG1CQUFHLEVBQUVBLEdBREY7QUFFSCtMLHVCQUFPLEVBQUUsS0FGTjtBQUdIc0osMkJBQVcsRUFBRTtBQUhWO0FBWkgsYUFBRDtBQVpILFdBL0JIO0FBOERMZixrQkFBUSxFQUFFO0FBQ05HLGlCQUFLLEVBQUU7QUFDSEMsb0JBQU0sRUFBRSxDQURMO0FBRUhyQyx5QkFBVyxFQUFFLENBRlY7QUFHSG9ELHlCQUFXLEVBQUUsQ0FIVjtBQUlIQyw4QkFBZ0IsRUFBRTtBQUpmO0FBREQsV0E5REw7QUFzRUxmLGdCQUFNLEVBQUU7QUFDSnJsQixtQkFBTyxFQUFFO0FBQ0xGLGtCQUFJLEVBQUUsQ0FERDtBQUVMeU4sbUJBQUssRUFBRSxDQUZGO0FBR0wxTixpQkFBRyxFQUFFLENBSEE7QUFJTHdoQixvQkFBTSxFQUFFO0FBSkg7QUFETDtBQXRFSDtBQWJJLE9BQWpCO0FBOEZBLFVBQUlpRSxLQUFLLEdBQUcsSUFBSW5DLEtBQUosQ0FBVXFDLEdBQVYsRUFBZUssVUFBZixDQUFaLENBNUdxRCxDQThHckQ7O0FBQ0FscEIsWUFBTSxDQUFDNk8sZ0JBQVAsQ0FBd0IsWUFBVztBQUMvQjhaLGFBQUssQ0FBQ2xmLE1BQU47QUFDSCxPQUZEO0FBR0g7QUF4TkUsR0FBUDtBQTBOSCxDQTVOVyxFQUFaLEMsQ0E4TkE7OztBQUNBLElBQUksSUFBSixFQUFtQztBQUMvQi9FLFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQmdoQixLQUFqQjtBQUNILEM7Ozs7Ozs7Ozs7OztBQ2xPWTs7QUFFYixJQUFJK0QsZ0JBQWdCLEdBQUcsWUFBVztBQUM5QixNQUFJQyxpQkFBaUIsR0FBRzNwQixNQUFNLENBQUM0QyxHQUFQLENBQVcsaUNBQVgsQ0FBeEI7QUFDQSxNQUFJZ25CLGlCQUFpQixHQUFHNXBCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxpQ0FBWCxDQUF4QjtBQUNBLE1BQUlpbkIsWUFBWSxHQUFHN3BCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVywyQkFBWCxDQUFuQjtBQUNBLE1BQUlrbkIsV0FBVyxHQUFHOXBCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVywwQkFBWCxDQUFsQjs7QUFFQSxNQUFJbW5CLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsR0FBVztBQUMvQixRQUFJM1osSUFBSSxHQUFHcFEsTUFBTSxDQUFDa0IsSUFBUCxDQUFZeW9CLGlCQUFaLEVBQStCLHdCQUEvQixDQUFYO0FBQ0EsUUFBSXprQixJQUFJLEdBQUdsRixNQUFNLENBQUNrQixJQUFQLENBQVl5b0IsaUJBQVosRUFBK0Isd0JBQS9CLENBQVg7QUFFQSxRQUFJSyxTQUFTLEdBQUcsSUFBSWpiLFdBQUosQ0FBZ0I0YSxpQkFBaEIsRUFBbUM7QUFDL0MzYSxhQUFPLEVBQUUsSUFEc0M7QUFFL0NFLGVBQVMsRUFBRSxpQkFGb0M7QUFHL0NLLGFBQU8sRUFBRSx1Q0FIc0M7QUFJL0NGLGNBQVEsRUFBRTtBQUpxQyxLQUFuQyxDQUFoQjtBQU9BclAsVUFBTSxDQUFDQyxVQUFQLENBQWtCaUYsSUFBbEIsRUFBd0I7QUFDcEJ5ZCxzQkFBZ0IsRUFBRSxJQURFO0FBRXBCclksMEJBQW9CLEVBQUUsSUFGRjtBQUdwQm5LLHdCQUFrQixFQUFFLElBSEE7QUFJcEJFLFlBQU0sRUFBRSxrQkFBVztBQUNmLFlBQUlBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ2tJLFdBQVAsR0FBcUI3SCxNQUF0QixDQUFyQjs7QUFFQSxZQUFJK1AsSUFBSixFQUFVO0FBQ04vUCxnQkFBTSxHQUFHQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNxZSxZQUFQLENBQW9Cak8sSUFBcEIsQ0FBRCxDQUExQjtBQUNBL1AsZ0JBQU0sR0FBR0EsTUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXK08sSUFBWCxFQUFpQixjQUFqQixDQUFELENBQTFCO0FBQ0g7O0FBRUQvUCxjQUFNLEdBQUdBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV3NvQixpQkFBWCxFQUE4QixZQUE5QixDQUFELENBQTFCO0FBQ0F0cEIsY0FBTSxHQUFHQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVdzb0IsaUJBQVgsRUFBOEIsZUFBOUIsQ0FBRCxDQUExQjtBQUVBLGVBQU90cEIsTUFBUDtBQUNIO0FBaEJtQixLQUF4QjtBQWtCSCxHQTdCRDs7QUErQkEsTUFBSTRwQixnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLEdBQVc7QUFDOUIsUUFBSTdaLElBQUksR0FBR3BRLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTBvQixpQkFBWixFQUErQix3QkFBL0IsQ0FBWDtBQUNBLFFBQUkxa0IsSUFBSSxHQUFHbEYsTUFBTSxDQUFDa0IsSUFBUCxDQUFZMG9CLGlCQUFaLEVBQStCLHdCQUEvQixDQUFYO0FBRUEsUUFBSUksU0FBUyxHQUFHLElBQUlqYixXQUFKLENBQWdCNmEsaUJBQWhCLEVBQW1DO0FBQy9DNWEsYUFBTyxFQUFFLElBRHNDO0FBRS9DRSxlQUFTLEVBQUUsaUJBRm9DO0FBRy9DSyxhQUFPLEVBQUUsdUNBSHNDO0FBSS9DRixjQUFRLEVBQUU7QUFKcUMsS0FBbkMsQ0FBaEI7QUFPQXJQLFVBQU0sQ0FBQ0MsVUFBUCxDQUFrQmlGLElBQWxCLEVBQXdCO0FBQ3BCeWQsc0JBQWdCLEVBQUUsSUFERTtBQUVwQnJZLDBCQUFvQixFQUFFLElBRkY7QUFHcEJuSyx3QkFBa0IsRUFBRSxJQUhBO0FBSXBCRSxZQUFNLEVBQUUsa0JBQVc7QUFDZixZQUFJQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNrSSxXQUFQLEdBQXFCN0gsTUFBdEIsQ0FBckI7O0FBRUEsWUFBSStQLElBQUosRUFBVTtBQUNOL1AsZ0JBQU0sR0FBR0EsTUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcWUsWUFBUCxDQUFvQmpPLElBQXBCLENBQUQsQ0FBMUI7QUFDQS9QLGdCQUFNLEdBQUdBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBVytPLElBQVgsRUFBaUIsY0FBakIsQ0FBRCxDQUExQjtBQUNIOztBQUVEL1AsY0FBTSxHQUFHQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVd1b0IsaUJBQVgsRUFBOEIsWUFBOUIsQ0FBRCxDQUExQjtBQUNBdnBCLGNBQU0sR0FBR0EsTUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXdW9CLGlCQUFYLEVBQThCLGVBQTlCLENBQUQsQ0FBMUI7QUFFQSxlQUFPdnBCLE1BQVA7QUFDSDtBQWhCbUIsS0FBeEI7QUFrQkgsR0E3QkQ7O0FBK0JBLE1BQUk2cEIsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBVztBQUN6QixRQUFJOVosSUFBSSxHQUFHcFEsTUFBTSxDQUFDa0IsSUFBUCxDQUFZMm9CLFlBQVosRUFBMEIsd0JBQTFCLENBQVg7QUFDQSxRQUFJM2tCLElBQUksR0FBR2xGLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTJvQixZQUFaLEVBQTBCLHdCQUExQixDQUFYO0FBRUEsUUFBSUcsU0FBUyxHQUFHLElBQUlqYixXQUFKLENBQWdCOGEsWUFBaEIsRUFBOEI7QUFDMUM3YSxhQUFPLEVBQUUsSUFEaUM7QUFFMUNFLGVBQVMsRUFBRSxpQkFGK0I7QUFHMUNLLGFBQU8sRUFBRSxpQ0FIaUM7QUFJMUNGLGNBQVEsRUFBRTtBQUpnQyxLQUE5QixDQUFoQjtBQU9BclAsVUFBTSxDQUFDQyxVQUFQLENBQWtCaUYsSUFBbEIsRUFBd0I7QUFDcEJ5ZCxzQkFBZ0IsRUFBRSxJQURFO0FBRXBCclksMEJBQW9CLEVBQUUsSUFGRjtBQUdwQm5LLHdCQUFrQixFQUFFLElBSEE7QUFJcEJFLFlBQU0sRUFBRSxrQkFBVztBQUNmLFlBQUlBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ2tJLFdBQVAsR0FBcUI3SCxNQUF0QixDQUFyQjs7QUFFQSxZQUFJK1AsSUFBSixFQUFVO0FBQ04vUCxnQkFBTSxHQUFHQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNxZSxZQUFQLENBQW9Cak8sSUFBcEIsQ0FBRCxDQUExQjtBQUNBL1AsZ0JBQU0sR0FBR0EsTUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXK08sSUFBWCxFQUFpQixjQUFqQixDQUFELENBQTFCO0FBQ0g7O0FBRUQvUCxjQUFNLEdBQUdBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV3dvQixZQUFYLEVBQXlCLFlBQXpCLENBQUQsQ0FBMUI7QUFDQXhwQixjQUFNLEdBQUdBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV3dvQixZQUFYLEVBQXlCLGVBQXpCLENBQUQsQ0FBMUI7QUFFQSxlQUFPeHBCLE1BQVA7QUFDSDtBQWhCbUIsS0FBeEI7QUFrQkgsR0E3QkQ7O0FBK0JBLE1BQUk4cEIsVUFBVSxHQUFHLFNBQWJBLFVBQWEsR0FBVztBQUN4QixRQUFJL1osSUFBSSxHQUFHcFEsTUFBTSxDQUFDa0IsSUFBUCxDQUFZNG9CLFdBQVosRUFBeUIsd0JBQXpCLENBQVg7QUFDQSxRQUFJNWtCLElBQUksR0FBR2xGLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTRvQixXQUFaLEVBQXlCLHdCQUF6QixDQUFYO0FBQ0EsUUFBSS9TLE1BQU0sR0FBRy9XLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyx3QkFBWCxDQUFiO0FBQ0EsUUFBSXduQixJQUFJLEdBQUdwcUIsTUFBTSxDQUFDa0IsSUFBUCxDQUFZNlYsTUFBWixFQUFvQixxQkFBcEIsQ0FBWDtBQUNBLFFBQUlzVCxPQUFPLEdBQUdycUIsTUFBTSxDQUFDa0IsSUFBUCxDQUFZNlYsTUFBWixFQUFvQix3QkFBcEIsQ0FBZDtBQUVBLFFBQUlpVCxTQUFTLEdBQUcsSUFBSWpiLFdBQUosQ0FBZ0IrYSxXQUFoQixFQUE2QjtBQUN6QzlhLGFBQU8sRUFBRSxJQURnQztBQUV6Q0UsZUFBUyxFQUFFLGlCQUY4QjtBQUd6Q0ssYUFBTyxFQUFFLGdDQUhnQztBQUl6Q0YsY0FBUSxFQUFFO0FBSitCLEtBQTdCLENBQWhCO0FBT0FyUCxVQUFNLENBQUNDLFVBQVAsQ0FBa0JvcUIsT0FBbEIsRUFBMkI7QUFDdkIxSCxzQkFBZ0IsRUFBRSxJQURLO0FBRXZCclksMEJBQW9CLEVBQUUsSUFGQztBQUd2Qm5LLHdCQUFrQixFQUFFLElBSEc7QUFJdkJFLFlBQU0sRUFBRSxrQkFBVztBQUNmLFlBQUlBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ2tJLFdBQVAsR0FBcUI3SCxNQUF0QixDQUFyQjtBQUVBQSxjQUFNLEdBQUdBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FlLFlBQVAsQ0FBb0IrTCxJQUFwQixDQUFELENBQTFCO0FBQ0EvcEIsY0FBTSxHQUFHQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVcrb0IsSUFBWCxFQUFpQixjQUFqQixDQUFELENBQTFCOztBQUVBLFlBQUloYSxJQUFKLEVBQVU7QUFDTi9QLGdCQUFNLEdBQUdBLE1BQU0sR0FBR21QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FlLFlBQVAsQ0FBb0JqTyxJQUFwQixDQUFELENBQTFCO0FBQ0EvUCxnQkFBTSxHQUFHQSxNQUFNLEdBQUdtUCxRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVcrTyxJQUFYLEVBQWlCLGNBQWpCLENBQUQsQ0FBMUI7QUFDSDs7QUFFRC9QLGNBQU0sR0FBR0EsTUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXeW9CLFdBQVgsRUFBd0IsWUFBeEIsQ0FBRCxDQUExQjtBQUNBenBCLGNBQU0sR0FBR0EsTUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDcUIsR0FBUCxDQUFXeW9CLFdBQVgsRUFBd0IsZUFBeEIsQ0FBRCxDQUExQjtBQUVBLGVBQU96cEIsTUFBUDtBQUNIO0FBbkJzQixLQUEzQjtBQXFCSCxHQW5DRDs7QUFxQ0EsU0FBTztBQUNIcUIsUUFBSSxFQUFFLGdCQUFXO0FBQ2Jxb0IsdUJBQWlCO0FBQ2pCRSxzQkFBZ0I7QUFDaEJDLGlCQUFXO0FBQ1hDLGdCQUFVO0FBQ2I7QUFORSxHQUFQO0FBUUgsQ0FoSnNCLEVBQXZCLEMsQ0FrSkE7OztBQUNBbnFCLE1BQU0sQ0FBQzZFLEtBQVAsQ0FBYSxZQUFXO0FBQ3BCNmtCLGtCQUFnQixDQUFDaG9CLElBQWpCO0FBQ0gsQ0FGRCxFOzs7Ozs7Ozs7Ozs7QUNySmE7O0FBRWIsSUFBSTRvQixZQUFZLEdBQUcsWUFBVztBQUMxQixNQUFJQyxLQUFLLEdBQUd2cUIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLGFBQVgsQ0FBWjtBQUNBLE1BQUkrbUIsaUJBQWlCLEdBQUczcEIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLCtCQUFYLENBQXhCO0FBQ0EsTUFBSTRuQixZQUFZLEdBQUd4cUIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLHlCQUFYLENBQW5CO0FBQ0EsTUFBSTZuQixhQUFhLEdBQUd6cUIsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLDBCQUFYLENBQXBCOztBQUVBLE1BQUk4bkIsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixHQUFXO0FBQzlCLFFBQUlycUIsTUFBSjtBQUNBLFFBQUlzcUIsR0FBRyxHQUFHM3FCLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWXFwQixLQUFaLEVBQW1CLHVCQUFuQixDQUFWO0FBQ0EsUUFBSUssT0FBTyxHQUFHNXFCLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWXFwQixLQUFaLEVBQW1CLHdCQUFuQixDQUFkO0FBRUFscUIsVUFBTSxHQUFHbVAsUUFBUSxDQUFDeFAsTUFBTSxDQUFDa0ksV0FBUCxHQUFxQjdILE1BQXRCLENBQVIsR0FDQW1QLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FlLFlBQVAsQ0FBb0JzTSxHQUFwQixDQUFELENBRFIsR0FFQW5iLFFBQVEsQ0FBQ3hQLE1BQU0sQ0FBQ3FCLEdBQVAsQ0FBV3NwQixHQUFYLEVBQWdCLGVBQWhCLENBQUQsQ0FGUixHQUdDLElBQUluYixRQUFRLENBQUN4UCxNQUFNLENBQUNxQixHQUFQLENBQVdzcEIsR0FBWCxFQUFnQixhQUFoQixDQUFELENBSGIsR0FJQSxFQUpUO0FBTUEsV0FBT3RxQixNQUFQO0FBQ0gsR0FaRDs7QUFjQSxNQUFJd3FCLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsR0FBVztBQUMzQixRQUFJYixTQUFTLEdBQUcsSUFBSWpiLFdBQUosQ0FBZ0J3YixLQUFoQixFQUF1QjtBQUNuQ3ZiLGFBQU8sRUFBRSxJQUQwQjtBQUVuQ0UsZUFBUyxFQUFFLGlCQUZ3QjtBQUduQ0ssYUFBTyxFQUFFLHVCQUgwQjtBQUluQ0YsY0FBUSxFQUFFO0FBSnlCLEtBQXZCLENBQWhCO0FBTUgsR0FQRDs7QUFTQSxNQUFJMGEsaUJBQWlCLEdBQUcsU0FBcEJBLGlCQUFvQixHQUFXO0FBQy9CL3BCLFVBQU0sQ0FBQ0MsVUFBUCxDQUFrQjBwQixpQkFBbEIsRUFBcUM7QUFDakNoSCxzQkFBZ0IsRUFBRSxJQURlO0FBRWpDclksMEJBQW9CLEVBQUUsSUFGVztBQUdqQ25LLHdCQUFrQixFQUFFLElBSGE7QUFJakNFLFlBQU0sRUFBRSxrQkFBVztBQUNmLGVBQU9xcUIsZ0JBQWdCLEVBQXZCO0FBQ0g7QUFOZ0MsS0FBckM7QUFRSCxHQVREOztBQVdBLE1BQUlJLFdBQVcsR0FBRyxTQUFkQSxXQUFjLEdBQVc7QUFDekI5cUIsVUFBTSxDQUFDQyxVQUFQLENBQWtCdXFCLFlBQWxCLEVBQWdDO0FBQzVCN0gsc0JBQWdCLEVBQUUsSUFEVTtBQUU1QnJZLDBCQUFvQixFQUFFLElBRk07QUFHNUJuSyx3QkFBa0IsRUFBRSxJQUhRO0FBSTVCRSxZQUFNLEVBQUUsa0JBQVc7QUFDZixlQUFPcXFCLGdCQUFnQixFQUF2QjtBQUNIO0FBTjJCLEtBQWhDO0FBUUgsR0FURDs7QUFXQSxNQUFJSyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxHQUFXO0FBQzFCL3FCLFVBQU0sQ0FBQ0MsVUFBUCxDQUFrQndxQixhQUFsQixFQUFpQztBQUM3QjlILHNCQUFnQixFQUFFLElBRFc7QUFFN0JyWSwwQkFBb0IsRUFBRSxJQUZPO0FBRzdCbkssd0JBQWtCLEVBQUUsSUFIUztBQUk3QkUsWUFBTSxFQUFFLGtCQUFXO0FBQ2YsZUFBT3FxQixnQkFBZ0IsRUFBdkI7QUFDSDtBQU40QixLQUFqQztBQVFILEdBVEQ7O0FBV0EsTUFBSU0sdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUEwQixHQUFXO0FBQ3JDbHNCLEtBQUMsQ0FBQ3lyQixLQUFELENBQUQsQ0FBU3JwQixJQUFULENBQWMsc0JBQWQsRUFBc0M5QixFQUF0QyxDQUF5QyxjQUF6QyxFQUF5RCxVQUFVNEIsQ0FBVixFQUFhO0FBQ2xFaEIsWUFBTSxDQUFDdUssWUFBUCxDQUFvQm9mLGlCQUFwQjtBQUNBM3BCLFlBQU0sQ0FBQ3VLLFlBQVAsQ0FBb0JpZ0IsWUFBcEI7QUFDQXhxQixZQUFNLENBQUN1SyxZQUFQLENBQW9Ca2dCLGFBQXBCO0FBQ0gsS0FKRDtBQUtILEdBTkQ7O0FBUUEsU0FBTztBQUNIL29CLFFBQUksRUFBRSxnQkFBVztBQUNibXBCLG1CQUFhO0FBQ2JkLHVCQUFpQjtBQUNqQmUsaUJBQVc7QUFDWEMsa0JBQVk7QUFDWkMsNkJBQXVCO0FBQzFCO0FBUEUsR0FBUDtBQVNILENBL0VrQixFQUFuQixDLENBaUZBOzs7QUFDQWhyQixNQUFNLENBQUM2RSxLQUFQLENBQWEsWUFBVztBQUNwQnlsQixjQUFZLENBQUM1b0IsSUFBYjtBQUNILENBRkQsRTs7Ozs7Ozs7Ozs7O0FDcEZhOztBQUViLElBQUl1cEIsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFXO0FBQzNCLE1BQUlocUIsTUFBSjtBQUNBLE1BQUltcEIsSUFBSjtBQUNBLE1BQUkxa0IsS0FBSjtBQUNBLE1BQUl3bEIsU0FBSjtBQUNBLE1BQUlDLGFBQUo7QUFDQSxNQUFJQyxjQUFKO0FBQ0EsTUFBSUMsb0JBQUo7QUFDQSxNQUFJQyxVQUFKO0FBQ0EsTUFBSXRmLEtBQUssR0FBRyxFQUFaO0FBRUEsTUFBSXVmLFNBQVMsR0FBRyxLQUFoQjtBQUNBLE1BQUlwaUIsT0FBTyxHQUFHLEtBQWQ7QUFDQSxNQUFJcWlCLFlBQVksR0FBRyxLQUFuQjtBQUNBLE1BQUlDLGNBQWMsR0FBRyxHQUFyQixDQWQyQixDQWNEOztBQUMxQixNQUFJQyxZQUFZLEdBQUcsa0VBQW5CO0FBQ0EsTUFBSUMsV0FBVyxHQUFHLDBCQUFsQjtBQUNBLE1BQUlDLFNBQVMsR0FBRyxDQUFoQjs7QUFFQSxNQUFJQyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxHQUFXO0FBQzFCTCxnQkFBWSxHQUFHLElBQWY7QUFDQXhyQixVQUFNLENBQUNSLFFBQVAsQ0FBZ0I4ckIsVUFBaEIsRUFBNEJJLFlBQTVCOztBQUVBLFFBQUlSLFNBQUosRUFBZTtBQUNYbHJCLFlBQU0sQ0FBQ1MsSUFBUCxDQUFZeXFCLFNBQVo7QUFDSDtBQUNKLEdBUEQ7O0FBU0EsTUFBSVksWUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBVztBQUMxQk4sZ0JBQVksR0FBRyxLQUFmO0FBQ0F4ckIsVUFBTSxDQUFDb0UsV0FBUCxDQUFtQmtuQixVQUFuQixFQUErQkksWUFBL0I7O0FBRUEsUUFBSVIsU0FBSixFQUFlO0FBQ1gsVUFBSXhsQixLQUFLLENBQUNhLEtBQU4sQ0FBWTlFLE1BQVosR0FBcUJtcUIsU0FBekIsRUFBb0M7QUFDaEM1ckIsY0FBTSxDQUFDUyxJQUFQLENBQVl5cUIsU0FBWjtBQUNILE9BRkQsTUFFTztBQUNIbHJCLGNBQU0sQ0FBQ21ILElBQVAsQ0FBWStqQixTQUFaLEVBQXVCLE1BQXZCO0FBQ0g7QUFDSjtBQUNKLEdBWEQ7O0FBYUEsTUFBSWEsWUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBVztBQUMxQixRQUFJVixvQkFBb0IsSUFBSSxDQUFDcnJCLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0J3ZixjQUFoQixFQUFnQyxNQUFoQyxDQUE3QixFQUFzRTtBQUNsRXRzQixPQUFDLENBQUN1c0Isb0JBQUQsQ0FBRCxDQUF3Qm5pQixRQUF4QixDQUFpQyxRQUFqQztBQUNBcEssT0FBQyxDQUFDdXNCLG9CQUFELENBQUQsQ0FBd0JuaUIsUUFBeEIsQ0FBaUMsUUFBakM7QUFDSDtBQUNKLEdBTEQ7O0FBT0EsTUFBSXlGLFlBQVksR0FBRyxTQUFmQSxZQUFlLEdBQVc7QUFDMUIsUUFBSTBjLG9CQUFvQixJQUFJcnJCLE1BQU0sQ0FBQzRMLFFBQVAsQ0FBZ0J3ZixjQUFoQixFQUFnQyxNQUFoQyxDQUE1QixFQUFxRTtBQUNqRXRzQixPQUFDLENBQUN1c0Isb0JBQUQsQ0FBRCxDQUF3Qm5pQixRQUF4QixDQUFpQyxRQUFqQztBQUNIO0FBQ0osR0FKRDs7QUFNQSxNQUFJOGlCLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsR0FBVztBQUMzQixRQUFJVCxTQUFTLElBQUl2ZixLQUFLLEtBQUt0RyxLQUFLLENBQUNhLEtBQWpDLEVBQXdDO0FBQ3BDdWxCLGtCQUFZO0FBQ1o5ckIsWUFBTSxDQUFDUixRQUFQLENBQWdCeUIsTUFBaEIsRUFBd0IwcUIsV0FBeEI7QUFDQUksa0JBQVk7QUFDWi9yQixZQUFNLENBQUN1SyxZQUFQLENBQW9CNGdCLGFBQXBCO0FBRUE7QUFDSDs7QUFFRG5mLFNBQUssR0FBR3RHLEtBQUssQ0FBQ2EsS0FBZDtBQUVBdkcsVUFBTSxDQUFDb0UsV0FBUCxDQUFtQm5ELE1BQW5CLEVBQTJCMHFCLFdBQTNCO0FBQ0FFLGdCQUFZO0FBQ1psZCxnQkFBWTtBQUVabEQsY0FBVSxDQUFDLFlBQVc7QUFDbEIzTSxPQUFDLENBQUNtdEIsSUFBRixDQUFPO0FBQ0hDLFdBQUcsRUFBRSxvRUFERjtBQUVINXRCLFlBQUksRUFBRTtBQUNGME4sZUFBSyxFQUFFQTtBQURMLFNBRkg7QUFLSG1nQixnQkFBUSxFQUFFLE1BTFA7QUFNSEMsZUFBTyxFQUFFLGlCQUFTQyxHQUFULEVBQWM7QUFDbkJkLG1CQUFTLEdBQUcsSUFBWjtBQUNBTyxzQkFBWTtBQUNaOXJCLGdCQUFNLENBQUNSLFFBQVAsQ0FBZ0J5QixNQUFoQixFQUF3QjBxQixXQUF4QjtBQUNBM3JCLGdCQUFNLENBQUNvSCxPQUFQLENBQWUrakIsYUFBZixFQUE4QmtCLEdBQTlCO0FBQ0FOLHNCQUFZO0FBQ1ovckIsZ0JBQU0sQ0FBQ3VLLFlBQVAsQ0FBb0I0Z0IsYUFBcEI7QUFDSCxTQWJFO0FBY0htQixhQUFLLEVBQUUsZUFBU0QsR0FBVCxFQUFjO0FBQ2pCZCxtQkFBUyxHQUFHLEtBQVo7QUFDQU8sc0JBQVk7QUFDWjlyQixnQkFBTSxDQUFDUixRQUFQLENBQWdCeUIsTUFBaEIsRUFBd0IwcUIsV0FBeEI7QUFDQTNyQixnQkFBTSxDQUFDb0gsT0FBUCxDQUFlK2pCLGFBQWYsRUFBOEIsb0ZBQTlCO0FBQ0FZLHNCQUFZO0FBQ1ovckIsZ0JBQU0sQ0FBQ3VLLFlBQVAsQ0FBb0I0Z0IsYUFBcEI7QUFDSDtBQXJCRSxPQUFQO0FBdUJILEtBeEJTLEVBd0JQLElBeEJPLENBQVY7QUF5QkgsR0F6Q0Q7O0FBMkNBLE1BQUlvQixZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFTdnJCLENBQVQsRUFBWTtBQUMzQjBFLFNBQUssQ0FBQ2EsS0FBTixHQUFjLEVBQWQ7QUFDQXlGLFNBQUssR0FBRyxFQUFSO0FBQ0F1ZixhQUFTLEdBQUcsS0FBWjtBQUNBdnJCLFVBQU0sQ0FBQ1MsSUFBUCxDQUFZeXFCLFNBQVo7QUFDQWxyQixVQUFNLENBQUNvRSxXQUFQLENBQW1CbkQsTUFBbkIsRUFBMkIwcUIsV0FBM0I7QUFDQWhkLGdCQUFZO0FBQ2YsR0FQRDs7QUFTQSxNQUFJNmQsWUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBVztBQUMxQixRQUFJOW1CLEtBQUssQ0FBQ2EsS0FBTixDQUFZOUUsTUFBWixHQUFxQm1xQixTQUF6QixFQUFvQztBQUNoQ0Usa0JBQVk7QUFDWm5kLGtCQUFZO0FBRVo7QUFDSDs7QUFFRCxRQUFJNmMsWUFBWSxJQUFJLElBQXBCLEVBQTBCO0FBQ3RCO0FBQ0g7O0FBRUQsUUFBSXJpQixPQUFKLEVBQWE7QUFDVG1DLGtCQUFZLENBQUNuQyxPQUFELENBQVo7QUFDSDs7QUFFREEsV0FBTyxHQUFHc0MsVUFBVSxDQUFDLFlBQVc7QUFDNUJ1Z0IsbUJBQWE7QUFDaEIsS0FGbUIsRUFFakJQLGNBRmlCLENBQXBCO0FBR0gsR0FuQkQ7O0FBcUJBLFNBQU87QUFDSC9wQixRQUFJLEVBQUUsY0FBU3VELE9BQVQsRUFBa0I7QUFDcEI7QUFDQWhFLFlBQU0sR0FBR2dFLE9BQVQ7QUFDQW1sQixVQUFJLEdBQUdwcUIsTUFBTSxDQUFDa0IsSUFBUCxDQUFZRCxNQUFaLEVBQW9CLHFCQUFwQixDQUFQO0FBQ0F5RSxXQUFLLEdBQUcxRixNQUFNLENBQUNrQixJQUFQLENBQVlELE1BQVosRUFBb0Isc0JBQXBCLENBQVI7QUFDQWlxQixlQUFTLEdBQUdsckIsTUFBTSxDQUFDa0IsSUFBUCxDQUFZRCxNQUFaLEVBQW9CLHNCQUFwQixDQUFaO0FBQ0FrcUIsbUJBQWEsR0FBR25yQixNQUFNLENBQUNrQixJQUFQLENBQVlELE1BQVosRUFBb0Isd0JBQXBCLENBQWhCO0FBQ0FtcUIsb0JBQWMsR0FBR3ByQixNQUFNLENBQUNrQixJQUFQLENBQVlELE1BQVosRUFBb0IsZ0JBQXBCLENBQWpCO0FBQ0FvcUIsMEJBQW9CLEdBQUdyckIsTUFBTSxDQUFDa0IsSUFBUCxDQUFZRCxNQUFaLEVBQW9CLDBCQUFwQixDQUF2QjtBQUNBcXFCLGdCQUFVLEdBQUd0ckIsTUFBTSxDQUFDa0IsSUFBUCxDQUFZRCxNQUFaLEVBQW9CLGNBQXBCLENBQWIsQ0FUb0IsQ0FXcEI7O0FBQ0FqQixZQUFNLENBQUMrRixRQUFQLENBQWdCTCxLQUFoQixFQUF1QixPQUF2QixFQUFnQzhtQixZQUFoQztBQUNBeHNCLFlBQU0sQ0FBQytGLFFBQVAsQ0FBZ0JMLEtBQWhCLEVBQXVCLE9BQXZCLEVBQWdDOG1CLFlBQWhDLEVBYm9CLENBZXBCOztBQUNBcEMsVUFBSSxDQUFDcUMsVUFBTCxHQUFrQixVQUFTenJCLENBQVQsRUFBWTtBQUMxQixZQUFJMlgsR0FBRyxHQUFHM1gsQ0FBQyxDQUFDMHJCLFFBQUYsSUFBYzFyQixDQUFDLENBQUMyckIsT0FBaEIsSUFBMkIsQ0FBckM7O0FBQ0EsWUFBSWhVLEdBQUcsSUFBSSxFQUFYLEVBQWU7QUFDWDNYLFdBQUMsQ0FBQ2dGLGNBQUY7QUFDSDtBQUNKLE9BTEQ7O0FBT0FoRyxZQUFNLENBQUMrRixRQUFQLENBQWdCbWxCLFNBQWhCLEVBQTJCLE9BQTNCLEVBQW9DcUIsWUFBcEM7QUFDSDtBQXpCRSxHQUFQO0FBMkJILENBMUpEOztBQTRKQSxJQUFJSyxtQkFBbUIsR0FBRzNCLGFBQTFCLEMsQ0FFQTs7QUFDQWpyQixNQUFNLENBQUM2RSxLQUFQLENBQWEsWUFBVztBQUNwQixNQUFJN0UsTUFBTSxDQUFDNEMsR0FBUCxDQUFXLHVCQUFYLENBQUosRUFBeUM7QUFDckNxb0IsaUJBQWEsR0FBR3ZwQixJQUFoQixDQUFxQjFCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyx1QkFBWCxDQUFyQjtBQUNIOztBQUVELE1BQUk1QyxNQUFNLENBQUM0QyxHQUFQLENBQVcscUJBQVgsQ0FBSixFQUF1QztBQUNuQ2dxQix1QkFBbUIsR0FBR2xyQixJQUF0QixDQUEyQjFCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyxxQkFBWCxDQUEzQjtBQUNIOztBQUVELE1BQUk1QyxNQUFNLENBQUM0QyxHQUFQLENBQVcsd0JBQVgsQ0FBSixFQUEwQztBQUN0Q2dxQix1QkFBbUIsR0FBR2xyQixJQUF0QixDQUEyQjFCLE1BQU0sQ0FBQzRDLEdBQVAsQ0FBVyx3QkFBWCxDQUEzQjtBQUNIO0FBQ0osQ0FaRCxFOzs7Ozs7Ozs7Ozs7QUNqS0E7QUFBQTtBQUFhOztBQUViO0FBRUE7Ozs7O0FBTUE7O0FBQ0FpcUIsbUJBQU8sQ0FBQywrR0FBRCxDQUFQOztBQUVBeGtCLE1BQU0sQ0FBQ3lrQixLQUFQLEdBQWVELG1CQUFPLENBQUMsNENBQUQsQ0FBdEI7QUFDQXhrQixNQUFNLENBQUN6SCxNQUFQLEdBQWdCaXNCLG1CQUFPLENBQUMsb0RBQUQsQ0FBdkI7QUFDQXhrQixNQUFNLENBQUN5YSxnQkFBUCxHQUEwQitKLG1CQUFPLENBQUMsNEdBQUQsQ0FBakM7QUFDQXhrQixNQUFNLENBQUNnYixPQUFQLEdBQWlCd0osbUJBQU8sQ0FBQyw0REFBRCxDQUF4QjtBQUNBeGtCLE1BQU0sQ0FBQytJLE9BQVAsR0FBaUJBLGtEQUFqQixDLENBRUE7O0FBQ0EvSSxNQUFNLENBQUNySSxNQUFQLEdBQWdCNnNCLG1CQUFPLENBQUMsb0ZBQUQsQ0FBdkI7QUFDQXhrQixNQUFNLENBQUNwSyxLQUFQLEdBQWU0dUIsbUJBQU8sQ0FBQyxrRkFBRCxDQUF0QjtBQUNBeGtCLE1BQU0sQ0FBQ3ZELFFBQVAsR0FBa0IrbkIsbUJBQU8sQ0FBQyx3RkFBRCxDQUF6QjtBQUNBeGtCLE1BQU0sQ0FBQ25CLFFBQVAsR0FBa0IybEIsbUJBQU8sQ0FBQyx3RkFBRCxDQUF6QjtBQUNBeGtCLE1BQU0sQ0FBQ2IsUUFBUCxHQUFrQnFsQixtQkFBTyxDQUFDLHdGQUFELENBQXpCO0FBQ0F4a0IsTUFBTSxDQUFDTSxNQUFQLEdBQWdCa2tCLG1CQUFPLENBQUMsb0ZBQUQsQ0FBdkI7QUFDQXhrQixNQUFNLENBQUMwRyxXQUFQLEdBQXFCOGQsbUJBQU8sQ0FBQyw4RkFBRCxDQUE1QjtBQUNBeGtCLE1BQU0sQ0FBQ3hJLFNBQVAsR0FBbUJndEIsbUJBQU8sQ0FBQywwRkFBRCxDQUExQjtBQUNBeGtCLE1BQU0sQ0FBQ3dKLFdBQVAsR0FBcUJnYixtQkFBTyxDQUFDLDhGQUFELENBQTVCO0FBQ0F4a0IsTUFBTSxDQUFDZ0ssUUFBUCxHQUFrQndhLG1CQUFPLENBQUMsd0ZBQUQsQ0FBekIsQyxDQUVBOztBQUNBeGtCLE1BQU0sQ0FBQ3diLFFBQVAsR0FBa0JnSixtQkFBTyxDQUFDLHNFQUFELENBQXpCO0FBQ0F4a0IsTUFBTSxDQUFDc2QsS0FBUCxHQUFla0gsbUJBQU8sQ0FBQyxnRUFBRCxDQUF0Qjs7QUFDQUEsbUJBQU8sQ0FBQyx3RkFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLGdGQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsa0ZBQUQsQ0FBUCxDIiwiZmlsZSI6Ii9qcy90ZW1wbGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXG4gKiBDb250YWluZXIgc3R5bGVcXG4gKi9cXG4ucHMge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xcbiAgb3ZlcmZsb3ctYW5jaG9yOiBub25lO1xcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lO1xcbiAgdG91Y2gtYWN0aW9uOiBhdXRvO1xcbiAgLW1zLXRvdWNoLWFjdGlvbjogYXV0bztcXG59XFxuXFxuLypcXG4gKiBTY3JvbGxiYXIgcmFpbCBzdHlsZXNcXG4gKi9cXG4ucHNfX3JhaWwteCB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgLjJzIGxpbmVhciwgb3BhY2l0eSAuMnMgbGluZWFyO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4ycyBsaW5lYXIsIG9wYWNpdHkgLjJzIGxpbmVhcjtcXG4gIGhlaWdodDogMTVweDtcXG4gIC8qIHRoZXJlIG11c3QgYmUgJ2JvdHRvbScgb3IgJ3RvcCcgZm9yIHBzX19yYWlsLXggKi9cXG4gIGJvdHRvbTogMHB4O1xcbiAgLyogcGxlYXNlIGRvbid0IGNoYW5nZSAncG9zaXRpb24nICovXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5wc19fcmFpbC15IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuMnMgbGluZWFyLCBvcGFjaXR5IC4ycyBsaW5lYXI7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgLjJzIGxpbmVhciwgb3BhY2l0eSAuMnMgbGluZWFyO1xcbiAgd2lkdGg6IDE1cHg7XFxuICAvKiB0aGVyZSBtdXN0IGJlICdyaWdodCcgb3IgJ2xlZnQnIGZvciBwc19fcmFpbC15ICovXFxuICByaWdodDogMDtcXG4gIC8qIHBsZWFzZSBkb24ndCBjaGFuZ2UgJ3Bvc2l0aW9uJyAqL1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4ucHMtLWFjdGl2ZS14ID4gLnBzX19yYWlsLXgsXFxuLnBzLS1hY3RpdmUteSA+IC5wc19fcmFpbC15IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi5wczpob3ZlciA+IC5wc19fcmFpbC14LFxcbi5wczpob3ZlciA+IC5wc19fcmFpbC15LFxcbi5wcy0tZm9jdXMgPiAucHNfX3JhaWwteCxcXG4ucHMtLWZvY3VzID4gLnBzX19yYWlsLXksXFxuLnBzLS1zY3JvbGxpbmcteCA+IC5wc19fcmFpbC14LFxcbi5wcy0tc2Nyb2xsaW5nLXkgPiAucHNfX3JhaWwteSB7XFxuICBvcGFjaXR5OiAwLjY7XFxufVxcblxcbi5wcyAucHNfX3JhaWwteDpob3ZlcixcXG4ucHMgLnBzX19yYWlsLXk6aG92ZXIsXFxuLnBzIC5wc19fcmFpbC14OmZvY3VzLFxcbi5wcyAucHNfX3JhaWwteTpmb2N1cyxcXG4ucHMgLnBzX19yYWlsLXgucHMtLWNsaWNraW5nLFxcbi5wcyAucHNfX3JhaWwteS5wcy0tY2xpY2tpbmcge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIG9wYWNpdHk6IDAuOTtcXG59XFxuXFxuLypcXG4gKiBTY3JvbGxiYXIgdGh1bWIgc3R5bGVzXFxuICovXFxuLnBzX190aHVtYi14IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4ycyBsaW5lYXIsIGhlaWdodCAuMnMgZWFzZS1pbi1vdXQ7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgLjJzIGxpbmVhciwgaGVpZ2h0IC4ycyBlYXNlLWluLW91dDtcXG4gIGhlaWdodDogNnB4O1xcbiAgLyogdGhlcmUgbXVzdCBiZSAnYm90dG9tJyBmb3IgcHNfX3RodW1iLXggKi9cXG4gIGJvdHRvbTogMnB4O1xcbiAgLyogcGxlYXNlIGRvbid0IGNoYW5nZSAncG9zaXRpb24nICovXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5wc19fdGh1bWIteSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuMnMgbGluZWFyLCB3aWR0aCAuMnMgZWFzZS1pbi1vdXQ7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgLjJzIGxpbmVhciwgd2lkdGggLjJzIGVhc2UtaW4tb3V0O1xcbiAgd2lkdGg6IDZweDtcXG4gIC8qIHRoZXJlIG11c3QgYmUgJ3JpZ2h0JyBmb3IgcHNfX3RodW1iLXkgKi9cXG4gIHJpZ2h0OiAycHg7XFxuICAvKiBwbGVhc2UgZG9uJ3QgY2hhbmdlICdwb3NpdGlvbicgKi9cXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLnBzX19yYWlsLXg6aG92ZXIgPiAucHNfX3RodW1iLXgsXFxuLnBzX19yYWlsLXg6Zm9jdXMgPiAucHNfX3RodW1iLXgsXFxuLnBzX19yYWlsLXgucHMtLWNsaWNraW5nIC5wc19fdGh1bWIteCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTk5O1xcbiAgaGVpZ2h0OiAxMXB4O1xcbn1cXG5cXG4ucHNfX3JhaWwteTpob3ZlciA+IC5wc19fdGh1bWIteSxcXG4ucHNfX3JhaWwteTpmb2N1cyA+IC5wc19fdGh1bWIteSxcXG4ucHNfX3JhaWwteS5wcy0tY2xpY2tpbmcgLnBzX190aHVtYi15IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5OTk7XFxuICB3aWR0aDogMTFweDtcXG59XFxuXFxuLyogTVMgc3VwcG9ydHMgKi9cXG5Ac3VwcG9ydHMgKC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZSkge1xcbiAgLnBzIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG8gIWltcG9ydGFudDtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OiBhY3RpdmUpLCAoLW1zLWhpZ2gtY29udHJhc3Q6IG5vbmUpIHtcXG4gIC5wcyB7XFxuICAgIG92ZXJmbG93OiBhdXRvICFpbXBvcnRhbnQ7XFxuICB9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiIsIi8qIVxuICogSmF2YVNjcmlwdCBDb29raWUgdjIuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanMtY29va2llL2pzLWNvb2tpZVxuICpcbiAqIENvcHlyaWdodCAyMDA2LCAyMDE1IEtsYXVzIEhhcnRsICYgRmFnbmVyIEJyYWNrXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHR2YXIgcmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyO1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRcdHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IHRydWU7XG5cdH1cblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRcdHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IHRydWU7XG5cdH1cblx0aWYgKCFyZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIpIHtcblx0XHR2YXIgT2xkQ29va2llcyA9IHdpbmRvdy5Db29raWVzO1xuXHRcdHZhciBhcGkgPSB3aW5kb3cuQ29va2llcyA9IGZhY3RvcnkoKTtcblx0XHRhcGkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHdpbmRvdy5Db29raWVzID0gT2xkQ29va2llcztcblx0XHRcdHJldHVybiBhcGk7XG5cdFx0fTtcblx0fVxufShmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbIGkgXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlIChzKSB7XG5cdFx0cmV0dXJuIHMucmVwbGFjZSgvKCVbMC05QS1aXXsyfSkrL2csIGRlY29kZVVSSUNvbXBvbmVudCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0IChjb252ZXJ0ZXIpIHtcblx0XHRmdW5jdGlvbiBhcGkoKSB7fVxuXG5cdFx0ZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlLCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGF0dHJpYnV0ZXMgPSBleHRlbmQoe1xuXHRcdFx0XHRwYXRoOiAnLydcblx0XHRcdH0sIGFwaS5kZWZhdWx0cywgYXR0cmlidXRlcyk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXR0cmlidXRlcy5leHBpcmVzID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLmV4cGlyZXMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpICogMSArIGF0dHJpYnV0ZXMuZXhwaXJlcyAqIDg2NGUrNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlJ3JlIHVzaW5nIFwiZXhwaXJlc1wiIGJlY2F1c2UgXCJtYXgtYWdlXCIgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuXHRcdFx0YXR0cmlidXRlcy5leHBpcmVzID0gYXR0cmlidXRlcy5leHBpcmVzID8gYXR0cmlidXRlcy5leHBpcmVzLnRvVVRDU3RyaW5nKCkgOiAnJztcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdFx0aWYgKC9eW1xce1xcW10vLnRlc3QocmVzdWx0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXG5cdFx0XHR2YWx1ZSA9IGNvbnZlcnRlci53cml0ZSA/XG5cdFx0XHRcdGNvbnZlcnRlci53cml0ZSh2YWx1ZSwga2V5KSA6XG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8lKDIzfDI0fDI2fDJCfDNBfDNDfDNFfDNEfDJGfDNGfDQwfDVCfDVEfDVFfDYwfDdCfDdEfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpO1xuXG5cdFx0XHRrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGtleSkpXG5cdFx0XHRcdC5yZXBsYWNlKC8lKDIzfDI0fDI2fDJCfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0XHRcdC5yZXBsYWNlKC9bXFwoXFwpXS9nLCBlc2NhcGUpO1xuXG5cdFx0XHR2YXIgc3RyaW5naWZpZWRBdHRyaWJ1dGVzID0gJyc7XG5cdFx0XHRmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyaW5naWZpZWRBdHRyaWJ1dGVzICs9ICc7ICcgKyBhdHRyaWJ1dGVOYW1lO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29uc2lkZXJzIFJGQyA2MjY1IHNlY3Rpb24gNS4yOlxuXHRcdFx0XHQvLyAuLi5cblx0XHRcdFx0Ly8gMy4gIElmIHRoZSByZW1haW5pbmcgdW5wYXJzZWQtYXR0cmlidXRlcyBjb250YWlucyBhICV4M0IgKFwiO1wiKVxuXHRcdFx0XHQvLyAgICAgY2hhcmFjdGVyOlxuXHRcdFx0XHQvLyBDb25zdW1lIHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHVwIHRvLFxuXHRcdFx0XHQvLyBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpIGNoYXJhY3Rlci5cblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnPScgKyBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLnNwbGl0KCc7JylbMF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgKyBzdHJpbmdpZmllZEF0dHJpYnV0ZXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldCAoa2V5LCBqc29uKSB7XG5cdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBqYXIgPSB7fTtcblx0XHRcdC8vIFRvIHByZXZlbnQgdGhlIGZvciBsb29wIGluIHRoZSBmaXJzdCBwbGFjZSBhc3NpZ24gYW4gZW1wdHkgYXJyYXlcblx0XHRcdC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNvb2tpZXMgYXQgYWxsLlxuXHRcdFx0dmFyIGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUgPyBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsgJykgOiBbXTtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0Zm9yICg7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IGNvb2tpZXNbaV0uc3BsaXQoJz0nKTtcblx0XHRcdFx0dmFyIGNvb2tpZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJz0nKTtcblxuXHRcdFx0XHRpZiAoIWpzb24gJiYgY29va2llLmNoYXJBdCgwKSA9PT0gJ1wiJykge1xuXHRcdFx0XHRcdGNvb2tpZSA9IGNvb2tpZS5zbGljZSgxLCAtMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gZGVjb2RlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHRjb29raWUgPSAoY29udmVydGVyLnJlYWQgfHwgY29udmVydGVyKShjb29raWUsIG5hbWUpIHx8XG5cdFx0XHRcdFx0XHRkZWNvZGUoY29va2llKTtcblxuXHRcdFx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRjb29raWUgPSBKU09OLnBhcnNlKGNvb2tpZSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGphcltuYW1lXSA9IGNvb2tpZTtcblxuXHRcdFx0XHRcdGlmIChrZXkgPT09IG5hbWUpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGtleSA/IGphcltrZXldIDogamFyO1xuXHRcdH1cblxuXHRcdGFwaS5zZXQgPSBzZXQ7XG5cdFx0YXBpLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBnZXQoa2V5LCBmYWxzZSAvKiByZWFkIGFzIHJhdyAqLyk7XG5cdFx0fTtcblx0XHRhcGkuZ2V0SlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBnZXQoa2V5LCB0cnVlIC8qIHJlYWQgYXMganNvbiAqLyk7XG5cdFx0fTtcblx0XHRhcGkucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgYXR0cmlidXRlcykge1xuXHRcdFx0c2V0KGtleSwgJycsIGV4dGVuZChhdHRyaWJ1dGVzLCB7XG5cdFx0XHRcdGV4cGlyZXM6IC0xXG5cdFx0XHR9KSk7XG5cdFx0fTtcblxuXHRcdGFwaS5kZWZhdWx0cyA9IHt9O1xuXG5cdFx0YXBpLndpdGhDb252ZXJ0ZXIgPSBpbml0O1xuXG5cdFx0cmV0dXJuIGFwaTtcblx0fVxuXG5cdHJldHVybiBpbml0KGZ1bmN0aW9uICgpIHt9KTtcbn0pKTtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi0yIS4vcGVyZmVjdC1zY3JvbGxiYXIuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LTIhLi9wZXJmZWN0LXNjcm9sbGJhci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi0yIS4vcGVyZmVjdC1zY3JvbGxiYXIuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLyohXG4gKiBwZXJmZWN0LXNjcm9sbGJhciB2MS40LjBcbiAqIChjKSAyMDE4IEh5dW5qZSBKdW5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuUGVyZmVjdFNjcm9sbGJhciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHNldChlbGVtZW50LCBvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbCArIFwicHhcIjtcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtrZXldID0gdmFsO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBkaXYoY2xhc3NOYW1lKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgcmV0dXJuIGRpdjtcbn1cblxudmFyIGVsTWF0Y2hlcyA9XG4gIHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBxdWVyeSkge1xuICBpZiAoIWVsTWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBtYXRjaGluZyBtZXRob2Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4gZWxNYXRjaGVzLmNhbGwoZWxlbWVudCwgcXVlcnkpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5yZW1vdmUpIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcnlDaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsZW1lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gbWF0Y2hlcyhjaGlsZCwgc2VsZWN0b3IpOyB9XG4gICk7XG59XG5cbnZhciBjbHMgPSB7XG4gIG1haW46ICdwcycsXG4gIGVsZW1lbnQ6IHtcbiAgICB0aHVtYjogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIChcInBzX190aHVtYi1cIiArIHgpOyB9LFxuICAgIHJhaWw6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoXCJwc19fcmFpbC1cIiArIHgpOyB9LFxuICAgIGNvbnN1bWluZzogJ3BzX19jaGlsZC0tY29uc3VtZScsXG4gIH0sXG4gIHN0YXRlOiB7XG4gICAgZm9jdXM6ICdwcy0tZm9jdXMnLFxuICAgIGNsaWNraW5nOiAncHMtLWNsaWNraW5nJyxcbiAgICBhY3RpdmU6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoXCJwcy0tYWN0aXZlLVwiICsgeCk7IH0sXG4gICAgc2Nyb2xsaW5nOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKFwicHMtLXNjcm9sbGluZy1cIiArIHgpOyB9LFxuICB9LFxufTtcblxuLypcbiAqIEhlbHBlciBtZXRob2RzXG4gKi9cbnZhciBzY3JvbGxpbmdDbGFzc1RpbWVvdXQgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcblxuZnVuY3Rpb24gYWRkU2Nyb2xsaW5nQ2xhc3MoaSwgeCkge1xuICB2YXIgY2xhc3NMaXN0ID0gaS5lbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIGNsYXNzTmFtZSA9IGNscy5zdGF0ZS5zY3JvbGxpbmcoeCk7XG5cbiAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNjcm9sbGluZ0NsYXNzVGltZW91dFt4XSk7XG4gIH0gZWxzZSB7XG4gICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbGluZ0NsYXNzKGksIHgpIHtcbiAgc2Nyb2xsaW5nQ2xhc3NUaW1lb3V0W3hdID0gc2V0VGltZW91dChcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBpLmlzQWxpdmUgJiYgaS5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xzLnN0YXRlLnNjcm9sbGluZyh4KSk7IH0sXG4gICAgaS5zZXR0aW5ncy5zY3JvbGxpbmdUaHJlc2hvbGRcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2V0U2Nyb2xsaW5nQ2xhc3NJbnN0YW50bHkoaSwgeCkge1xuICBhZGRTY3JvbGxpbmdDbGFzcyhpLCB4KTtcbiAgcmVtb3ZlU2Nyb2xsaW5nQ2xhc3MoaSwgeCk7XG59XG5cbnZhciBFdmVudEVsZW1lbnQgPSBmdW5jdGlvbiBFdmVudEVsZW1lbnQoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmhhbmRsZXJzID0ge307XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpc0VtcHR5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkV2ZW50RWxlbWVudC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIHRoaXMuaGFuZGxlcnNbZXZlbnROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgfVxuICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoZXZlbnROYW1lLCB0YXJnZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0gPSB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgaWYgKHRhcmdldCAmJiBoYW5kbGVyICE9PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzJDEuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uIHVuYmluZEFsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzJDEuaGFuZGxlcnMpIHtcbiAgICB0aGlzJDEudW5iaW5kKG5hbWUpO1xuICB9XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaXNFbXB0eS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnMpLmV2ZXJ5KFxuICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMkMS5oYW5kbGVyc1trZXldLmxlbmd0aCA9PT0gMDsgfVxuICApO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEV2ZW50RWxlbWVudC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgRXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZXZlbnRFbGVtZW50ID0gZnVuY3Rpb24gZXZlbnRFbGVtZW50IChlbGVtZW50KSB7XG4gIHZhciBlZSA9IHRoaXMuZXZlbnRFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVlKSB7IHJldHVybiBlZS5lbGVtZW50ID09PSBlbGVtZW50OyB9KVswXTtcbiAgaWYgKCFlZSkge1xuICAgIGVlID0gbmV3IEV2ZW50RWxlbWVudChlbGVtZW50KTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlZSk7XG4gIH1cbiAgcmV0dXJuIGVlO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpLmJpbmQoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGVlLnVuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xuXG4gIGlmIChlZS5pc0VtcHR5KSB7XG4gICAgLy8gcmVtb3ZlXG4gICAgdGhpcy5ldmVudEVsZW1lbnRzLnNwbGljZSh0aGlzLmV2ZW50RWxlbWVudHMuaW5kZXhPZihlZSksIDEpO1xuICB9XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uIHVuYmluZEFsbCAoKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnVuYmluZEFsbCgpOyB9KTtcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciBvbmNlSGFuZGxlciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICBlZS51bmJpbmQoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XG4gICAgaGFuZGxlcihldnQpO1xuICB9O1xuICBlZS5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQobmFtZSwgZmFsc2UsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cbn1cblxudmFyIHByb2Nlc3NTY3JvbGxEaWZmID0gZnVuY3Rpb24oXG4gIGksXG4gIGF4aXMsXG4gIGRpZmYsXG4gIHVzZVNjcm9sbGluZ0NsYXNzLFxuICBmb3JjZUZpcmVSZWFjaEV2ZW50XG4pIHtcbiAgaWYgKCB1c2VTY3JvbGxpbmdDbGFzcyA9PT0gdm9pZCAwICkgdXNlU2Nyb2xsaW5nQ2xhc3MgPSB0cnVlO1xuICBpZiAoIGZvcmNlRmlyZVJlYWNoRXZlbnQgPT09IHZvaWQgMCApIGZvcmNlRmlyZVJlYWNoRXZlbnQgPSBmYWxzZTtcblxuICB2YXIgZmllbGRzO1xuICBpZiAoYXhpcyA9PT0gJ3RvcCcpIHtcbiAgICBmaWVsZHMgPSBbXG4gICAgICAnY29udGVudEhlaWdodCcsXG4gICAgICAnY29udGFpbmVySGVpZ2h0JyxcbiAgICAgICdzY3JvbGxUb3AnLFxuICAgICAgJ3knLFxuICAgICAgJ3VwJyxcbiAgICAgICdkb3duJyBdO1xuICB9IGVsc2UgaWYgKGF4aXMgPT09ICdsZWZ0Jykge1xuICAgIGZpZWxkcyA9IFtcbiAgICAgICdjb250ZW50V2lkdGgnLFxuICAgICAgJ2NvbnRhaW5lcldpZHRoJyxcbiAgICAgICdzY3JvbGxMZWZ0JyxcbiAgICAgICd4JyxcbiAgICAgICdsZWZ0JyxcbiAgICAgICdyaWdodCcgXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcHJvcGVyIGF4aXMgc2hvdWxkIGJlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBwcm9jZXNzU2Nyb2xsRGlmZiQxKGksIGRpZmYsIGZpZWxkcywgdXNlU2Nyb2xsaW5nQ2xhc3MsIGZvcmNlRmlyZVJlYWNoRXZlbnQpO1xufTtcblxuZnVuY3Rpb24gcHJvY2Vzc1Njcm9sbERpZmYkMShcbiAgaSxcbiAgZGlmZixcbiAgcmVmLFxuICB1c2VTY3JvbGxpbmdDbGFzcyxcbiAgZm9yY2VGaXJlUmVhY2hFdmVudFxuKSB7XG4gIHZhciBjb250ZW50SGVpZ2h0ID0gcmVmWzBdO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gcmVmWzFdO1xuICB2YXIgc2Nyb2xsVG9wID0gcmVmWzJdO1xuICB2YXIgeSA9IHJlZlszXTtcbiAgdmFyIHVwID0gcmVmWzRdO1xuICB2YXIgZG93biA9IHJlZls1XTtcbiAgaWYgKCB1c2VTY3JvbGxpbmdDbGFzcyA9PT0gdm9pZCAwICkgdXNlU2Nyb2xsaW5nQ2xhc3MgPSB0cnVlO1xuICBpZiAoIGZvcmNlRmlyZVJlYWNoRXZlbnQgPT09IHZvaWQgMCApIGZvcmNlRmlyZVJlYWNoRXZlbnQgPSBmYWxzZTtcblxuICB2YXIgZWxlbWVudCA9IGkuZWxlbWVudDtcblxuICAvLyByZXNldCByZWFjaFxuICBpLnJlYWNoW3ldID0gbnVsbDtcblxuICAvLyAxIGZvciBzdWJwaXhlbCByb3VuZGluZ1xuICBpZiAoZWxlbWVudFtzY3JvbGxUb3BdIDwgMSkge1xuICAgIGkucmVhY2hbeV0gPSAnc3RhcnQnO1xuICB9XG5cbiAgLy8gMSBmb3Igc3VicGl4ZWwgcm91bmRpbmdcbiAgaWYgKGVsZW1lbnRbc2Nyb2xsVG9wXSA+IGlbY29udGVudEhlaWdodF0gLSBpW2NvbnRhaW5lckhlaWdodF0gLSAxKSB7XG4gICAgaS5yZWFjaFt5XSA9ICdlbmQnO1xuICB9XG5cbiAgaWYgKGRpZmYpIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoKFwicHMtc2Nyb2xsLVwiICsgeSkpKTtcblxuICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KChcInBzLXNjcm9sbC1cIiArIHVwKSkpO1xuICAgIH0gZWxzZSBpZiAoZGlmZiA+IDApIHtcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudCgoXCJwcy1zY3JvbGwtXCIgKyBkb3duKSkpO1xuICAgIH1cblxuICAgIGlmICh1c2VTY3JvbGxpbmdDbGFzcykge1xuICAgICAgc2V0U2Nyb2xsaW5nQ2xhc3NJbnN0YW50bHkoaSwgeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGkucmVhY2hbeV0gJiYgKGRpZmYgfHwgZm9yY2VGaXJlUmVhY2hFdmVudCkpIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoKFwicHMtXCIgKyB5ICsgXCItcmVhY2gtXCIgKyAoaS5yZWFjaFt5XSkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9JbnQoeCkge1xuICByZXR1cm4gcGFyc2VJbnQoeCwgMTApIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGlzRWRpdGFibGUoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBtYXRjaGVzKGVsLCAnaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV0nKSB8fFxuICAgIG1hdGNoZXMoZWwsICdzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV0nKSB8fFxuICAgIG1hdGNoZXMoZWwsICd0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXScpIHx8XG4gICAgbWF0Y2hlcyhlbCwgJ2J1dHRvbixbY29udGVudGVkaXRhYmxlXScpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG91dGVyV2lkdGgoZWxlbWVudCkge1xuICB2YXIgc3R5bGVzID0gZ2V0KGVsZW1lbnQpO1xuICByZXR1cm4gKFxuICAgIHRvSW50KHN0eWxlcy53aWR0aCkgK1xuICAgIHRvSW50KHN0eWxlcy5wYWRkaW5nTGVmdCkgK1xuICAgIHRvSW50KHN0eWxlcy5wYWRkaW5nUmlnaHQpICtcbiAgICB0b0ludChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKSArXG4gICAgdG9JbnQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpXG4gICk7XG59XG5cbnZhciBlbnYgPSB7XG4gIGlzV2ViS2l0OlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICBzdXBwb3J0c1RvdWNoOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxuICAgICAgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6XG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMsXG4gIGlzQ2hyb21lOlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpLFxufTtcblxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oaSkge1xuICB2YXIgZWxlbWVudCA9IGkuZWxlbWVudDtcbiAgdmFyIHJvdW5kZWRTY3JvbGxUb3AgPSBNYXRoLmZsb29yKGVsZW1lbnQuc2Nyb2xsVG9wKTtcblxuICBpLmNvbnRhaW5lcldpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgaS5jb250YWluZXJIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgaS5jb250ZW50V2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuICBpLmNvbnRlbnRIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcblxuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJYUmFpbCkpIHtcbiAgICAvLyBjbGVhbiB1cCBhbmQgYXBwZW5kXG4gICAgcXVlcnlDaGlsZHJlbihlbGVtZW50LCBjbHMuZWxlbWVudC5yYWlsKCd4JykpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiByZW1vdmUoZWwpOyB9XG4gICAgKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGkuc2Nyb2xsYmFyWFJhaWwpO1xuICB9XG4gIGlmICghZWxlbWVudC5jb250YWlucyhpLnNjcm9sbGJhcllSYWlsKSkge1xuICAgIC8vIGNsZWFuIHVwIGFuZCBhcHBlbmRcbiAgICBxdWVyeUNoaWxkcmVuKGVsZW1lbnQsIGNscy5lbGVtZW50LnJhaWwoJ3knKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHJlbW92ZShlbCk7IH1cbiAgICApO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaS5zY3JvbGxiYXJZUmFpbCk7XG4gIH1cblxuICBpZiAoXG4gICAgIWkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmXG4gICAgaS5jb250YWluZXJXaWR0aCArIGkuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IGkuY29udGVudFdpZHRoXG4gICkge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWFdpZHRoID0gaS5jb250YWluZXJXaWR0aCAtIGkucmFpbFhNYXJnaW5XaWR0aDtcbiAgICBpLnJhaWxYUmF0aW8gPSBpLmNvbnRhaW5lcldpZHRoIC8gaS5yYWlsWFdpZHRoO1xuICAgIGkuc2Nyb2xsYmFyWFdpZHRoID0gZ2V0VGh1bWJTaXplKFxuICAgICAgaSxcbiAgICAgIHRvSW50KGkucmFpbFhXaWR0aCAqIGkuY29udGFpbmVyV2lkdGggLyBpLmNvbnRlbnRXaWR0aClcbiAgICApO1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSB0b0ludChcbiAgICAgIChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgKlxuICAgICAgICAoaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIC9cbiAgICAgICAgKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKFxuICAgICFpLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJlxuICAgIGkuY29udGFpbmVySGVpZ2h0ICsgaS5zZXR0aW5ncy5zY3JvbGxZTWFyZ2luT2Zmc2V0IDwgaS5jb250ZW50SGVpZ2h0XG4gICkge1xuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWUhlaWdodCA9IGkuY29udGFpbmVySGVpZ2h0IC0gaS5yYWlsWU1hcmdpbkhlaWdodDtcbiAgICBpLnJhaWxZUmF0aW8gPSBpLmNvbnRhaW5lckhlaWdodCAvIGkucmFpbFlIZWlnaHQ7XG4gICAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gZ2V0VGh1bWJTaXplKFxuICAgICAgaSxcbiAgICAgIHRvSW50KGkucmFpbFlIZWlnaHQgKiBpLmNvbnRhaW5lckhlaWdodCAvIGkuY29udGVudEhlaWdodClcbiAgICApO1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IHRvSW50KFxuICAgICAgcm91bmRlZFNjcm9sbFRvcCAqXG4gICAgICAgIChpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSAvXG4gICAgICAgIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGkuc2Nyb2xsYmFyWExlZnQgPj0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIHtcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGg7XG4gIH1cbiAgaWYgKGkuc2Nyb2xsYmFyWVRvcCA+PSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSB7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodDtcbiAgfVxuXG4gIHVwZGF0ZUNzcyhlbGVtZW50LCBpKTtcblxuICBpZiAoaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNscy5zdGF0ZS5hY3RpdmUoJ3gnKSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNscy5zdGF0ZS5hY3RpdmUoJ3gnKSk7XG4gICAgaS5zY3JvbGxiYXJYV2lkdGggPSAwO1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSAwO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IDA7XG4gIH1cbiAgaWYgKGkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbHMuc3RhdGUuYWN0aXZlKCd5JykpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbHMuc3RhdGUuYWN0aXZlKCd5JykpO1xuICAgIGkuc2Nyb2xsYmFyWUhlaWdodCA9IDA7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gMDtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRodW1iU2l6ZShpLCB0aHVtYlNpemUpIHtcbiAgaWYgKGkuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSB7XG4gICAgdGh1bWJTaXplID0gTWF0aC5tYXgodGh1bWJTaXplLCBpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCk7XG4gIH1cbiAgaWYgKGkuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKSB7XG4gICAgdGh1bWJTaXplID0gTWF0aC5taW4odGh1bWJTaXplLCBpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHRodW1iU2l6ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3NzKGVsZW1lbnQsIGkpIHtcbiAgdmFyIHhSYWlsT2Zmc2V0ID0geyB3aWR0aDogaS5yYWlsWFdpZHRoIH07XG4gIHZhciByb3VuZGVkU2Nyb2xsVG9wID0gTWF0aC5mbG9vcihlbGVtZW50LnNjcm9sbFRvcCk7XG5cbiAgaWYgKGkuaXNSdGwpIHtcbiAgICB4UmFpbE9mZnNldC5sZWZ0ID1cbiAgICAgIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArXG4gICAgICBpLmNvbnRhaW5lcldpZHRoIC1cbiAgICAgIGkuY29udGVudFdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cbiAgaWYgKGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20pIHtcbiAgICB4UmFpbE9mZnNldC5ib3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gLSByb3VuZGVkU2Nyb2xsVG9wO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LnRvcCA9IGkuc2Nyb2xsYmFyWFRvcCArIHJvdW5kZWRTY3JvbGxUb3A7XG4gIH1cbiAgc2V0KGkuc2Nyb2xsYmFyWFJhaWwsIHhSYWlsT2Zmc2V0KTtcblxuICB2YXIgeVJhaWxPZmZzZXQgPSB7IHRvcDogcm91bmRlZFNjcm9sbFRvcCwgaGVpZ2h0OiBpLnJhaWxZSGVpZ2h0IH07XG4gIGlmIChpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQpIHtcbiAgICBpZiAoaS5pc1J0bCkge1xuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPVxuICAgICAgICBpLmNvbnRlbnRXaWR0aCAtXG4gICAgICAgIChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgLVxuICAgICAgICBpLnNjcm9sbGJhcllSaWdodCAtXG4gICAgICAgIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LnJpZ2h0ID0gaS5zY3JvbGxiYXJZUmlnaHQgLSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpLmlzUnRsKSB7XG4gICAgICB5UmFpbE9mZnNldC5sZWZ0ID1cbiAgICAgICAgaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgK1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgK1xuICAgICAgICBpLmNvbnRhaW5lcldpZHRoICogMiAtXG4gICAgICAgIGkuY29udGVudFdpZHRoIC1cbiAgICAgICAgaS5zY3JvbGxiYXJZTGVmdCAtXG4gICAgICAgIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLnNjcm9sbGJhcllMZWZ0ICsgZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgfVxuICBzZXQoaS5zY3JvbGxiYXJZUmFpbCwgeVJhaWxPZmZzZXQpO1xuXG4gIHNldChpLnNjcm9sbGJhclgsIHtcbiAgICBsZWZ0OiBpLnNjcm9sbGJhclhMZWZ0LFxuICAgIHdpZHRoOiBpLnNjcm9sbGJhclhXaWR0aCAtIGkucmFpbEJvcmRlclhXaWR0aCxcbiAgfSk7XG4gIHNldChpLnNjcm9sbGJhclksIHtcbiAgICB0b3A6IGkuc2Nyb2xsYmFyWVRvcCxcbiAgICBoZWlnaHQ6IGkuc2Nyb2xsYmFyWUhlaWdodCAtIGkucmFpbEJvcmRlcllXaWR0aCxcbiAgfSk7XG59XG5cbnZhciBjbGlja1JhaWwgPSBmdW5jdGlvbihpKSB7XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclksICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTsgfSk7XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhcllSYWlsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcG9zaXRpb25Ub3AgPVxuICAgICAgZS5wYWdlWSAtXG4gICAgICB3aW5kb3cucGFnZVlPZmZzZXQgLVxuICAgICAgaS5zY3JvbGxiYXJZUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHBvc2l0aW9uVG9wID4gaS5zY3JvbGxiYXJZVG9wID8gMSA6IC0xO1xuXG4gICAgaS5lbGVtZW50LnNjcm9sbFRvcCArPSBkaXJlY3Rpb24gKiBpLmNvbnRhaW5lckhlaWdodDtcbiAgICB1cGRhdGVHZW9tZXRyeShpKTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTsgfSk7XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclhSYWlsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcG9zaXRpb25MZWZ0ID1cbiAgICAgIGUucGFnZVggLVxuICAgICAgd2luZG93LnBhZ2VYT2Zmc2V0IC1cbiAgICAgIGkuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICB2YXIgZGlyZWN0aW9uID0gcG9zaXRpb25MZWZ0ID4gaS5zY3JvbGxiYXJYTGVmdCA/IDEgOiAtMTtcblxuICAgIGkuZWxlbWVudC5zY3JvbGxMZWZ0ICs9IGRpcmVjdGlvbiAqIGkuY29udGFpbmVyV2lkdGg7XG4gICAgdXBkYXRlR2VvbWV0cnkoaSk7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbn07XG5cbnZhciBkcmFnVGh1bWIgPSBmdW5jdGlvbihpKSB7XG4gIGJpbmRNb3VzZVNjcm9sbEhhbmRsZXIoaSwgW1xuICAgICdjb250YWluZXJXaWR0aCcsXG4gICAgJ2NvbnRlbnRXaWR0aCcsXG4gICAgJ3BhZ2VYJyxcbiAgICAncmFpbFhXaWR0aCcsXG4gICAgJ3Njcm9sbGJhclgnLFxuICAgICdzY3JvbGxiYXJYV2lkdGgnLFxuICAgICdzY3JvbGxMZWZ0JyxcbiAgICAneCcsXG4gICAgJ3Njcm9sbGJhclhSYWlsJyBdKTtcbiAgYmluZE1vdXNlU2Nyb2xsSGFuZGxlcihpLCBbXG4gICAgJ2NvbnRhaW5lckhlaWdodCcsXG4gICAgJ2NvbnRlbnRIZWlnaHQnLFxuICAgICdwYWdlWScsXG4gICAgJ3JhaWxZSGVpZ2h0JyxcbiAgICAnc2Nyb2xsYmFyWScsXG4gICAgJ3Njcm9sbGJhcllIZWlnaHQnLFxuICAgICdzY3JvbGxUb3AnLFxuICAgICd5JyxcbiAgICAnc2Nyb2xsYmFyWVJhaWwnIF0pO1xufTtcblxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsSGFuZGxlcihcbiAgaSxcbiAgcmVmXG4pIHtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHJlZlswXTtcbiAgdmFyIGNvbnRlbnRIZWlnaHQgPSByZWZbMV07XG4gIHZhciBwYWdlWSA9IHJlZlsyXTtcbiAgdmFyIHJhaWxZSGVpZ2h0ID0gcmVmWzNdO1xuICB2YXIgc2Nyb2xsYmFyWSA9IHJlZls0XTtcbiAgdmFyIHNjcm9sbGJhcllIZWlnaHQgPSByZWZbNV07XG4gIHZhciBzY3JvbGxUb3AgPSByZWZbNl07XG4gIHZhciB5ID0gcmVmWzddO1xuICB2YXIgc2Nyb2xsYmFyWVJhaWwgPSByZWZbOF07XG5cbiAgdmFyIGVsZW1lbnQgPSBpLmVsZW1lbnQ7XG5cbiAgdmFyIHN0YXJ0aW5nU2Nyb2xsVG9wID0gbnVsbDtcbiAgdmFyIHN0YXJ0aW5nTW91c2VQYWdlWSA9IG51bGw7XG4gIHZhciBzY3JvbGxCeSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihlKSB7XG4gICAgZWxlbWVudFtzY3JvbGxUb3BdID1cbiAgICAgIHN0YXJ0aW5nU2Nyb2xsVG9wICsgc2Nyb2xsQnkgKiAoZVtwYWdlWV0gLSBzdGFydGluZ01vdXNlUGFnZVkpO1xuICAgIGFkZFNjcm9sbGluZ0NsYXNzKGksIHkpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGkpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZVVwSGFuZGxlcigpIHtcbiAgICByZW1vdmVTY3JvbGxpbmdDbGFzcyhpLCB5KTtcbiAgICBpW3Njcm9sbGJhcllSYWlsXS5jbGFzc0xpc3QucmVtb3ZlKGNscy5zdGF0ZS5jbGlja2luZyk7XG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gIH1cblxuICBpLmV2ZW50LmJpbmQoaVtzY3JvbGxiYXJZXSwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc3RhcnRpbmdTY3JvbGxUb3AgPSBlbGVtZW50W3Njcm9sbFRvcF07XG4gICAgc3RhcnRpbmdNb3VzZVBhZ2VZID0gZVtwYWdlWV07XG4gICAgc2Nyb2xsQnkgPVxuICAgICAgKGlbY29udGVudEhlaWdodF0gLSBpW2NvbnRhaW5lckhlaWdodF0pIC9cbiAgICAgIChpW3JhaWxZSGVpZ2h0XSAtIGlbc2Nyb2xsYmFyWUhlaWdodF0pO1xuXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIGkuZXZlbnQub25jZShpLm93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgaVtzY3JvbGxiYXJZUmFpbF0uY2xhc3NMaXN0LmFkZChjbHMuc3RhdGUuY2xpY2tpbmcpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG52YXIga2V5Ym9hcmQgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBlbGVtZW50ID0gaS5lbGVtZW50O1xuXG4gIHZhciBlbGVtZW50SG92ZXJlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGNoZXMoZWxlbWVudCwgJzpob3ZlcicpOyB9O1xuICB2YXIgc2Nyb2xsYmFyRm9jdXNlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGNoZXMoaS5zY3JvbGxiYXJYLCAnOmZvY3VzJykgfHwgbWF0Y2hlcyhpLnNjcm9sbGJhclksICc6Zm9jdXMnKTsgfTtcblxuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBNYXRoLmZsb29yKGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICBpZiAoZGVsdGFYID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChzY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgfHxcbiAgICAgICAgKHNjcm9sbFRvcCA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCAmJiBkZWx0YVkgPCAwKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGlmIChkZWx0YVkgPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKHNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgfHxcbiAgICAgICAgKHNjcm9sbExlZnQgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoICYmIGRlbHRhWCA+IDApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChcbiAgICAgIChlLmlzRGVmYXVsdFByZXZlbnRlZCAmJiBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB8fFxuICAgICAgZS5kZWZhdWx0UHJldmVudGVkXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50SG92ZXJlZCgpICYmICFzY3JvbGxiYXJGb2N1c2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgOiBpLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lGUkFNRScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuY29udGVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyBkZWVwZXIgaWYgZWxlbWVudCBpcyBhIHdlYmNvbXBvbmVudFxuICAgICAgICB3aGlsZSAoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNFZGl0YWJsZShhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhWCA9IDA7XG4gICAgdmFyIGRlbHRhWSA9IDA7XG5cbiAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgIGNhc2UgMzc6IC8vIGxlZnRcbiAgICAgICAgaWYgKGUubWV0YUtleSkge1xuICAgICAgICAgIGRlbHRhWCA9IC1pLmNvbnRlbnRXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgIGRlbHRhWCA9IC1pLmNvbnRhaW5lcldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWCA9IC0zMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6IC8vIHVwXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICBkZWx0YVkgPSBpLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5hbHRLZXkpIHtcbiAgICAgICAgICBkZWx0YVkgPSBpLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVkgPSAzMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6IC8vIHJpZ2h0XG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICBkZWx0YVggPSBpLmNvbnRlbnRXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgIGRlbHRhWCA9IGkuY29udGFpbmVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFYID0gMzA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQwOiAvLyBkb3duXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICBkZWx0YVkgPSAtaS5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAgICAgZGVsdGFZID0gLWkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWSA9IC0zMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzI6IC8vIHNwYWNlIGJhclxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGRlbHRhWSA9IGkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWSA9IC1pLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzM6IC8vIHBhZ2UgdXBcbiAgICAgICAgZGVsdGFZID0gaS5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNDogLy8gcGFnZSBkb3duXG4gICAgICAgIGRlbHRhWSA9IC1pLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM2OiAvLyBob21lXG4gICAgICAgIGRlbHRhWSA9IGkuY29udGVudEhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM1OiAvLyBlbmRcbiAgICAgICAgZGVsdGFZID0gLWkuY29udGVudEhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGRlbHRhWCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgZGVsdGFZICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgLT0gZGVsdGFZO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArPSBkZWx0YVg7XG4gICAgdXBkYXRlR2VvbWV0cnkoaSk7XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciB3aGVlbCA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGVsZW1lbnQgPSBpLmVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgcm91bmRlZFNjcm9sbFRvcCA9IE1hdGguZmxvb3IoZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIHZhciBpc1RvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wID09PSAwO1xuICAgIHZhciBpc0JvdHRvbSA9XG4gICAgICByb3VuZGVkU2Nyb2xsVG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgPT09IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIHZhciBpc0xlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQgPT09IDA7XG4gICAgdmFyIGlzUmlnaHQgPVxuICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ICsgZWxlbWVudC5vZmZzZXRXaWR0aCA9PT0gZWxlbWVudC5zY3JvbGxXaWR0aDtcblxuICAgIHZhciBoaXRzQm91bmQ7XG5cbiAgICAvLyBwaWNrIGF4aXMgd2l0aCBwcmltYXJ5IGRpcmVjdGlvblxuICAgIGlmIChNYXRoLmFicyhkZWx0YVkpID4gTWF0aC5hYnMoZGVsdGFYKSkge1xuICAgICAgaGl0c0JvdW5kID0gaXNUb3AgfHwgaXNCb3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdHNCb3VuZCA9IGlzTGVmdCB8fCBpc1JpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBoaXRzQm91bmQgPyAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uIDogdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbHRhRnJvbUV2ZW50KGUpIHtcbiAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVg7XG4gICAgdmFyIGRlbHRhWSA9IC0xICogZS5kZWx0YVk7XG5cbiAgICBpZiAodHlwZW9mIGRlbHRhWCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlbHRhWSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE9TIFggU2FmYXJpXG4gICAgICBkZWx0YVggPSAtMSAqIGUud2hlZWxEZWx0YVggLyA2O1xuICAgICAgZGVsdGFZID0gZS53aGVlbERlbHRhWSAvIDY7XG4gICAgfVxuXG4gICAgaWYgKGUuZGVsdGFNb2RlICYmIGUuZGVsdGFNb2RlID09PSAxKSB7XG4gICAgICAvLyBGaXJlZm94IGluIGRlbHRhTW9kZSAxOiBMaW5lIHNjcm9sbGluZ1xuICAgICAgZGVsdGFYICo9IDEwO1xuICAgICAgZGVsdGFZICo9IDEwO1xuICAgIH1cblxuICAgIGlmIChkZWx0YVggIT09IGRlbHRhWCAmJiBkZWx0YVkgIT09IGRlbHRhWSAvKiBOYU4gY2hlY2tzICovKSB7XG4gICAgICAvLyBJRSBpbiBzb21lIG1vdXNlIGRyaXZlcnNcbiAgICAgIGRlbHRhWCA9IDA7XG4gICAgICBkZWx0YVkgPSBlLndoZWVsRGVsdGE7XG4gICAgfVxuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIC8vIHJldmVyc2UgYXhpcyB3aXRoIHNoaWZ0IGtleVxuICAgICAgcmV0dXJuIFstZGVsdGFZLCAtZGVsdGFYXTtcbiAgICB9XG4gICAgcmV0dXJuIFtkZWx0YVgsIGRlbHRhWV07XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCZUNvbnN1bWVkQnlDaGlsZCh0YXJnZXQsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgLy8gRklYTUU6IHRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciA8c2VsZWN0PiBpc3N1ZSBpbiBGRiBhbmQgSUUgIzU3MVxuICAgIGlmICghZW52LmlzV2ViS2l0ICYmIGVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2VsZWN0OmZvY3VzJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvciA9IHRhcmdldDtcblxuICAgIHdoaWxlIChjdXJzb3IgJiYgY3Vyc29yICE9PSBlbGVtZW50KSB7XG4gICAgICBpZiAoY3Vyc29yLmNsYXNzTGlzdC5jb250YWlucyhjbHMuZWxlbWVudC5jb25zdW1pbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBnZXQoY3Vyc29yKTtcbiAgICAgIHZhciBvdmVyZmxvdyA9IFtzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1ldLmpvaW4oXG4gICAgICAgICcnXG4gICAgICApO1xuXG4gICAgICAvLyBpZiBzY3JvbGxhYmxlXG4gICAgICBpZiAob3ZlcmZsb3cubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgbWF4U2Nyb2xsVG9wID0gY3Vyc29yLnNjcm9sbEhlaWdodCAtIGN1cnNvci5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChtYXhTY3JvbGxUb3AgPiAwKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShjdXJzb3Iuc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApICYmXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxUb3AgPT09IG1heFNjcm9sbFRvcCAmJiBkZWx0YVkgPCAwKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhTY3JvbGxMZWZ0ID0gY3Vyc29yLnNjcm9sbFdpZHRoIC0gY3Vyc29yLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAobWF4U2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApICYmXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSBtYXhTY3JvbGxMZWZ0ICYmIGRlbHRhWCA+IDApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V3aGVlbEhhbmRsZXIoZSkge1xuICAgIHZhciByZWYgPSBnZXREZWx0YUZyb21FdmVudChlKTtcbiAgICB2YXIgZGVsdGFYID0gcmVmWzBdO1xuICAgIHZhciBkZWx0YVkgPSByZWZbMV07XG5cbiAgICBpZiAoc2hvdWxkQmVDb25zdW1lZEJ5Q2hpbGQoZS50YXJnZXQsIGRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKCFpLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMpIHtcbiAgICAgIC8vIGRlbHRhWCB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYW5kIGRlbHRhWSB3aWxsXG4gICAgICAvLyBvbmx5IGJlIHVzZWQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZyAtIHRoaXMgaXMgdGhlIGRlZmF1bHRcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wIC09IGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZDtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArPSBkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgfSBlbHNlIGlmIChpLnNjcm9sbGJhcllBY3RpdmUgJiYgIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xuICAgICAgLy8gb25seSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgYWN0aXZlIGFuZCB1c2VCb3RoV2hlZWxBeGVzIG9wdGlvbiBpc1xuICAgICAgLy8gYWN0aXZlLCBzbyBsZXQncyBzY3JvbGwgdmVydGljYWwgYmFyIHVzaW5nIGJvdGggbW91c2Ugd2hlZWwgYXhlc1xuICAgICAgaWYgKGRlbHRhWSkge1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCAtPSBkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCArPSBkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgICB9XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGkuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhaS5zY3JvbGxiYXJZQWN0aXZlKSB7XG4gICAgICAvLyB1c2VCb3RoV2hlZWxBeGVzIGFuZCBvbmx5IGhvcml6b250YWwgYmFyIGlzIGFjdGl2ZSwgc28gdXNlIGJvdGhcbiAgICAgIC8vIHdoZWVsIGF4ZXMgZm9yIGhvcml6b250YWwgYmFyXG4gICAgICBpZiAoZGVsdGFYKSB7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArPSBkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgLT0gZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkO1xuICAgICAgfVxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlR2VvbWV0cnkoaSk7XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gc2hvdWxkUHJldmVudCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQgJiYgIWUuY3RybEtleSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5vbndoZWVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnd2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5vbm1vdXNld2hlZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICB9XG59O1xuXG52YXIgdG91Y2ggPSBmdW5jdGlvbihpKSB7XG4gIGlmICghZW52LnN1cHBvcnRzVG91Y2ggJiYgIWVudi5zdXBwb3J0c0llUG9pbnRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gaS5lbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gTWF0aC5mbG9vcihlbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgdmFyIG1hZ25pdHVkZVggPSBNYXRoLmFicyhkZWx0YVgpO1xuICAgIHZhciBtYWduaXR1ZGVZID0gTWF0aC5hYnMoZGVsdGFZKTtcblxuICAgIGlmIChtYWduaXR1ZGVZID4gbWFnbml0dWRlWCkge1xuICAgICAgLy8gdXNlciBpcyBwZXJoYXBzIHRyeWluZyB0byBzd2lwZSB1cC9kb3duIHRoZSBwYWdlXG5cbiAgICAgIGlmIChcbiAgICAgICAgKGRlbHRhWSA8IDAgJiYgc2Nyb2xsVG9wID09PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgfHxcbiAgICAgICAgKGRlbHRhWSA+IDAgJiYgc2Nyb2xsVG9wID09PSAwKVxuICAgICAgKSB7XG4gICAgICAgIC8vIHNldCBwcmV2ZW50IGZvciBtb2JpbGUgQ2hyb21lIHJlZnJlc2hcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID09PSAwICYmIGRlbHRhWSA+IDAgJiYgZW52LmlzQ2hyb21lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWFnbml0dWRlWCA+IG1hZ25pdHVkZVkpIHtcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgbGVmdC9yaWdodCBhY3Jvc3MgdGhlIHBhZ2VcblxuICAgICAgaWYgKFxuICAgICAgICAoZGVsdGFYIDwgMCAmJiBzY3JvbGxMZWZ0ID09PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpIHx8XG4gICAgICAgIChkZWx0YVggPiAwICYmIHNjcm9sbExlZnQgPT09IDApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpIHtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCAtPSBkaWZmZXJlbmNlWTtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgLT0gZGlmZmVyZW5jZVg7XG5cbiAgICB1cGRhdGVHZW9tZXRyeShpKTtcbiAgfVxuXG4gIHZhciBzdGFydE9mZnNldCA9IHt9O1xuICB2YXIgc3RhcnRUaW1lID0gMDtcbiAgdmFyIHNwZWVkID0ge307XG4gIHZhciBlYXNpbmdMb29wID0gbnVsbDtcblxuICBmdW5jdGlvbiBnZXRUb3VjaChlKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcykge1xuICAgICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWF5YmUgSUUgcG9pbnRlclxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSGFuZGxlKGUpIHtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSAmJiBlLnBvaW50ZXJUeXBlID09PSAncGVuJyAmJiBlLmJ1dHRvbnMgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgZS5wb2ludGVyVHlwZSAmJlxuICAgICAgZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJlxuICAgICAgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoU3RhcnQoZSkge1xuICAgIGlmICghc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoID0gZ2V0VG91Y2goZSk7XG5cbiAgICBzdGFydE9mZnNldC5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgIHN0YXJ0T2Zmc2V0LnBhZ2VZID0gdG91Y2gucGFnZVk7XG5cbiAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIGlmIChlYXNpbmdMb29wICE9PSBudWxsKSB7XG4gICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJlQ29uc3VtZWRCeUNoaWxkKHRhcmdldCwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBpZiAoIWVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IgPSB0YXJnZXQ7XG5cbiAgICB3aGlsZSAoY3Vyc29yICYmIGN1cnNvciAhPT0gZWxlbWVudCkge1xuICAgICAgaWYgKGN1cnNvci5jbGFzc0xpc3QuY29udGFpbnMoY2xzLmVsZW1lbnQuY29uc3VtaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gZ2V0KGN1cnNvcik7XG4gICAgICB2YXIgb3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXS5qb2luKFxuICAgICAgICAnJ1xuICAgICAgKTtcblxuICAgICAgLy8gaWYgc2Nyb2xsYWJsZVxuICAgICAgaWYgKG92ZXJmbG93Lm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIG1heFNjcm9sbFRvcCA9IGN1cnNvci5zY3JvbGxIZWlnaHQgLSBjdXJzb3IuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAobWF4U2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoY3Vyc29yLnNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSAmJlxuICAgICAgICAgICAgIShjdXJzb3Iuc2Nyb2xsVG9wID09PSBtYXhTY3JvbGxUb3AgJiYgZGVsdGFZIDwgMClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4U2Nyb2xsTGVmdCA9IGN1cnNvci5zY3JvbGxMZWZ0IC0gY3Vyc29yLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAobWF4U2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApICYmXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSBtYXhTY3JvbGxMZWZ0ICYmIGRlbHRhWCA+IDApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaChlKTtcblxuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB7IHBhZ2VYOiB0b3VjaC5wYWdlWCwgcGFnZVk6IHRvdWNoLnBhZ2VZIH07XG5cbiAgICAgIHZhciBkaWZmZXJlbmNlWCA9IGN1cnJlbnRPZmZzZXQucGFnZVggLSBzdGFydE9mZnNldC5wYWdlWDtcbiAgICAgIHZhciBkaWZmZXJlbmNlWSA9IGN1cnJlbnRPZmZzZXQucGFnZVkgLSBzdGFydE9mZnNldC5wYWdlWTtcblxuICAgICAgaWYgKHNob3VsZEJlQ29uc3VtZWRCeUNoaWxkKGUudGFyZ2V0LCBkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBwbHlUb3VjaE1vdmUoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gY3VycmVudE9mZnNldDtcblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIHZhciB0aW1lR2FwID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBpZiAodGltZUdhcCA+IDApIHtcbiAgICAgICAgc3BlZWQueCA9IGRpZmZlcmVuY2VYIC8gdGltZUdhcDtcbiAgICAgICAgc3BlZWQueSA9IGRpZmZlcmVuY2VZIC8gdGltZUdhcDtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRQcmV2ZW50KGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaEVuZCgpIHtcbiAgICBpZiAoaS5zZXR0aW5ncy5zd2lwZUVhc2luZykge1xuICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgIGVhc2luZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGkuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzcGVlZC54ICYmICFzcGVlZC55KSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWQueCkgPCAwLjAxICYmIE1hdGguYWJzKHNwZWVkLnkpIDwgMC4wMSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHlUb3VjaE1vdmUoc3BlZWQueCAqIDMwLCBzcGVlZC55ICogMzApO1xuXG4gICAgICAgIHNwZWVkLnggKj0gMC44O1xuICAgICAgICBzcGVlZC55ICo9IDAuODtcbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW52LnN1cHBvcnRzVG91Y2gpIHtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0KTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcbiAgfSBlbHNlIGlmIChlbnYuc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVyZG93bicsIHRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVybW92ZScsIHRvdWNoTW92ZSk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJ1cCcsIHRvdWNoRW5kKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJEb3duJywgdG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlck1vdmUnLCB0b3VjaE1vdmUpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJVcCcsIHRvdWNoRW5kKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICBoYW5kbGVyczogWydjbGljay1yYWlsJywgJ2RyYWctdGh1bWInLCAna2V5Ym9hcmQnLCAnd2hlZWwnLCAndG91Y2gnXSxcbiAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogMTAwMCxcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgc3VwcHJlc3NTY3JvbGxYOiBmYWxzZSxcbiAgc3VwcHJlc3NTY3JvbGxZOiBmYWxzZSxcbiAgc3dpcGVFYXNpbmc6IHRydWUsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IGZhbHNlLFxuICB3aGVlbFByb3BhZ2F0aW9uOiB0cnVlLFxuICB3aGVlbFNwZWVkOiAxLFxufSk7IH07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgJ2NsaWNrLXJhaWwnOiBjbGlja1JhaWwsXG4gICdkcmFnLXRodW1iJzogZHJhZ1RodW1iLFxuICBrZXlib2FyZDoga2V5Ym9hcmQsXG4gIHdoZWVsOiB3aGVlbCxcbiAgdG91Y2g6IHRvdWNoLFxufTtcblxudmFyIFBlcmZlY3RTY3JvbGxiYXIgPSBmdW5jdGlvbiBQZXJmZWN0U2Nyb2xsYmFyKGVsZW1lbnQsIHVzZXJTZXR0aW5ncykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCB1c2VyU2V0dGluZ3MgPT09IHZvaWQgMCApIHVzZXJTZXR0aW5ncyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgfVxuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gZWxlbWVudCBpcyBzcGVjaWZpZWQgdG8gaW5pdGlhbGl6ZSBQZXJmZWN0U2Nyb2xsYmFyJyk7XG4gIH1cblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbHMubWFpbik7XG5cbiAgdGhpcy5zZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncygpO1xuICBmb3IgKHZhciBrZXkgaW4gdXNlclNldHRpbmdzKSB7XG4gICAgdGhpcyQxLnNldHRpbmdzW2tleV0gPSB1c2VyU2V0dGluZ3Nba2V5XTtcbiAgfVxuXG4gIHRoaXMuY29udGFpbmVyV2lkdGggPSBudWxsO1xuICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG51bGw7XG4gIHRoaXMuY29udGVudFdpZHRoID0gbnVsbDtcbiAgdGhpcy5jb250ZW50SGVpZ2h0ID0gbnVsbDtcblxuICB2YXIgZm9jdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xzLnN0YXRlLmZvY3VzKTsgfTtcbiAgdmFyIGJsdXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xzLnN0YXRlLmZvY3VzKTsgfTtcblxuICB0aGlzLmlzUnRsID0gZ2V0KGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gIHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSAtMTtcbiAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbExlZnQgPCAwO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IG9yaWdpbmFsU2Nyb2xsTGVmdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xuICB0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbFxuICAgID8gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICA6IDA7XG4gIHRoaXMuZXZlbnQgPSBuZXcgRXZlbnRNYW5hZ2VyKCk7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICB0aGlzLnNjcm9sbGJhclhSYWlsID0gZGl2KGNscy5lbGVtZW50LnJhaWwoJ3gnKSk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWCA9IGRpdihjbHMuZWxlbWVudC50aHVtYigneCcpKTtcbiAgdGhpcy5zY3JvbGxiYXJYUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclgpO1xuICB0aGlzLnNjcm9sbGJhclguc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJYLCAnZm9jdXMnLCBmb2N1cyk7XG4gIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsICdibHVyJywgYmx1cik7XG4gIHRoaXMuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsYmFyWFdpZHRoID0gbnVsbDtcbiAgdGhpcy5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XG4gIHZhciByYWlsWFN0eWxlID0gZ2V0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpO1xuICB0aGlzLnNjcm9sbGJhclhCb3R0b20gPSBwYXJzZUludChyYWlsWFN0eWxlLmJvdHRvbSwgMTApO1xuICBpZiAoaXNOYU4odGhpcy5zY3JvbGxiYXJYQm90dG9tKSkge1xuICAgIHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSBmYWxzZTtcbiAgICB0aGlzLnNjcm9sbGJhclhUb3AgPSB0b0ludChyYWlsWFN0eWxlLnRvcCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9IHRydWU7XG4gIH1cbiAgdGhpcy5yYWlsQm9yZGVyWFdpZHRoID1cbiAgICB0b0ludChyYWlsWFN0eWxlLmJvcmRlckxlZnRXaWR0aCkgKyB0b0ludChyYWlsWFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuICAvLyBTZXQgcmFpbCB0byBkaXNwbGF5OmJsb2NrIHRvIGNhbGN1bGF0ZSBtYXJnaW5zXG4gIHNldCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6ICdibG9jaycgfSk7XG4gIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9XG4gICAgdG9JbnQocmFpbFhTdHlsZS5tYXJnaW5MZWZ0KSArIHRvSW50KHJhaWxYU3R5bGUubWFyZ2luUmlnaHQpO1xuICBzZXQodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiAnJyB9KTtcbiAgdGhpcy5yYWlsWFdpZHRoID0gbnVsbDtcbiAgdGhpcy5yYWlsWFJhdGlvID0gbnVsbDtcblxuICB0aGlzLnNjcm9sbGJhcllSYWlsID0gZGl2KGNscy5lbGVtZW50LnJhaWwoJ3knKSk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWSA9IGRpdihjbHMuZWxlbWVudC50aHVtYigneScpKTtcbiAgdGhpcy5zY3JvbGxiYXJZUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclkpO1xuICB0aGlzLnNjcm9sbGJhclkuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJZLCAnZm9jdXMnLCBmb2N1cyk7XG4gIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksICdibHVyJywgYmx1cik7XG4gIHRoaXMuc2Nyb2xsYmFyWUFjdGl2ZSA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsYmFyWUhlaWdodCA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsYmFyWVRvcCA9IG51bGw7XG4gIHZhciByYWlsWVN0eWxlID0gZ2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpO1xuICB0aGlzLnNjcm9sbGJhcllSaWdodCA9IHBhcnNlSW50KHJhaWxZU3R5bGUucmlnaHQsIDEwKTtcbiAgaWYgKGlzTmFOKHRoaXMuc2Nyb2xsYmFyWVJpZ2h0KSkge1xuICAgIHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsYmFyWUxlZnQgPSB0b0ludChyYWlsWVN0eWxlLmxlZnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9IHRydWU7XG4gIH1cbiAgdGhpcy5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IHRoaXMuaXNSdGwgPyBvdXRlcldpZHRoKHRoaXMuc2Nyb2xsYmFyWSkgOiBudWxsO1xuICB0aGlzLnJhaWxCb3JkZXJZV2lkdGggPVxuICAgIHRvSW50KHJhaWxZU3R5bGUuYm9yZGVyVG9wV2lkdGgpICsgdG9JbnQocmFpbFlTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gIHNldCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6ICdibG9jaycgfSk7XG4gIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPVxuICAgIHRvSW50KHJhaWxZU3R5bGUubWFyZ2luVG9wKSArIHRvSW50KHJhaWxZU3R5bGUubWFyZ2luQm90dG9tKTtcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogJycgfSk7XG4gIHRoaXMucmFpbFlIZWlnaHQgPSBudWxsO1xuICB0aGlzLnJhaWxZUmF0aW8gPSBudWxsO1xuXG4gIHRoaXMucmVhY2ggPSB7XG4gICAgeDpcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA8PSAwXG4gICAgICAgID8gJ3N0YXJ0J1xuICAgICAgICA6IGVsZW1lbnQuc2Nyb2xsTGVmdCA+PSB0aGlzLmNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGFpbmVyV2lkdGhcbiAgICAgICAgICA/ICdlbmQnXG4gICAgICAgICAgOiBudWxsLFxuICAgIHk6XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA8PSAwXG4gICAgICAgID8gJ3N0YXJ0J1xuICAgICAgICA6IGVsZW1lbnQuc2Nyb2xsVG9wID49IHRoaXMuY29udGVudEhlaWdodCAtIHRoaXMuY29udGFpbmVySGVpZ2h0XG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogbnVsbCxcbiAgfTtcblxuICB0aGlzLmlzQWxpdmUgPSB0cnVlO1xuXG4gIHRoaXMuc2V0dGluZ3MuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlck5hbWUpIHsgcmV0dXJuIGhhbmRsZXJzW2hhbmRsZXJOYW1lXSh0aGlzJDEpOyB9KTtcblxuICB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKGVsZW1lbnQuc2Nyb2xsVG9wKTsgLy8gZm9yIG9uU2Nyb2xsIG9ubHlcbiAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDsgLy8gZm9yIG9uU2Nyb2xsIG9ubHlcbiAgdGhpcy5ldmVudC5iaW5kKHRoaXMuZWxlbWVudCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzJDEub25TY3JvbGwoZSk7IH0pO1xuICB1cGRhdGVHZW9tZXRyeSh0aGlzKTtcbn07XG5cblBlcmZlY3RTY3JvbGxiYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIGlmICghdGhpcy5pc0FsaXZlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVjYWxjdWF0ZSBuZWdhdGl2ZSBzY3JvbGxMZWZ0IGFkanVzdG1lbnRcbiAgdGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGxcbiAgICA/IHRoaXMuZWxlbWVudC5zY3JvbGxXaWR0aCAtIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aFxuICAgIDogMDtcblxuICAvLyBSZWNhbGN1bGF0ZSByYWlsIG1hcmdpbnNcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgdGhpcy5yYWlsWE1hcmdpbldpZHRoID1cbiAgICB0b0ludChnZXQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luTGVmdCkgK1xuICAgIHRvSW50KGdldCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5SaWdodCk7XG4gIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPVxuICAgIHRvSW50KGdldCh0aGlzLnNjcm9sbGJhcllSYWlsKS5tYXJnaW5Ub3ApICtcbiAgICB0b0ludChnZXQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luQm90dG9tKTtcblxuICAvLyBIaWRlIHNjcm9sbGJhcnMgbm90IHRvIGFmZmVjdCBzY3JvbGxXaWR0aCBhbmQgc2Nyb2xsSGVpZ2h0XG4gIHNldCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogJ25vbmUnIH0pO1xuXG4gIHVwZGF0ZUdlb21ldHJ5KHRoaXMpO1xuXG4gIHByb2Nlc3NTY3JvbGxEaWZmKHRoaXMsICd0b3AnLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gIHByb2Nlc3NTY3JvbGxEaWZmKHRoaXMsICdsZWZ0JywgMCwgZmFsc2UsIHRydWUpO1xuXG4gIHNldCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6ICcnIH0pO1xuICBzZXQodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiAnJyB9KTtcbn07XG5cblBlcmZlY3RTY3JvbGxiYXIucHJvdG90eXBlLm9uU2Nyb2xsID0gZnVuY3Rpb24gb25TY3JvbGwgKGUpIHtcbiAgaWYgKCF0aGlzLmlzQWxpdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB1cGRhdGVHZW9tZXRyeSh0aGlzKTtcbiAgcHJvY2Vzc1Njcm9sbERpZmYodGhpcywgJ3RvcCcsIHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgLSB0aGlzLmxhc3RTY3JvbGxUb3ApO1xuICBwcm9jZXNzU2Nyb2xsRGlmZihcbiAgICB0aGlzLFxuICAgICdsZWZ0JyxcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCAtIHRoaXMubGFzdFNjcm9sbExlZnRcbiAgKTtcblxuICB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHRoaXMuZWxlbWVudC5zY3JvbGxUb3ApO1xuICB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQ7XG59O1xuXG5QZXJmZWN0U2Nyb2xsYmFyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIGlmICghdGhpcy5pc0FsaXZlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5ldmVudC51bmJpbmRBbGwoKTtcbiAgcmVtb3ZlKHRoaXMuc2Nyb2xsYmFyWCk7XG4gIHJlbW92ZSh0aGlzLnNjcm9sbGJhclkpO1xuICByZW1vdmUodGhpcy5zY3JvbGxiYXJYUmFpbCk7XG4gIHJlbW92ZSh0aGlzLnNjcm9sbGJhcllSYWlsKTtcbiAgdGhpcy5yZW1vdmVQc0NsYXNzZXMoKTtcblxuICAvLyB1bnNldCBlbGVtZW50c1xuICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB0aGlzLnNjcm9sbGJhclggPSBudWxsO1xuICB0aGlzLnNjcm9sbGJhclkgPSBudWxsO1xuICB0aGlzLnNjcm9sbGJhclhSYWlsID0gbnVsbDtcbiAgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IG51bGw7XG5cbiAgdGhpcy5pc0FsaXZlID0gZmFsc2U7XG59O1xuXG5QZXJmZWN0U2Nyb2xsYmFyLnByb3RvdHlwZS5yZW1vdmVQc0NsYXNzZXMgPSBmdW5jdGlvbiByZW1vdmVQc0NsYXNzZXMgKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZVxuICAgIC5zcGxpdCgnICcpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW5hbWUubWF0Y2goL15wcyhbLV9dLit8KSQvKTsgfSlcbiAgICAuam9pbignICcpO1xufTtcblxucmV0dXJuIFBlcmZlY3RTY3JvbGxiYXI7XG5cbn0pKSk7XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE2LjBcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcblxudmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn0oKTtcblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSwgMTApICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0sIDEwKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddLCAxMCk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFN0aWNreS5qc1xuICogTGlicmFyeSBmb3Igc3RpY2t5IGVsZW1lbnRzIHdyaXR0ZW4gaW4gdmFuaWxsYSBqYXZhc2NyaXB0LiBXaXRoIHRoaXMgbGlicmFyeSB5b3UgY2FuIGVhc2lseSBzZXQgc3RpY2t5IGVsZW1lbnRzIG9uIHlvdXIgd2Vic2l0ZS4gSXQncyBhbHNvIHJlc3BvbnNpdmUuXG4gKlxuICogQHZlcnNpb24gMS4yLjBcbiAqIEBhdXRob3IgUmFmYWwgR2FsdXMgPGJpdXJvQHJhZmFsZ2FsdXMucGw+XG4gKiBAd2Vic2l0ZSBodHRwczovL3JnYWx1cy5naXRodWIuaW8vc3RpY2t5LWpzL1xuICogQHJlcG8gaHR0cHM6Ly9naXRodWIuY29tL3JnYWx1cy9zdGlja3ktanNcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZ2FsdXMvc3RpY2t5LWpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG52YXIgU3RpY2t5ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogU3RpY2t5IGluc3RhbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciB3aGljaCB3ZSBjYW4gZmluZCBlbGVtZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucyAtIEdsb2JhbCBvcHRpb25zIGZvciBzdGlja3kgZWxlbWVudHMgKGNvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IGRhdGEte29wdGlvbn09XCJcIiBhdHRyaWJ1dGVzKVxuICAgKi9cbiAgZnVuY3Rpb24gU3RpY2t5KCkge1xuICAgIHZhciBzZWxlY3RvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0aWNreSk7XG5cbiAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuXG4gICAgdGhpcy52ZXJzaW9uID0gJzEuMi4wJztcblxuICAgIHRoaXMudnAgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZSgpO1xuICAgIHRoaXMuYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHdyYXA6IG9wdGlvbnMud3JhcCB8fCBmYWxzZSxcbiAgICAgIG1hcmdpblRvcDogb3B0aW9ucy5tYXJnaW5Ub3AgfHwgMCxcbiAgICAgIHN0aWNreUZvcjogb3B0aW9ucy5zdGlja3lGb3IgfHwgMCxcbiAgICAgIHN0aWNreUNsYXNzOiBvcHRpb25zLnN0aWNreUNsYXNzIHx8IG51bGwsXG4gICAgICBzdGlja3lDb250YWluZXI6IG9wdGlvbnMuc3RpY2t5Q29udGFpbmVyIHx8ICdib2R5J1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVNjcm9sbFRvcFBvc2l0aW9uID0gdGhpcy51cGRhdGVTY3JvbGxUb3BQb3NpdGlvbi5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy51cGRhdGVTY3JvbGxUb3BQb3NpdGlvbigpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy51cGRhdGVTY3JvbGxUb3BQb3NpdGlvbik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlU2Nyb2xsVG9wUG9zaXRpb24pO1xuXG4gICAgdGhpcy5ydW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHdhaXRzIGZvciBwYWdlIHRvIGJlIGZ1bGx5IGxvYWRlZCBhbmQgdGhlbiByZW5kZXJzICYgYWN0aXZhdGVzIGV2ZXJ5IHN0aWNreSBlbGVtZW50IGZvdW5kIHdpdGggc3BlY2lmaWVkIHNlbGVjdG9yXG4gICAqIEBmdW5jdGlvblxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyB3YWl0IGZvciBwYWdlIHRvIGJlIGZ1bGx5IGxvYWRlZFxuICAgIHZhciBwYWdlTG9hZGVkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwYWdlTG9hZGVkKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgX3RoaXMuZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucmVuZGVyRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGFzc2lnbiBuZWVkZWQgdmFyaWFibGVzIGZvciBzdGlja3kgZWxlbWVudCwgdGhhdCBhcmUgdXNlZCBpbiBmdXR1cmUgZm9yIGNhbGN1bGF0aW9ucyBhbmQgb3RoZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYmUgcmVuZGVyZWRcbiAgICovXG5cblxuICBTdGlja3kucHJvdG90eXBlLnJlbmRlckVsZW1lbnQgPSBmdW5jdGlvbiByZW5kZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIGNyZWF0ZSBjb250YWluZXIgZm9yIHZhcmlhYmxlcyBuZWVkZWQgaW4gZnV0dXJlXG4gICAgZWxlbWVudC5zdGlja3kgPSB7fTtcblxuICAgIC8vIHNldCBkZWZhdWx0IHZhcmlhYmxlc1xuICAgIGVsZW1lbnQuc3RpY2t5LmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgZWxlbWVudC5zdGlja3kubWFyZ2luVG9wID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWFyZ2luLXRvcCcpKSB8fCB0aGlzLm9wdGlvbnMubWFyZ2luVG9wO1xuICAgIGVsZW1lbnQuc3RpY2t5LnN0aWNreUZvciA9IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS1mb3InKSkgfHwgdGhpcy5vcHRpb25zLnN0aWNreUZvcjtcbiAgICBlbGVtZW50LnN0aWNreS5zdGlja3lDbGFzcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS1jbGFzcycpIHx8IHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcztcbiAgICBlbGVtZW50LnN0aWNreS53cmFwID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3RpY2t5LXdyYXAnKSA/IHRydWUgOiB0aGlzLm9wdGlvbnMud3JhcDtcbiAgICAvLyBAdG9kbyBhdHRyaWJ1dGUgZm9yIHN0aWNreUNvbnRhaW5lclxuICAgIC8vIGVsZW1lbnQuc3RpY2t5LnN0aWNreUNvbnRhaW5lciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS1jb250YWluZXInKSB8fCB0aGlzLm9wdGlvbnMuc3RpY2t5Q29udGFpbmVyO1xuICAgIGVsZW1lbnQuc3RpY2t5LnN0aWNreUNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5zdGlja3lDb250YWluZXI7XG5cbiAgICBlbGVtZW50LnN0aWNreS5jb250YWluZXIgPSB0aGlzLmdldFN0aWNreUNvbnRhaW5lcihlbGVtZW50KTtcbiAgICBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdCA9IHRoaXMuZ2V0UmVjdGFuZ2xlKGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lcik7XG5cbiAgICBlbGVtZW50LnN0aWNreS5yZWN0ID0gdGhpcy5nZXRSZWN0YW5nbGUoZWxlbWVudCk7XG5cbiAgICAvLyBmaXggd2hlbiBlbGVtZW50IGlzIGltYWdlIHRoYXQgaGFzIG5vdCB5ZXQgbG9hZGVkIGFuZCB3aWR0aCwgaGVpZ2h0ID0gMFxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgIGVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5zdGlja3kucmVjdCA9IF90aGlzMi5nZXRSZWN0YW5nbGUoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnN0aWNreS53cmFwKSB7XG4gICAgICB0aGlzLndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGFjdGl2YXRlIHJlbmRlcmVkIGVsZW1lbnRcbiAgICB0aGlzLmFjdGl2YXRlKGVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcmFwcyBlbGVtZW50IGludG8gcGxhY2Vob2xkZXIgZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtub2RlfSBlbGVtZW50IC0gRWxlbWVudCB0byBiZSB3cmFwcGVkXG4gICAqL1xuXG5cbiAgU3RpY2t5LnByb3RvdHlwZS53cmFwRWxlbWVudCA9IGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCAnPHNwYW4+PC9zcGFuPicpO1xuICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGFjdGl2YXRlcyBlbGVtZW50IHdoZW4gc3BlY2lmaWVkIGNvbmRpdGlvbnMgYXJlIG1ldCBhbmQgdGhlbiBpbml0YWxpc2UgZXZlbnRzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGJlIGFjdGl2YXRlZFxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiBhY3RpdmF0ZShlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuc3RpY2t5LnJlY3QudG9wICsgZWxlbWVudC5zdGlja3kucmVjdC5oZWlnaHQgPCBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC5oZWlnaHQgJiYgZWxlbWVudC5zdGlja3kuc3RpY2t5Rm9yIDwgdGhpcy52cC53aWR0aCAmJiAhZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICBlbGVtZW50LnN0aWNreS5hY3RpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCkgPCAwKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50LnN0aWNreS5yZXNpemVFdmVudCkge1xuICAgICAgdGhpcy5pbml0UmVzaXplRXZlbnRzKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5zdGlja3kucmVzaXplRXZlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudC5zdGlja3kuc2Nyb2xsRXZlbnQpIHtcbiAgICAgIHRoaXMuaW5pdFNjcm9sbEV2ZW50cyhlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc3RpY2t5LnNjcm9sbEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBvc2l0aW9uKGVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB3aGljaCBpcyBhZGRpbmcgb25SZXNpemVFdmVudHMgdG8gd2luZG93IGxpc3RlbmVyIGFuZCBhc3NpZ25zIGZ1bmN0aW9uIHRvIGVsZW1lbnQgYXMgcmVzaXplTGlzdGVuZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZm9yIHdoaWNoIHJlc2l6ZSBldmVudHMgYXJlIGluaXRpYWxpc2VkXG4gICAqL1xuXG5cbiAgU3RpY2t5LnByb3RvdHlwZS5pbml0UmVzaXplRXZlbnRzID0gZnVuY3Rpb24gaW5pdFJlc2l6ZUV2ZW50cyhlbGVtZW50KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBlbGVtZW50LnN0aWNreS5yZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczMub25SZXNpemVFdmVudHMoZWxlbWVudCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZWxlbWVudC5zdGlja3kucmVzaXplTGlzdGVuZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGVsZW1lbnQgbGlzdGVuZXIgZnJvbSByZXNpemUgZXZlbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZnJvbSB3aGljaCBsaXN0ZW5lciBpcyBkZWxldGVkXG4gICAqL1xuXG5cbiAgU3RpY2t5LnByb3RvdHlwZS5kZXN0cm95UmVzaXplRXZlbnRzID0gZnVuY3Rpb24gZGVzdHJveVJlc2l6ZUV2ZW50cyhlbGVtZW50KSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGVsZW1lbnQuc3RpY2t5LnJlc2l6ZUxpc3RlbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gd2hpY2ggaXMgZmlyZWQgd2hlbiB1c2VyIHJlc2l6ZSB3aW5kb3cuIEl0IGNoZWNrcyBpZiBlbGVtZW50IHNob3VsZCBiZSBhY3RpdmF0ZWQgb3IgZGVhY3RpdmF0ZWQgYW5kIHRoZW4gcnVuIHNldFBvc2l0aW9uIGZ1bmN0aW9uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IGZvciB3aGljaCBldmVudCBmdW5jdGlvbiBpcyBmaXJlZFxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUub25SZXNpemVFdmVudHMgPSBmdW5jdGlvbiBvblJlc2l6ZUV2ZW50cyhlbGVtZW50KSB7XG4gICAgdGhpcy52cCA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplKCk7XG5cbiAgICBlbGVtZW50LnN0aWNreS5yZWN0ID0gdGhpcy5nZXRSZWN0YW5nbGUoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zdGlja3kuY29udGFpbmVyLnJlY3QgPSB0aGlzLmdldFJlY3RhbmdsZShlbGVtZW50LnN0aWNreS5jb250YWluZXIpO1xuXG4gICAgaWYgKGVsZW1lbnQuc3RpY2t5LnJlY3QudG9wICsgZWxlbWVudC5zdGlja3kucmVjdC5oZWlnaHQgPCBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC5oZWlnaHQgJiYgZWxlbWVudC5zdGlja3kuc3RpY2t5Rm9yIDwgdGhpcy52cC53aWR0aCAmJiAhZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICBlbGVtZW50LnN0aWNreS5hY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zdGlja3kucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCA+PSBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC5oZWlnaHQgfHwgZWxlbWVudC5zdGlja3kuc3RpY2t5Rm9yID49IHRoaXMudnAud2lkdGggJiYgZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICBlbGVtZW50LnN0aWNreS5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBvc2l0aW9uKGVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB3aGljaCBpcyBhZGRpbmcgb25TY3JvbGxFdmVudHMgdG8gd2luZG93IGxpc3RlbmVyIGFuZCBhc3NpZ25zIGZ1bmN0aW9uIHRvIGVsZW1lbnQgYXMgc2Nyb2xsTGlzdGVuZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZm9yIHdoaWNoIHNjcm9sbCBldmVudHMgYXJlIGluaXRpYWxpc2VkXG4gICAqL1xuXG5cbiAgU3RpY2t5LnByb3RvdHlwZS5pbml0U2Nyb2xsRXZlbnRzID0gZnVuY3Rpb24gaW5pdFNjcm9sbEV2ZW50cyhlbGVtZW50KSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBlbGVtZW50LnN0aWNreS5zY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczQub25TY3JvbGxFdmVudHMoZWxlbWVudCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZWxlbWVudC5zdGlja3kuc2Nyb2xsTGlzdGVuZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGVsZW1lbnQgbGlzdGVuZXIgZnJvbSBzY3JvbGwgZXZlbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZnJvbSB3aGljaCBsaXN0ZW5lciBpcyBkZWxldGVkXG4gICAqL1xuXG5cbiAgU3RpY2t5LnByb3RvdHlwZS5kZXN0cm95U2Nyb2xsRXZlbnRzID0gZnVuY3Rpb24gZGVzdHJveVNjcm9sbEV2ZW50cyhlbGVtZW50KSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGVsZW1lbnQuc3RpY2t5LnNjcm9sbExpc3RlbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gd2hpY2ggaXMgZmlyZWQgd2hlbiB1c2VyIHNjcm9sbCB3aW5kb3cuIElmIGVsZW1lbnQgaXMgYWN0aXZlLCBmdW5jdGlvbiBpcyBpbnZva2luZyBzZXRQb3NpdGlvbiBmdW5jdGlvblxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtub2RlfSBlbGVtZW50IC0gRWxlbWVudCBmb3Igd2hpY2ggZXZlbnQgZnVuY3Rpb24gaXMgZmlyZWRcbiAgICovXG5cblxuICBTdGlja3kucHJvdG90eXBlLm9uU2Nyb2xsRXZlbnRzID0gZnVuY3Rpb24gb25TY3JvbGxFdmVudHMoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LnN0aWNreS5hY3RpdmUpIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oZWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYWluIGZ1bmN0aW9uIGZvciB0aGUgbGlicmFyeS4gSGVyZSBhcmUgc29tZSBjb25kaXRpb24gY2FsY3VsYXRpb25zIGFuZCBjc3MgYXBwZW5kaW5nIGZvciBzdGlja3kgZWxlbWVudCB3aGVuIHVzZXIgc2Nyb2xsIHdpbmRvd1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtub2RlfSBlbGVtZW50IC0gRWxlbWVudCB0aGF0IHdpbGwgYmUgcG9zaXRpb25lZCBpZiBpdCdzIGFjdGl2ZVxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgdGhpcy5jc3MoZWxlbWVudCwgeyBwb3NpdGlvbjogJycsIHdpZHRoOiAnJywgdG9wOiAnJywgbGVmdDogJycgfSk7XG5cbiAgICBpZiAodGhpcy52cC5oZWlnaHQgPCBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCB8fCAhZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50LnN0aWNreS5yZWN0LndpZHRoKSB7XG4gICAgICBlbGVtZW50LnN0aWNreS5yZWN0ID0gdGhpcy5nZXRSZWN0YW5nbGUoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuc3RpY2t5LndyYXApIHtcbiAgICAgIHRoaXMuY3NzKGVsZW1lbnQucGFyZW50Tm9kZSwge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICB3aWR0aDogZWxlbWVudC5zdGlja3kucmVjdC53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5zdGlja3kucmVjdC5oZWlnaHQgKyAncHgnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5zdGlja3kucmVjdC50b3AgPT09IDAgJiYgZWxlbWVudC5zdGlja3kuY29udGFpbmVyID09PSB0aGlzLmJvZHkpIHtcbiAgICAgIHRoaXMuY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogZWxlbWVudC5zdGlja3kucmVjdC50b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiBlbGVtZW50LnN0aWNreS5yZWN0LmxlZnQgKyAncHgnLFxuICAgICAgICB3aWR0aDogZWxlbWVudC5zdGlja3kucmVjdC53aWR0aCArICdweCdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxUb3AgPiBlbGVtZW50LnN0aWNreS5yZWN0LnRvcCAtIGVsZW1lbnQuc3RpY2t5Lm1hcmdpblRvcCkge1xuICAgICAgdGhpcy5jc3MoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQuc3RpY2t5LnJlY3Qud2lkdGggKyAncHgnLFxuICAgICAgICBsZWZ0OiBlbGVtZW50LnN0aWNreS5yZWN0LmxlZnQgKyAncHgnXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wICsgZWxlbWVudC5zdGlja3kucmVjdC5oZWlnaHQgKyBlbGVtZW50LnN0aWNreS5tYXJnaW5Ub3AgPiBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5jb250YWluZXIub2Zmc2V0SGVpZ2h0KSB7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICB0b3A6IGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0LnRvcCArIGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSAodGhpcy5zY3JvbGxUb3AgKyBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCkgKyAncHgnIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3NzKGVsZW1lbnQsIHsgdG9wOiBlbGVtZW50LnN0aWNreS5tYXJnaW5Ub3AgKyAncHgnIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudC5zdGlja3kuc3RpY2t5Q2xhc3MpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jc3MoZWxlbWVudCwgeyBwb3NpdGlvbjogJycsIHdpZHRoOiAnJywgdG9wOiAnJywgbGVmdDogJycgfSk7XG5cbiAgICAgIGlmIChlbGVtZW50LnN0aWNreS53cmFwKSB7XG4gICAgICAgIHRoaXMuY3NzKGVsZW1lbnQucGFyZW50Tm9kZSwgeyBkaXNwbGF5OiAnJywgd2lkdGg6ICcnLCBoZWlnaHQ6ICcnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB1cGRhdGVzIGVsZW1lbnQgc3RpY2t5IHJlY3RhbmdsZSAod2l0aCBzdGlja3kgY29udGFpbmVyKSwgdGhlbiBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIGVsZW1lbnQsIHRoZW4gdXBkYXRlIHBvc2l0aW9uIGlmIGl0J3MgYWN0aXZlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdGhpcy5mb3JFYWNoKHRoaXMuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnN0aWNreS5yZWN0ID0gX3RoaXM1LmdldFJlY3RhbmdsZShlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0ID0gX3RoaXM1LmdldFJlY3RhbmdsZShlbGVtZW50LnN0aWNreS5jb250YWluZXIpO1xuXG4gICAgICBfdGhpczUuYWN0aXZhdGUoZWxlbWVudCk7XG4gICAgICBfdGhpczUuc2V0UG9zaXRpb24oZWxlbWVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHN0aWNreSBlbGVtZW50LCByZW1vdmUgbGlzdGVuZXJzXG4gICAqIEBmdW5jdGlvblxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB0aGlzLmZvckVhY2godGhpcy5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIF90aGlzNi5kZXN0cm95UmVzaXplRXZlbnRzKGVsZW1lbnQpO1xuICAgICAgX3RoaXM2LmRlc3Ryb3lTY3JvbGxFdmVudHMoZWxlbWVudCk7XG4gICAgICBkZWxldGUgZWxlbWVudC5zdGlja3k7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBjb250YWluZXIgZWxlbWVudCBpbiB3aGljaCBzdGlja3kgZWxlbWVudCBpcyBzdHVjayAoaWYgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBpdCdzIHN0dWNrIHRvIGJvZHkpXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IHdoaWNoIHN0aWNreSBjb250YWluZXIgYXJlIGxvb2tlZCBmb3JcbiAgICogQHJldHVybiB7bm9kZX0gZWxlbWVudCAtIFN0aWNreSBjb250YWluZXJcbiAgICovXG5cblxuICBTdGlja3kucHJvdG90eXBlLmdldFN0aWNreUNvbnRhaW5lciA9IGZ1bmN0aW9uIGdldFN0aWNreUNvbnRhaW5lcihlbGVtZW50KSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIHdoaWxlICghY29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1zdGlja3ktY29udGFpbmVyJykgJiYgIWNvbnRhaW5lci5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudC5zdGlja3kuc3RpY2t5Q29udGFpbmVyKSAmJiBjb250YWluZXIgIT09IHRoaXMuYm9keSkge1xuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGVsZW1lbnQgcmVjdGFuZ2xlICYgcG9zaXRpb24gKHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdClcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgd2hpY2ggcG9zaXRpb24gJiByZWN0YW5nbGUgYXJlIHJldHVybmVkXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG5cblxuICBTdGlja3kucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uIGdldFJlY3RhbmdsZShlbGVtZW50KSB7XG4gICAgdGhpcy5jc3MoZWxlbWVudCwgeyBwb3NpdGlvbjogJycsIHdpZHRoOiAnJywgdG9wOiAnJywgbGVmdDogJycgfSk7XG5cbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heChlbGVtZW50Lm9mZnNldFdpZHRoLCBlbGVtZW50LmNsaWVudFdpZHRoLCBlbGVtZW50LnNjcm9sbFdpZHRoKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoZWxlbWVudC5vZmZzZXRIZWlnaHQsIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBlbGVtZW50LnNjcm9sbEhlaWdodCk7XG5cbiAgICB2YXIgdG9wID0gMDtcbiAgICB2YXIgbGVmdCA9IDA7XG5cbiAgICBkbyB7XG4gICAgICB0b3AgKz0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgIGxlZnQgKz0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgfSB3aGlsZSAoZWxlbWVudCk7XG5cbiAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdmlld3BvcnQgZGltZW5zaW9uc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUuZ2V0Vmlld3BvcnRTaXplID0gZnVuY3Rpb24gZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB1cGRhdGVzIHdpbmRvdyBzY3JvbGwgcG9zaXRpb25cbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG5cblxuICBTdGlja3kucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFRvcFBvc2l0aW9uID0gZnVuY3Rpb24gdXBkYXRlU2Nyb2xsVG9wUG9zaXRpb24oKSB7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCkgLSAoZG9jdW1lbnQuY2xpZW50VG9wIHx8IDApIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgbG9vcHNcbiAgICogQGhlbHBlclxuICAgKiBAcGFyYW0ge2FycmF5fVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIChubyBuZWVkIGZvciBleHBsYW5hdGlvbilcbiAgICovXG5cblxuICBTdGlja3kucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2soYXJyYXlbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGFkZC9yZW1vdmUgY3NzIHByb3BlcnRpZXMgZm9yIHNwZWNpZmllZCBlbGVtZW50LlxuICAgKiBAaGVscGVyXG4gICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQ1NTIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgZnJvbSBzcGVjaWZpZWQgZWxlbWVudFxuICAgKi9cblxuXG4gIFN0aWNreS5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gY3NzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN0aWNreTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnQgZnVuY3Rpb24gdGhhdCBzdXBwb3J0cyBBTUQsIENvbW1vbkpTIGFuZCBQbGFpbiBCcm93c2VyLlxuICovXG5cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICByb290LlN0aWNreSA9IGZhY3Rvcnk7XG4gIH1cbn0pKHRoaXMsIFN0aWNreSk7IiwiXHJcbnZhciBTdGlja3kgPSByZXF1aXJlKCcuL2Rpc3Qvc3RpY2t5LmNvbXBpbGUuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RpY2t5O1xyXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjMuM1xuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJztcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgY29udGFpbmVyOiBmYWxzZSxcbiAgZGVsYXk6IDAsXG4gIGh0bWw6IGZhbHNlLFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICB0aXRsZTogJycsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxuICBvZmZzZXQ6IDAsXG4gIGFycm93U2VsZWN0b3I6ICcudG9vbHRpcC1hcnJvdywgLnRvb2x0aXBfX2Fycm93JyxcbiAgaW5uZXJTZWxlY3RvcjogJy50b29sdGlwLWlubmVyLCAudG9vbHRpcF9faW5uZXInXG59O1xuXG52YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBUb29sdGlwLmpzIGluc3RhbmNlXG4gICAqIEBjbGFzcyBUb29sdGlwXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSBET00gbm9kZSB1c2VkIGFzIHJlZmVyZW5jZSBvZiB0aGUgdG9vbHRpcCAoaXQgY2FuIGJlIGEgalF1ZXJ5IGVsZW1lbnQpLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wbGFjZW1lbnQ9J3RvcCdcbiAgICogICAgICBQbGFjZW1lbnQgb2YgdGhlIHBvcHBlciBhY2NlcHRlZCB2YWx1ZXM6IGB0b3AoLXN0YXJ0LCAtZW5kKSwgcmlnaHQoLXN0YXJ0LCAtZW5kKSwgYm90dG9tKC1zdGFydCwgLWVuZCksXG4gICAqICAgICAgbGVmdCgtc3RhcnQsIC1lbmQpYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXJyb3dTZWxlY3Rvcj0nLnRvb2x0aXAtYXJyb3csIC50b29sdGlwX19hcnJvdyddIC0gY2xhc3NOYW1lIHVzZWQgdG8gbG9jYXRlIHRoZSBET00gYXJyb3cgZWxlbWVudCBpbiB0aGUgdG9vbHRpcC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlubmVyU2VsZWN0b3I9Jy50b29sdGlwLWlubmVyLCAudG9vbHRpcF9faW5uZXInXSAtIGNsYXNzTmFtZSB1c2VkIHRvIGxvY2F0ZSB0aGUgRE9NIGlubmVyIGVsZW1lbnQgaW4gdGhlIHRvb2x0aXAuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfGZhbHNlfSBvcHRpb25zLmNvbnRhaW5lcj1mYWxzZSAtIEFwcGVuZCB0aGUgdG9vbHRpcCB0byBhIHNwZWNpZmljIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gb3B0aW9ucy5kZWxheT0wXG4gICAqICAgICAgRGVsYXkgc2hvd2luZyBhbmQgaGlkaW5nIHRoZSB0b29sdGlwIChtcykgLSBkb2VzIG5vdCBhcHBseSB0byBtYW51YWwgdHJpZ2dlciB0eXBlLlxuICAgKiAgICAgIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCBkZWxheSBpcyBhcHBsaWVkIHRvIGJvdGggaGlkZS9zaG93LlxuICAgKiAgICAgIE9iamVjdCBzdHJ1Y3R1cmUgaXM6IGB7IHNob3c6IDUwMCwgaGlkZTogMTAwIH1gXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5odG1sPWZhbHNlIC0gSW5zZXJ0IEhUTUwgaW50byB0aGUgdG9vbHRpcC4gSWYgZmFsc2UsIHRoZSBjb250ZW50IHdpbGwgaW5zZXJ0ZWQgd2l0aCBgdGV4dENvbnRlbnRgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGVtcGxhdGU9JzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+J11cbiAgICogICAgICBCYXNlIEhUTUwgdG8gdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b29sdGlwLlxuICAgKiAgICAgIFRoZSB0b29sdGlwJ3MgYHRpdGxlYCB3aWxsIGJlIGluamVjdGVkIGludG8gdGhlIGAudG9vbHRpcC1pbm5lcmAgb3IgYC50b29sdGlwX19pbm5lcmAuXG4gICAqICAgICAgYC50b29sdGlwLWFycm93YCBvciBgLnRvb2x0aXBfX2Fycm93YCB3aWxsIGJlY29tZSB0aGUgdG9vbHRpcCdzIGFycm93LlxuICAgKiAgICAgIFRoZSBvdXRlcm1vc3Qgd3JhcHBlciBlbGVtZW50IHNob3VsZCBoYXZlIHRoZSBgLnRvb2x0aXBgIGNsYXNzLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxUaXRsZUZ1bmN0aW9ufSBvcHRpb25zLnRpdGxlPScnIC0gRGVmYXVsdCB0aXRsZSB2YWx1ZSBpZiBgdGl0bGVgIGF0dHJpYnV0ZSBpc24ndCBwcmVzZW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJpZ2dlcj0naG92ZXIgZm9jdXMnXVxuICAgKiAgICAgIEhvdyB0b29sdGlwIGlzIHRyaWdnZXJlZCAtIGNsaWNrLCBob3ZlciwgZm9jdXMsIG1hbnVhbC5cbiAgICogICAgICBZb3UgbWF5IHBhc3MgbXVsdGlwbGUgdHJpZ2dlcnM7IHNlcGFyYXRlIHRoZW0gd2l0aCBhIHNwYWNlLiBgbWFudWFsYCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBhbnkgb3RoZXIgdHJpZ2dlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNsb3NlT25DbGlja091dHNpZGU9ZmFsc2UgLSBDbG9zZSBhIHBvcHBlciBvbiBjbGljayBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYW5kIHJlZmVyZW5jZSBlbGVtZW50LiBUaGlzIGhhcyBlZmZlY3Qgb25seSB3aGVuIG9wdGlvbnMudHJpZ2dlciBpcyAnY2xpY2snLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudFxuICAgKiAgICAgIFRoZSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllcyBmb3IgdGhlIHRvb2x0aXAuIEZvciBtb3JlIGluZm9ybWF0aW9uIHJlZmVyIHRvIFBvcHBlci5qcydcbiAgICogICAgICBbYm91bmRhcmllc0VsZW1lbnQgZG9jc10oaHR0cHM6Ly9wb3BwZXIuanMub3JnL3BvcHBlci1kb2N1bWVudGF0aW9uLmh0bWwpXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MCAtIE9mZnNldCBvZiB0aGUgdG9vbHRpcCByZWxhdGl2ZSB0byBpdHMgcmVmZXJlbmNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiByZWZlciB0byBQb3BwZXIuanMnXG4gICAqICAgICAgW29mZnNldCBkb2NzXShodHRwczovL3BvcHBlci5qcy5vcmcvcG9wcGVyLWRvY3VtZW50YXRpb24uaHRtbClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9wcGVyT3B0aW9ucz17fSAtIFBvcHBlciBvcHRpb25zLCB3aWxsIGJlIHBhc3NlZCBkaXJlY3RseSB0byBwb3BwZXIgaW5zdGFuY2UuIEZvciBtb3JlIGluZm9ybWF0aW9uIHJlZmVyIHRvIFBvcHBlci5qcydcbiAgICogICAgICBbb3B0aW9ucyBkb2NzXShodHRwczovL3BvcHBlci5qcy5vcmcvcG9wcGVyLWRvY3VtZW50YXRpb24uaHRtbClcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgdG9vbHRpcCBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gVG9vbHRpcChyZWZlcmVuY2UsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuICAgIF9pbml0aWFsaXNlUHJvcHMuY2FsbCh0aGlzKTtcblxuICAgIC8vIGFwcGx5IHVzZXIgb3B0aW9ucyBvdmVyIGRlZmF1bHQgb25lc1xuICAgIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcblxuICAgIHJlZmVyZW5jZS5qcXVlcnkgJiYgKHJlZmVyZW5jZSA9IHJlZmVyZW5jZVswXSk7XG5cbiAgICAvLyBjYWNoZSByZWZlcmVuY2UgYW5kIG9wdGlvbnNcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLy8gZ2V0IGV2ZW50cyBsaXN0XG4gICAgdmFyIGV2ZW50cyA9IHR5cGVvZiBvcHRpb25zLnRyaWdnZXIgPT09ICdzdHJpbmcnID8gb3B0aW9ucy50cmlnZ2VyLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICByZXR1cm4gWydjbGljaycsICdob3ZlcicsICdmb2N1cyddLmluZGV4T2YodHJpZ2dlcikgIT09IC0xO1xuICAgIH0pIDogW107XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZVxuICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuX3BvcHBlck9wdGlvbnMgPSB7fTtcblxuICAgIC8vIHNldCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIGV2ZW50cywgb3B0aW9ucyk7XG4gIH1cblxuICAvL1xuICAvLyBQdWJsaWMgbWV0aG9kc1xuICAvL1xuXG4gIC8qKlxuICAgKiBSZXZlYWxzIGFuIGVsZW1lbnQncyB0b29sdGlwLiBUaGlzIGlzIGNvbnNpZGVyZWQgYSBcIm1hbnVhbFwiIHRyaWdnZXJpbmcgb2YgdGhlIHRvb2x0aXAuXG4gICAqIFRvb2x0aXBzIHdpdGggemVyby1sZW5ndGggdGl0bGVzIGFyZSBuZXZlciBkaXNwbGF5ZWQuXG4gICAqIEBtZXRob2QgVG9vbHRpcCNzaG93XG4gICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEhpZGVzIGFuIGVsZW1lbnTigJlzIHRvb2x0aXAuIFRoaXMgaXMgY29uc2lkZXJlZCBhIOKAnG1hbnVhbOKAnSB0cmlnZ2VyaW5nIG9mIHRoZSB0b29sdGlwLlxuICAgKiBAbWV0aG9kIFRvb2x0aXAjaGlkZVxuICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBIaWRlcyBhbmQgZGVzdHJveXMgYW4gZWxlbWVudOKAmXMgdG9vbHRpcC5cbiAgICogQG1ldGhvZCBUb29sdGlwI2Rpc3Bvc2VcbiAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICovXG5cblxuICAvKipcbiAgICogVG9nZ2xlcyBhbiBlbGVtZW504oCZcyB0b29sdGlwLiBUaGlzIGlzIGNvbnNpZGVyZWQgYSDigJxtYW51YWzigJ0gdHJpZ2dlcmluZyBvZiB0aGUgdG9vbHRpcC5cbiAgICogQG1ldGhvZCBUb29sdGlwI3RvZ2dsZVxuICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0b29sdGlwJ3MgdGl0bGUgY29udGVudFxuICAgKiBAbWV0aG9kIFRvb2x0aXAjdXBkYXRlVGl0bGVDb250ZW50XG4gICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSB0aXRsZSAtIFRoZSBuZXcgY29udGVudCB0byB1c2UgZm9yIHRoZSB0aXRsZVxuICAgKi9cblxuXG4gIC8vXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuICAvL1xuXG4gIGNyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiAnX2NyZWF0ZScsXG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdG9vbHRpcCBub2RlXG4gICAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fFRpdGxlRnVuY3Rpb259IHRpdGxlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0h0bWxcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gdG9vbHRpcE5vZGVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZShyZWZlcmVuY2UsIHRlbXBsYXRlLCB0aXRsZSwgYWxsb3dIdG1sKSB7XG4gICAgICAvLyBjcmVhdGUgdG9vbHRpcCBlbGVtZW50XG4gICAgICB2YXIgdG9vbHRpcEdlbmVyYXRvciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRvb2x0aXBHZW5lcmF0b3IuaW5uZXJIVE1MID0gdGVtcGxhdGUudHJpbSgpO1xuICAgICAgdmFyIHRvb2x0aXBOb2RlID0gdG9vbHRpcEdlbmVyYXRvci5jaGlsZE5vZGVzWzBdO1xuXG4gICAgICAvLyBhZGQgdW5pcXVlIElEIHRvIG91ciB0b29sdGlwIChuZWVkZWQgZm9yIGFjY2Vzc2liaWxpdHkgcmVhc29ucylcbiAgICAgIHRvb2x0aXBOb2RlLmlkID0gJ3Rvb2x0aXBfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxMCk7XG5cbiAgICAgIC8vIHNldCBpbml0aWFsIGBhcmlhLWhpZGRlbmAgc3RhdGUgdG8gYGZhbHNlYCAoaXQncyB2aXNpYmxlISlcbiAgICAgIHRvb2x0aXBOb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgLy8gYWRkIHRpdGxlIHRvIHRvb2x0aXBcbiAgICAgIHZhciB0aXRsZU5vZGUgPSB0b29sdGlwR2VuZXJhdG9yLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmlubmVyU2VsZWN0b3IpO1xuICAgICAgdGhpcy5fYWRkVGl0bGVDb250ZW50KHJlZmVyZW5jZSwgdGl0bGUsIGFsbG93SHRtbCwgdGl0bGVOb2RlKTtcblxuICAgICAgLy8gcmV0dXJuIHRoZSBnZW5lcmF0ZWQgdG9vbHRpcCBub2RlXG4gICAgICByZXR1cm4gdG9vbHRpcE5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2FkZFRpdGxlQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUaXRsZUNvbnRlbnQocmVmZXJlbmNlLCB0aXRsZSwgYWxsb3dIdG1sLCB0aXRsZU5vZGUpIHtcbiAgICAgIGlmICh0aXRsZS5ub2RlVHlwZSA9PT0gMSB8fCB0aXRsZS5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgLy8gaWYgdGl0bGUgaXMgYSBlbGVtZW50IG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQsIGFwcGVuZCBpdCBvbmx5IGlmIGFsbG93SHRtbCBpcyB0cnVlXG4gICAgICAgIGFsbG93SHRtbCAmJiB0aXRsZU5vZGUuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpdGxlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjYWxsIG91cnNlbGYgc28gdGhhdCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBnZXRzIGhhbmRsZWQgYXBwcm9wcmlhdGVseSAtIGVpdGhlclxuICAgICAgICAvLyBhcyBhIGRvbSBub2RlLCBhIHN0cmluZywgb3IgZXZlbiBhcyBhbm90aGVyIGZ1bmN0aW9uLlxuICAgICAgICB0aGlzLl9hZGRUaXRsZUNvbnRlbnQocmVmZXJlbmNlLCB0aXRsZS5jYWxsKHJlZmVyZW5jZSksIGFsbG93SHRtbCwgdGl0bGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGl0J3MganVzdCBhIHNpbXBsZSB0ZXh0LCBzZXQgdGV4dENvbnRlbnQgb3IgaW5uZXJIdG1sIGRlcGVuZGluZyBieSBgYWxsb3dIdG1sYCB2YWx1ZVxuICAgICAgICBhbGxvd0h0bWwgPyB0aXRsZU5vZGUuaW5uZXJIVE1MID0gdGl0bGUgOiB0aXRsZU5vZGUudGV4dENvbnRlbnQgPSB0aXRsZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KHJlZmVyZW5jZSwgb3B0aW9ucykge1xuICAgICAgLy8gZG9uJ3Qgc2hvdyBpZiBpdCdzIGFscmVhZHkgdmlzaWJsZVxuICAgICAgLy8gb3IgaWYgaXQncyBub3QgYmVpbmcgc2hvd2VkXG4gICAgICBpZiAodGhpcy5faXNPcGVuICYmICF0aGlzLl9pc09wZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xuXG4gICAgICAvLyBpZiB0aGUgdG9vbHRpcE5vZGUgYWxyZWFkeSBleGlzdHMsIGp1c3Qgc2hvdyBpdFxuICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBOb2RlKSB7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aXRsZVxuICAgICAgdmFyIHRpdGxlID0gcmVmZXJlbmNlLmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCBvcHRpb25zLnRpdGxlO1xuXG4gICAgICAvLyBkb24ndCBzaG93IHRvb2x0aXAgaWYgbm8gdGl0bGUgaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIHRvb2x0aXAgbm9kZVxuICAgICAgdmFyIHRvb2x0aXBOb2RlID0gdGhpcy5fY3JlYXRlKHJlZmVyZW5jZSwgb3B0aW9ucy50ZW1wbGF0ZSwgdGl0bGUsIG9wdGlvbnMuaHRtbCk7XG5cbiAgICAgIC8vIEFkZCBgYXJpYS1kZXNjcmliZWRieWAgdG8gb3VyIHJlZmVyZW5jZSBlbGVtZW50IGZvciBhY2Nlc3NpYmlsaXR5IHJlYXNvbnNcbiAgICAgIHJlZmVyZW5jZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0b29sdGlwTm9kZS5pZCk7XG5cbiAgICAgIC8vIGFwcGVuZCB0b29sdGlwIHRvIGNvbnRhaW5lclxuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2ZpbmRDb250YWluZXIob3B0aW9ucy5jb250YWluZXIsIHJlZmVyZW5jZSk7XG5cbiAgICAgIHRoaXMuX2FwcGVuZCh0b29sdGlwTm9kZSwgY29udGFpbmVyKTtcblxuICAgICAgdGhpcy5fcG9wcGVyT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLnBvcHBlck9wdGlvbnMsIHtcbiAgICAgICAgcGxhY2VtZW50OiBvcHRpb25zLnBsYWNlbWVudFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3BvcHBlck9wdGlvbnMubW9kaWZpZXJzID0gX2V4dGVuZHMoe30sIHRoaXMuX3BvcHBlck9wdGlvbnMubW9kaWZpZXJzLCB7XG4gICAgICAgIGFycm93OiBfZXh0ZW5kcyh7fSwgdGhpcy5fcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgJiYgdGhpcy5fcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMuYXJyb3csIHtcbiAgICAgICAgICBlbGVtZW50OiBvcHRpb25zLmFycm93U2VsZWN0b3JcbiAgICAgICAgfSksXG4gICAgICAgIG9mZnNldDogX2V4dGVuZHMoe30sIHRoaXMuX3BvcHBlck9wdGlvbnMubW9kaWZpZXJzICYmIHRoaXMuX3BvcHBlck9wdGlvbnMubW9kaWZpZXJzLm9mZnNldCwge1xuICAgICAgICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQgfHwgdGhpcy5fcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgJiYgdGhpcy5fcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMub2Zmc2V0ICYmIHRoaXMuX3BvcHBlck9wdGlvbnMubW9kaWZpZXJzLm9mZnNldC5vZmZzZXQgfHwgb3B0aW9ucy5vZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5wcmV2ZW50T3ZlcmZsb3cgPSB7XG4gICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZSA9IG5ldyBQb3BwZXIocmVmZXJlbmNlLCB0b29sdGlwTm9kZSwgdGhpcy5fcG9wcGVyT3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlID0gdG9vbHRpcE5vZGU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19oaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSAvKnJlZmVyZW5jZSwgb3B0aW9ucyove1xuICAgICAgLy8gZG9uJ3QgaGlkZSBpZiBpdCdzIGFscmVhZHkgaGlkZGVuXG4gICAgICBpZiAoIXRoaXMuX2lzT3Blbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XG5cbiAgICAgIC8vIGhpZGUgdG9vbHRpcE5vZGVcbiAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZGlzcG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXNwb3NlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmaXJzdCB0byBwcmV2ZW50IGFueSB1bmV4cGVjdGVkIGJlaGF2aW91clxuICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBfcmVmLmZ1bmMsXG4gICAgICAgICAgICBldmVudCA9IF9yZWYuZXZlbnQ7XG5cbiAgICAgICAgX3RoaXMucmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBOb2RlKSB7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcblxuICAgICAgICAvLyBkZXN0cm95IGluc3RhbmNlXG4gICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIGRlc3Ryb3kgdG9vbHRpcE5vZGUgaWYgcmVtb3ZlT25EZXN0cm95IGlzIG5vdCBzZXQsIGFzIHBvcHBlckluc3RhbmNlLmRlc3Ryb3koKSBhbHJlYWR5IHJlbW92ZXMgdGhlIGVsZW1lbnRcbiAgICAgICAgaWYgKCF0aGlzLnBvcHBlckluc3RhbmNlLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgdGhpcy5fdG9vbHRpcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl90b29sdGlwTm9kZSk7XG4gICAgICAgICAgdGhpcy5fdG9vbHRpcE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZENvbnRhaW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQ29udGFpbmVyKGNvbnRhaW5lciwgcmVmZXJlbmNlKSB7XG4gICAgICAvLyBpZiBjb250YWluZXIgaXMgYSBxdWVyeSwgZ2V0IHRoZSByZWxhdGl2ZSBlbGVtZW50XG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGFpbmVyID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgICAvLyBpZiBjb250YWluZXIgaXMgYGZhbHNlYCwgc2V0IGl0IHRvIHJlZmVyZW5jZSBwYXJlbnRcbiAgICAgICAgY29udGFpbmVyID0gcmVmZXJlbmNlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCB0b29sdGlwIHRvIGNvbnRhaW5lclxuICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b29sdGlwTm9kZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfGZhbHNlfSBjb250YWluZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FwcGVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmQodG9vbHRpcE5vZGUsIGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXBOb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0RXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0RXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBldmVudHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZGlyZWN0RXZlbnRzID0gW107XG4gICAgICB2YXIgb3Bwb3NpdGVFdmVudHMgPSBbXTtcblxuICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgICBkaXJlY3RFdmVudHMucHVzaCgnbW91c2VlbnRlcicpO1xuICAgICAgICAgICAgb3Bwb3NpdGVFdmVudHMucHVzaCgnbW91c2VsZWF2ZScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgZGlyZWN0RXZlbnRzLnB1c2goJ2ZvY3VzJyk7XG4gICAgICAgICAgICBvcHBvc2l0ZUV2ZW50cy5wdXNoKCdibHVyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICBkaXJlY3RFdmVudHMucHVzaCgnY2xpY2snKTtcbiAgICAgICAgICAgIG9wcG9zaXRlRXZlbnRzLnB1c2goJ2NsaWNrJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIHNjaGVkdWxlIHNob3cgdG9vbHRpcFxuICAgICAgZGlyZWN0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYyhldnQpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLl9pc09wZW5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZ0LnVzZWRCeVRvb2x0aXAgPSB0cnVlO1xuICAgICAgICAgIF90aGlzMi5fc2NoZWR1bGVTaG93KHJlZmVyZW5jZSwgb3B0aW9ucy5kZWxheSwgb3B0aW9ucywgZXZ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMyLl9ldmVudHMucHVzaCh7IGV2ZW50OiBldmVudCwgZnVuYzogZnVuYyB9KTtcbiAgICAgICAgcmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNjaGVkdWxlIGhpZGUgdG9vbHRpcFxuICAgICAgb3Bwb3NpdGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKGV2dCkge1xuICAgICAgICAgIGlmIChldnQudXNlZEJ5VG9vbHRpcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczIuX3NjaGVkdWxlSGlkZShyZWZlcmVuY2UsIG9wdGlvbnMuZGVsYXksIG9wdGlvbnMsIGV2dCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMi5fZXZlbnRzLnB1c2goeyBldmVudDogZXZlbnQsIGZ1bmM6IGZ1bmMgfSk7XG4gICAgICAgIHJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jKTtcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnY2xpY2snICYmIG9wdGlvbnMuY2xvc2VPbkNsaWNrT3V0c2lkZSkge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzMi5faXNPcGVuaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3BwZXIgPSBfdGhpczIucG9wcGVySW5zdGFuY2UucG9wcGVyO1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZS5jb250YWlucyhlLnRhcmdldCkgfHwgcG9wcGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jKGUpO1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfc2NoZWR1bGVTaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NjaGVkdWxlU2hvdyhyZWZlcmVuY2UsIGRlbGF5LCBvcHRpb25zIC8qLCBldnQgKi8pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9pc09wZW5pbmcgPSB0cnVlO1xuICAgICAgLy8gZGVmYXVsdHMgdG8gMFxuICAgICAgdmFyIGNvbXB1dGVkRGVsYXkgPSBkZWxheSAmJiBkZWxheS5zaG93IHx8IGRlbGF5IHx8IDA7XG4gICAgICB0aGlzLl9zaG93VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc2hvdyhyZWZlcmVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSwgY29tcHV0ZWREZWxheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3NjaGVkdWxlSGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY2hlZHVsZUhpZGUocmVmZXJlbmNlLCBkZWxheSwgb3B0aW9ucywgZXZ0KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5faXNPcGVuaW5nID0gZmFsc2U7XG4gICAgICAvLyBkZWZhdWx0cyB0byAwXG4gICAgICB2YXIgY29tcHV0ZWREZWxheSA9IGRlbGF5ICYmIGRlbGF5LmhpZGUgfHwgZGVsYXkgfHwgMDtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVvdXQpO1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM0Ll9pc09wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhfdGhpczQuX3Rvb2x0aXBOb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBoaWRpbmcgYmVjYXVzZSBvZiBhIG1vdXNlbGVhdmUsIHdlIG11c3QgY2hlY2sgdGhhdCB0aGUgbmV3XG4gICAgICAgIC8vIHJlZmVyZW5jZSBpc24ndCB0aGUgdG9vbHRpcCwgYmVjYXVzZSBpbiB0aGlzIGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byBoaWRlIGl0XG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgICAgdmFyIGlzU2V0ID0gX3RoaXM0Ll9zZXRUb29sdGlwTm9kZUV2ZW50KGV2dCwgcmVmZXJlbmNlLCBkZWxheSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyBpZiB3ZSBzZXQgdGhlIG5ldyBldmVudCwgZG9uJ3QgaGlkZSB0aGUgdG9vbHRpcCB5ZXRcbiAgICAgICAgICAvLyB0aGUgbmV3IGV2ZW50IHdpbGwgdGFrZSBjYXJlIHRvIGhpZGUgaXQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgaWYgKGlzU2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM0Ll9oaWRlKHJlZmVyZW5jZSwgb3B0aW9ucyk7XG4gICAgICB9LCBjb21wdXRlZERlbGF5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlVGl0bGVDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVRpdGxlQ29udGVudCh0aXRsZSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl90b29sdGlwTm9kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudGl0bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRpdGxlTm9kZSA9IHRoaXMuX3Rvb2x0aXBOb2RlLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmlubmVyU2VsZWN0b3IpO1xuICAgICAgdGhpcy5fY2xlYXJUaXRsZUNvbnRlbnQodGl0bGVOb2RlLCB0aGlzLm9wdGlvbnMuaHRtbCwgdGhpcy5yZWZlcmVuY2UuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRoaXMub3B0aW9ucy50aXRsZSk7XG4gICAgICB0aGlzLl9hZGRUaXRsZUNvbnRlbnQodGhpcy5yZWZlcmVuY2UsIHRpdGxlLCB0aGlzLm9wdGlvbnMuaHRtbCwgdGl0bGVOb2RlKTtcbiAgICAgIHRoaXMub3B0aW9ucy50aXRsZSA9IHRpdGxlO1xuICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYXJUaXRsZUNvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYXJUaXRsZUNvbnRlbnQodGl0bGVOb2RlLCBhbGxvd0h0bWwsIGxhc3RUaXRsZSkge1xuICAgICAgaWYgKGxhc3RUaXRsZS5ub2RlVHlwZSA9PT0gMSB8fCBsYXN0VGl0bGUubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgIGFsbG93SHRtbCAmJiB0aXRsZU5vZGUucmVtb3ZlQ2hpbGQobGFzdFRpdGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93SHRtbCA/IHRpdGxlTm9kZS5pbm5lckhUTUwgPSAnJyA6IHRpdGxlTm9kZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVG9vbHRpcDtcbn0oKTtcblxuLyoqXG4gKiBUaXRsZSBmdW5jdGlvbiwgaXRzIGNvbnRleHQgaXMgdGhlIFRvb2x0aXAgaW5zdGFuY2UuXG4gKiBAbWVtYmVyb2YgVG9vbHRpcFxuICogQGNhbGxiYWNrIFRpdGxlRnVuY3Rpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gcGxhY2VtZW50IC0gVGhlIGRlc2lyZWQgdGl0bGUuXG4gKi9cblxuXG52YXIgX2luaXRpYWxpc2VQcm9wcyA9IGZ1bmN0aW9uIF9pbml0aWFsaXNlUHJvcHMoKSB7XG4gIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gIHRoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXM1Ll9zaG93KF90aGlzNS5yZWZlcmVuY2UsIF90aGlzNS5vcHRpb25zKTtcbiAgfTtcblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzNS5faGlkZSgpO1xuICB9O1xuXG4gIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXM1Ll9kaXNwb3NlKCk7XG4gIH07XG5cbiAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzNS5faXNPcGVuKSB7XG4gICAgICByZXR1cm4gX3RoaXM1LmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF90aGlzNS5zaG93KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMudXBkYXRlVGl0bGVDb250ZW50ID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgcmV0dXJuIF90aGlzNS5fdXBkYXRlVGl0bGVDb250ZW50KHRpdGxlKTtcbiAgfTtcblxuICB0aGlzLl9ldmVudHMgPSBbXTtcblxuICB0aGlzLl9zZXRUb29sdGlwTm9kZUV2ZW50ID0gZnVuY3Rpb24gKGV2dCwgcmVmZXJlbmNlLCBkZWxheSwgb3B0aW9ucykge1xuICAgIHZhciByZWxhdGVkcmVmZXJlbmNlID0gZXZ0LnJlbGF0ZWRyZWZlcmVuY2UgfHwgZXZ0LnRvRWxlbWVudCB8fCBldnQucmVsYXRlZFRhcmdldDtcblxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGV2dDIpIHtcbiAgICAgIHZhciByZWxhdGVkcmVmZXJlbmNlMiA9IGV2dDIucmVsYXRlZHJlZmVyZW5jZSB8fCBldnQyLnRvRWxlbWVudCB8fCBldnQyLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciBhZnRlciBjYWxsXG4gICAgICBfdGhpczUuX3Rvb2x0aXBOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LnR5cGUsIGNhbGxiYWNrKTtcblxuICAgICAgLy8gSWYgdGhlIG5ldyByZWZlcmVuY2UgaXMgbm90IHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgICAgaWYgKCFyZWZlcmVuY2UuY29udGFpbnMocmVsYXRlZHJlZmVyZW5jZTIpKSB7XG4gICAgICAgIC8vIFNjaGVkdWxlIHRvIGhpZGUgdG9vbHRpcFxuICAgICAgICBfdGhpczUuX3NjaGVkdWxlSGlkZShyZWZlcmVuY2UsIG9wdGlvbnMuZGVsYXksIG9wdGlvbnMsIGV2dDIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoX3RoaXM1Ll90b29sdGlwTm9kZS5jb250YWlucyhyZWxhdGVkcmVmZXJlbmNlKSkge1xuICAgICAgLy8gbGlzdGVuIHRvIG1vdXNlbGVhdmUgb24gdGhlIHRvb2x0aXAgZWxlbWVudCB0byBiZSBhYmxlIHRvIGhpZGUgdGhlIHRvb2x0aXBcbiAgICAgIF90aGlzNS5fdG9vbHRpcE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnQudHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2x0aXAuanMubWFwXG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCIoZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAvLyBOb2RlL0NvbW1vbkpTXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICB3aW5kb3cud051bWIgPSBmYWN0b3J5KCk7XHJcbiAgfVxyXG59KShmdW5jdGlvbigpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIEZvcm1hdE9wdGlvbnMgPSBbXHJcbiAgICBcImRlY2ltYWxzXCIsXHJcbiAgICBcInRob3VzYW5kXCIsXHJcbiAgICBcIm1hcmtcIixcclxuICAgIFwicHJlZml4XCIsXHJcbiAgICBcInN1ZmZpeFwiLFxyXG4gICAgXCJlbmNvZGVyXCIsXHJcbiAgICBcImRlY29kZXJcIixcclxuICAgIFwibmVnYXRpdmVCZWZvcmVcIixcclxuICAgIFwibmVnYXRpdmVcIixcclxuICAgIFwiZWRpdFwiLFxyXG4gICAgXCJ1bmRvXCJcclxuICBdO1xyXG5cclxuICAvLyBHZW5lcmFsXHJcblxyXG4gIC8vIFJldmVyc2UgYSBzdHJpbmdcclxuICBmdW5jdGlvbiBzdHJSZXZlcnNlKGEpIHtcclxuICAgIHJldHVybiBhXHJcbiAgICAgIC5zcGxpdChcIlwiKVxyXG4gICAgICAucmV2ZXJzZSgpXHJcbiAgICAgIC5qb2luKFwiXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggYSBzcGVjaWZpZWQgcHJlZml4LlxyXG4gIGZ1bmN0aW9uIHN0clN0YXJ0c1dpdGgoaW5wdXQsIG1hdGNoKSB7XHJcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKDAsIG1hdGNoLmxlbmd0aCkgPT09IG1hdGNoO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaXMgYSBzdHJpbmcgZW5kcyBpbiBhIHNwZWNpZmllZCBzdWZmaXguXHJcbiAgZnVuY3Rpb24gc3RyRW5kc1dpdGgoaW5wdXQsIG1hdGNoKSB7XHJcbiAgICByZXR1cm4gaW5wdXQuc2xpY2UoLTEgKiBtYXRjaC5sZW5ndGgpID09PSBtYXRjaDtcclxuICB9XHJcblxyXG4gIC8vIFRocm93IGFuIGVycm9yIGlmIGZvcm1hdHRpbmcgb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlLlxyXG4gIGZ1bmN0aW9uIHRocm93RXF1YWxFcnJvcihGLCBhLCBiKSB7XHJcbiAgICBpZiAoKEZbYV0gfHwgRltiXSkgJiYgRlthXSA9PT0gRltiXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiBhIG51bWJlciBpcyBmaW5pdGUgYW5kIG5vdCBOYU5cclxuICBmdW5jdGlvbiBpc1ZhbGlkTnVtYmVyKGlucHV0KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGlucHV0KTtcclxuICB9XHJcblxyXG4gIC8vIFByb3ZpZGUgcm91bmRpbmctYWNjdXJhdGUgdG9GaXhlZCBtZXRob2QuXHJcbiAgLy8gQm9ycm93ZWQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMzIzMzMwLzc3NTI2NVxyXG4gIGZ1bmN0aW9uIHRvRml4ZWQodmFsdWUsIGV4cCkge1xyXG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KFwiZVwiKTtcclxuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgrKHZhbHVlWzBdICsgXCJlXCIgKyAodmFsdWVbMV0gPyArdmFsdWVbMV0gKyBleHAgOiBleHApKSk7XHJcbiAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoXCJlXCIpO1xyXG4gICAgcmV0dXJuICgrKHZhbHVlWzBdICsgXCJlXCIgKyAodmFsdWVbMV0gPyArdmFsdWVbMV0gLSBleHAgOiAtZXhwKSkpLnRvRml4ZWQoZXhwKTtcclxuICB9XHJcblxyXG4gIC8vIEZvcm1hdHRpbmdcclxuXHJcbiAgLy8gQWNjZXB0IGEgbnVtYmVyIGFzIGlucHV0LCBvdXRwdXQgZm9ybWF0dGVkIHN0cmluZy5cclxuICBmdW5jdGlvbiBmb3JtYXRUbyhcclxuICAgIGRlY2ltYWxzLFxyXG4gICAgdGhvdXNhbmQsXHJcbiAgICBtYXJrLFxyXG4gICAgcHJlZml4LFxyXG4gICAgc3VmZml4LFxyXG4gICAgZW5jb2RlcixcclxuICAgIGRlY29kZXIsXHJcbiAgICBuZWdhdGl2ZUJlZm9yZSxcclxuICAgIG5lZ2F0aXZlLFxyXG4gICAgZWRpdCxcclxuICAgIHVuZG8sXHJcbiAgICBpbnB1dFxyXG4gICkge1xyXG4gICAgdmFyIG9yaWdpbmFsSW5wdXQgPSBpbnB1dCxcclxuICAgICAgaW5wdXRJc05lZ2F0aXZlLFxyXG4gICAgICBpbnB1dFBpZWNlcyxcclxuICAgICAgaW5wdXRCYXNlLFxyXG4gICAgICBpbnB1dERlY2ltYWxzID0gXCJcIixcclxuICAgICAgb3V0cHV0ID0gXCJcIjtcclxuXHJcbiAgICAvLyBBcHBseSB1c2VyIGVuY29kZXIgdG8gdGhlIGlucHV0LlxyXG4gICAgLy8gRXhwZWN0ZWQgb3V0Y29tZTogbnVtYmVyLlxyXG4gICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgaW5wdXQgPSBlbmNvZGVyKGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdG9wIGlmIG5vIHZhbGlkIG51bWJlciB3YXMgcHJvdmlkZWQsIHRoZSBudW1iZXIgaXMgaW5maW5pdGUgb3IgTmFOLlxyXG4gICAgaWYgKCFpc1ZhbGlkTnVtYmVyKGlucHV0KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUm91bmRpbmcgYXdheSBkZWNpbWFscyBtaWdodCBjYXVzZSBhIHZhbHVlIG9mIC0wXHJcbiAgICAvLyB3aGVuIHVzaW5nIHZlcnkgc21hbGwgcmFuZ2VzLiBSZW1vdmUgdGhvc2UgY2FzZXMuXHJcbiAgICBpZiAoZGVjaW1hbHMgIT09IGZhbHNlICYmIHBhcnNlRmxvYXQoaW5wdXQudG9GaXhlZChkZWNpbWFscykpID09PSAwKSB7XHJcbiAgICAgIGlucHV0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3JtYXR0aW5nIGlzIGRvbmUgb24gYWJzb2x1dGUgbnVtYmVycyxcclxuICAgIC8vIGRlY29yYXRlZCBieSBhbiBvcHRpb25hbCBuZWdhdGl2ZSBzeW1ib2wuXHJcbiAgICBpZiAoaW5wdXQgPCAwKSB7XHJcbiAgICAgIGlucHV0SXNOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICAgIGlucHV0ID0gTWF0aC5hYnMoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHRoZSBzcGVjaWZpZWQgb3B0aW9uLlxyXG4gICAgaWYgKGRlY2ltYWxzICE9PSBmYWxzZSkge1xyXG4gICAgICBpbnB1dCA9IHRvRml4ZWQoaW5wdXQsIGRlY2ltYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdGhlIG51bWJlciBpbnRvIGEgc3RyaW5nLCBzbyBpdCBjYW4gYmUgc3BsaXQuXHJcbiAgICBpbnB1dCA9IGlucHV0LnRvU3RyaW5nKCk7XHJcblxyXG4gICAgLy8gQnJlYWsgdGhlIG51bWJlciBvbiB0aGUgZGVjaW1hbCBzZXBhcmF0b3IuXHJcbiAgICBpZiAoaW5wdXQuaW5kZXhPZihcIi5cIikgIT09IC0xKSB7XHJcbiAgICAgIGlucHV0UGllY2VzID0gaW5wdXQuc3BsaXQoXCIuXCIpO1xyXG5cclxuICAgICAgaW5wdXRCYXNlID0gaW5wdXRQaWVjZXNbMF07XHJcblxyXG4gICAgICBpZiAobWFyaykge1xyXG4gICAgICAgIGlucHV0RGVjaW1hbHMgPSBtYXJrICsgaW5wdXRQaWVjZXNbMV07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIGl0IGlzbid0IHNwbGl0LCB0aGUgZW50aXJlIG51bWJlciB3aWxsIGRvLlxyXG4gICAgICBpbnB1dEJhc2UgPSBpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHcm91cCBudW1iZXJzIGluIHNldHMgb2YgdGhyZWUuXHJcbiAgICBpZiAodGhvdXNhbmQpIHtcclxuICAgICAgaW5wdXRCYXNlID0gc3RyUmV2ZXJzZShpbnB1dEJhc2UpLm1hdGNoKC8uezEsM30vZyk7XHJcbiAgICAgIGlucHV0QmFzZSA9IHN0clJldmVyc2UoaW5wdXRCYXNlLmpvaW4oc3RyUmV2ZXJzZSh0aG91c2FuZCkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgbnVtYmVyIGlzIG5lZ2F0aXZlLCBwcmVmaXggd2l0aCBuZWdhdGlvbiBzeW1ib2wuXHJcbiAgICBpZiAoaW5wdXRJc05lZ2F0aXZlICYmIG5lZ2F0aXZlQmVmb3JlKSB7XHJcbiAgICAgIG91dHB1dCArPSBuZWdhdGl2ZUJlZm9yZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVmaXggdGhlIG51bWJlclxyXG4gICAgaWYgKHByZWZpeCkge1xyXG4gICAgICBvdXRwdXQgKz0gcHJlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vcm1hbCBuZWdhdGl2ZSBvcHRpb24gY29tZXMgYWZ0ZXIgdGhlIHByZWZpeC4gRGVmYXVsdHMgdG8gJy0nLlxyXG4gICAgaWYgKGlucHV0SXNOZWdhdGl2ZSAmJiBuZWdhdGl2ZSkge1xyXG4gICAgICBvdXRwdXQgKz0gbmVnYXRpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXBwZW5kIHRoZSBhY3R1YWwgbnVtYmVyLlxyXG4gICAgb3V0cHV0ICs9IGlucHV0QmFzZTtcclxuICAgIG91dHB1dCArPSBpbnB1dERlY2ltYWxzO1xyXG5cclxuICAgIC8vIEFwcGx5IHRoZSBzdWZmaXguXHJcbiAgICBpZiAoc3VmZml4KSB7XHJcbiAgICAgIG91dHB1dCArPSBzdWZmaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUnVuIHRoZSBvdXRwdXQgdGhyb3VnaCBhIHVzZXItc3BlY2lmaWVkIHBvc3QtZm9ybWF0dGVyLlxyXG4gICAgaWYgKGVkaXQpIHtcclxuICAgICAgb3V0cHV0ID0gZWRpdChvdXRwdXQsIG9yaWdpbmFsSW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsbCBkb25lLlxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxuICB9XHJcblxyXG4gIC8vIEFjY2VwdCBhIHN0aW5nIGFzIGlucHV0LCBvdXRwdXQgZGVjb2RlZCBudW1iZXIuXHJcbiAgZnVuY3Rpb24gZm9ybWF0RnJvbShcclxuICAgIGRlY2ltYWxzLFxyXG4gICAgdGhvdXNhbmQsXHJcbiAgICBtYXJrLFxyXG4gICAgcHJlZml4LFxyXG4gICAgc3VmZml4LFxyXG4gICAgZW5jb2RlcixcclxuICAgIGRlY29kZXIsXHJcbiAgICBuZWdhdGl2ZUJlZm9yZSxcclxuICAgIG5lZ2F0aXZlLFxyXG4gICAgZWRpdCxcclxuICAgIHVuZG8sXHJcbiAgICBpbnB1dFxyXG4gICkge1xyXG4gICAgdmFyIG9yaWdpbmFsSW5wdXQgPSBpbnB1dCxcclxuICAgICAgaW5wdXRJc05lZ2F0aXZlLFxyXG4gICAgICBvdXRwdXQgPSBcIlwiO1xyXG5cclxuICAgIC8vIFVzZXIgZGVmaW5lZCBwcmUtZGVjb2Rlci4gUmVzdWx0IG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nLlxyXG4gICAgaWYgKHVuZG8pIHtcclxuICAgICAgaW5wdXQgPSB1bmRvKGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IHRoZSBpbnB1dC4gQ2FuJ3QgYmUgZW1wdHkuXHJcbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCB0aGUgbmVnYXRpdmVCZWZvcmUgdmFsdWU6IHJlbW92ZSBpdC5cclxuICAgIC8vIFJlbWVtYmVyIGlzIHdhcyB0aGVyZSwgdGhlIG51bWJlciBpcyBuZWdhdGl2ZS5cclxuICAgIGlmIChuZWdhdGl2ZUJlZm9yZSAmJiBzdHJTdGFydHNXaXRoKGlucHV0LCBuZWdhdGl2ZUJlZm9yZSkpIHtcclxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKG5lZ2F0aXZlQmVmb3JlLCBcIlwiKTtcclxuICAgICAgaW5wdXRJc05lZ2F0aXZlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXBlYXQgdGhlIHNhbWUgcHJvY2VkdXJlIGZvciB0aGUgcHJlZml4LlxyXG4gICAgaWYgKHByZWZpeCAmJiBzdHJTdGFydHNXaXRoKGlucHV0LCBwcmVmaXgpKSB7XHJcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShwcmVmaXgsIFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFuZCBhZ2FpbiBmb3IgbmVnYXRpdmUuXHJcbiAgICBpZiAobmVnYXRpdmUgJiYgc3RyU3RhcnRzV2l0aChpbnB1dCwgbmVnYXRpdmUpKSB7XHJcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShuZWdhdGl2ZSwgXCJcIik7XHJcbiAgICAgIGlucHV0SXNOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSBzdWZmaXguXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc2xpY2VcclxuICAgIGlmIChzdWZmaXggJiYgc3RyRW5kc1dpdGgoaW5wdXQsIHN1ZmZpeCkpIHtcclxuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgwLCAtMSAqIHN1ZmZpeC5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgdGhvdXNhbmQgZ3JvdXBpbmcuXHJcbiAgICBpZiAodGhvdXNhbmQpIHtcclxuICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdCh0aG91c2FuZCkuam9pbihcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgdGhlIGRlY2ltYWwgc2VwYXJhdG9yIGJhY2sgdG8gcGVyaW9kLlxyXG4gICAgaWYgKG1hcmspIHtcclxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKG1hcmssIFwiLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVwZW5kIHRoZSBuZWdhdGl2ZSBzeW1ib2wuXHJcbiAgICBpZiAoaW5wdXRJc05lZ2F0aXZlKSB7XHJcbiAgICAgIG91dHB1dCArPSBcIi1cIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIG51bWJlclxyXG4gICAgb3V0cHV0ICs9IGlucHV0O1xyXG5cclxuICAgIC8vIFRyaW0gYWxsIG5vbi1udW1lcmljIGNoYXJhY3RlcnMgKGFsbG93ICcuJyBhbmQgJy0nKTtcclxuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bXjAtOVxcLlxcLS5dL2csIFwiXCIpO1xyXG5cclxuICAgIC8vIFRoZSB2YWx1ZSBjb250YWlucyBubyBwYXJzZS1hYmxlIG51bWJlci5cclxuICAgIGlmIChvdXRwdXQgPT09IFwiXCIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvdmVydCB0byBudW1iZXIuXHJcbiAgICBvdXRwdXQgPSBOdW1iZXIob3V0cHV0KTtcclxuXHJcbiAgICAvLyBSdW4gdGhlIHVzZXItc3BlY2lmaWVkIHBvc3QtZGVjb2Rlci5cclxuICAgIGlmIChkZWNvZGVyKSB7XHJcbiAgICAgIG91dHB1dCA9IGRlY29kZXIob3V0cHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpcyB0aGUgb3V0cHV0IGlzIHZhbGlkLCBvdGhlcndpc2U6IHJldHVybiBmYWxzZS5cclxuICAgIGlmICghaXNWYWxpZE51bWJlcihvdXRwdXQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG4gIH1cclxuXHJcbiAgLy8gRnJhbWV3b3JrXHJcblxyXG4gIC8vIFZhbGlkYXRlIGZvcm1hdHRpbmcgb3B0aW9uc1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKGlucHV0T3B0aW9ucykge1xyXG4gICAgdmFyIGksXHJcbiAgICAgIG9wdGlvbk5hbWUsXHJcbiAgICAgIG9wdGlvblZhbHVlLFxyXG4gICAgICBmaWx0ZXJlZE9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAoaW5wdXRPcHRpb25zW1wic3VmZml4XCJdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaW5wdXRPcHRpb25zW1wic3VmZml4XCJdID0gaW5wdXRPcHRpb25zW1wicG9zdGZpeFwiXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgRm9ybWF0T3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICBvcHRpb25OYW1lID0gRm9ybWF0T3B0aW9uc1tpXTtcclxuICAgICAgb3B0aW9uVmFsdWUgPSBpbnB1dE9wdGlvbnNbb3B0aW9uTmFtZV07XHJcblxyXG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIE9ubHkgZGVmYXVsdCBpZiBuZWdhdGl2ZUJlZm9yZSBpc24ndCBzZXQuXHJcbiAgICAgICAgaWYgKG9wdGlvbk5hbWUgPT09IFwibmVnYXRpdmVcIiAmJiAhZmlsdGVyZWRPcHRpb25zLm5lZ2F0aXZlQmVmb3JlKSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBcIi1cIjtcclxuICAgICAgICAgIC8vIERvbid0IHNldCBhIGRlZmF1bHQgZm9yIG1hcmsgd2hlbiAndGhvdXNhbmQnIGlzIHNldC5cclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09IFwibWFya1wiICYmIGZpbHRlcmVkT3B0aW9ucy50aG91c2FuZCAhPT0gXCIuXCIpIHtcclxuICAgICAgICAgIGZpbHRlcmVkT3B0aW9uc1tvcHRpb25OYW1lXSA9IFwiLlwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZsb2F0aW5nIHBvaW50cyBpbiBKUyBhcmUgc3RhYmxlIHVwIHRvIDcgZGVjaW1hbHMuXHJcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gXCJkZWNpbWFsc1wiKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID49IDAgJiYgb3B0aW9uVmFsdWUgPCA4KSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBvcHRpb25WYWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbk5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlc2Ugb3B0aW9ucywgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBmdW5jdGlvbnMuXHJcbiAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgb3B0aW9uTmFtZSA9PT0gXCJlbmNvZGVyXCIgfHxcclxuICAgICAgICBvcHRpb25OYW1lID09PSBcImRlY29kZXJcIiB8fFxyXG4gICAgICAgIG9wdGlvbk5hbWUgPT09IFwiZWRpdFwiIHx8XHJcbiAgICAgICAgb3B0aW9uTmFtZSA9PT0gXCJ1bmRvXCJcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBvcHRpb25WYWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbk5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXIgb3B0aW9ucyBhcmUgc3RyaW5ncy5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBvcHRpb25WYWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbk5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvbWUgdmFsdWVzIGNhbid0IGJlIGV4dHJhY3RlZCBmcm9tIGFcclxuICAgIC8vIHN0cmluZyBpZiBjZXJ0YWluIGNvbWJpbmF0aW9ucyBhcmUgcHJlc2VudC5cclxuICAgIHRocm93RXF1YWxFcnJvcihmaWx0ZXJlZE9wdGlvbnMsIFwibWFya1wiLCBcInRob3VzYW5kXCIpO1xyXG4gICAgdGhyb3dFcXVhbEVycm9yKGZpbHRlcmVkT3B0aW9ucywgXCJwcmVmaXhcIiwgXCJuZWdhdGl2ZVwiKTtcclxuICAgIHRocm93RXF1YWxFcnJvcihmaWx0ZXJlZE9wdGlvbnMsIFwicHJlZml4XCIsIFwibmVnYXRpdmVCZWZvcmVcIik7XHJcblxyXG4gICAgcmV0dXJuIGZpbHRlcmVkT3B0aW9ucztcclxuICB9XHJcblxyXG4gIC8vIFBhc3MgYWxsIG9wdGlvbnMgYXMgZnVuY3Rpb24gYXJndW1lbnRzXHJcbiAgZnVuY3Rpb24gcGFzc0FsbChvcHRpb25zLCBtZXRob2QsIGlucHV0KSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgYXJncyA9IFtdO1xyXG5cclxuICAgIC8vIEFkZCBhbGwgb3B0aW9ucyBpbiBvcmRlciBvZiBGb3JtYXRPcHRpb25zXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgRm9ybWF0T3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICBhcmdzLnB1c2gob3B0aW9uc1tGb3JtYXRPcHRpb25zW2ldXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXBwZW5kIHRoZSBpbnB1dCwgdGhlbiBjYWxsIHRoZSBtZXRob2QsIHByZXNlbnRpbmcgYWxsXHJcbiAgICAvLyBvcHRpb25zIGFzIGFyZ3VtZW50cy5cclxuICAgIGFyZ3MucHVzaChpbnB1dCk7XHJcbiAgICByZXR1cm4gbWV0aG9kLmFwcGx5KFwiXCIsIGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gd051bWIob3B0aW9ucykge1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHdOdW1iKSkge1xyXG4gICAgICByZXR1cm4gbmV3IHdOdW1iKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyA9IHZhbGlkYXRlKG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIENhbGwgJ2Zvcm1hdFRvJyB3aXRoIHByb3BlciBhcmd1bWVudHMuXHJcbiAgICB0aGlzLnRvID0gZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgcmV0dXJuIHBhc3NBbGwob3B0aW9ucywgZm9ybWF0VG8sIGlucHV0KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2FsbCAnZm9ybWF0RnJvbScgd2l0aCBwcm9wZXIgYXJndW1lbnRzLlxyXG4gICAgdGhpcy5mcm9tID0gZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgcmV0dXJuIHBhc3NBbGwob3B0aW9ucywgZm9ybWF0RnJvbSwgaW5wdXQpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB3TnVtYjtcclxufSk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBjbGFzcyBLQXBwXG4gKi9cblxudmFyIEtUQXBwID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R9IGNvbG9ycyBTdGF0ZSBjb2xvcnMgKiovXG4gICAgdmFyIGNvbG9ycyA9IHt9O1xuXG4gICAgdmFyIGluaXRUb29sdGlwID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIHNraW4gPSBlbC5kYXRhKCdza2luJykgPyAndG9vbHRpcC0nICsgZWwuZGF0YSgnc2tpbicpIDogJyc7XG4gICAgICAgIHZhciB3aWR0aCA9IGVsLmRhdGEoJ3dpZHRoJykgPT09ICdhdXRvJyA/ICd0b29sdG9wLWF1dG8td2lkdGgnIDogJyc7XG4gICAgICAgIHZhciB0cmlnZ2VyVmFsdWUgPSBlbC5kYXRhKCd0cmlnZ2VyJykgPyBlbC5kYXRhKCd0cmlnZ2VyJykgOiAnaG92ZXInO1xuICAgICAgICB2YXIgcGxhY2VtZW50ID0gZWwuZGF0YSgncGxhY2VtZW50JykgPyBlbC5kYXRhKCdwbGFjZW1lbnQnKSA6ICdsZWZ0JztcblxuICAgICAgICBlbC50b29sdGlwKHtcbiAgICAgICAgICAgIHRyaWdnZXI6IHRyaWdnZXJWYWx1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXAgJyArIHNraW4gKyAnICcgKyB3aWR0aCArICdcIiByb2xlPVwidG9vbHRpcFwiPlxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PlxcXG4gICAgICAgICAgICA8L2Rpdj4nXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbml0VG9vbHRpcHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW5pdCBib290c3RyYXAgdG9vbHRpcHNcbiAgICAgICAgJCgnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0VG9vbHRpcCgkKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRQb3BvdmVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIHNraW4gPSBlbC5kYXRhKCdza2luJykgPyAncG9wb3Zlci0nICsgZWwuZGF0YSgnc2tpbicpIDogJyc7XG4gICAgICAgIHZhciB0cmlnZ2VyVmFsdWUgPSBlbC5kYXRhKCd0cmlnZ2VyJykgPyBlbC5kYXRhKCd0cmlnZ2VyJykgOiAnaG92ZXInO1xuXG4gICAgICAgIGVsLnBvcG92ZXIoe1xuICAgICAgICAgICAgdHJpZ2dlcjogdHJpZ2dlclZhbHVlLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICdcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXIgJyArIHNraW4gKyAnXCIgcm9sZT1cInRvb2x0aXBcIj5cXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPlxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PlxcXG4gICAgICAgICAgICA8L2Rpdj4nXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbml0UG9wb3ZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW5pdCBib290c3RyYXAgcG9wb3ZlclxuICAgICAgICAkKCdbZGF0YS10b2dnbGU9XCJwb3BvdmVyXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRQb3BvdmVyKCQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdEZpbGVJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpbml0IGJvb3RzdHJhcCBwb3BvdmVyXG4gICAgICAgICQoJy5jdXN0b20tZmlsZS1pbnB1dCcpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgICAkKHRoaXMpLm5leHQoJy5jdXN0b20tZmlsZS1sYWJlbCcpLmFkZENsYXNzKFwic2VsZWN0ZWRcIikuaHRtbChmaWxlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbml0UG9ydGxldCA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGluaXQgcG9ydGxldCB0b29sc1xuICAgICAgICB2YXIgZWwgPSAkKGVsKTtcbiAgICAgICAgdmFyIHBvcnRsZXQgPSBuZXcgS1RQb3J0bGV0KGVsWzBdLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdFBvcnRsZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGluaXQgcG9ydGxldCB0b29sc1xuICAgICAgICAkKCdbZGF0YS1rdHBvcnRsZXQ9XCJ0cnVlXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChlbC5kYXRhKCdkYXRhLWt0cG9ydGxldC1pbml0aWFsaXplZCcpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaW5pdFBvcnRsZXQoZWwsIHt9KTtcbiAgICAgICAgICAgICAgICBlbC5kYXRhKCdkYXRhLWt0cG9ydGxldC1pbml0aWFsaXplZCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdFNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCdbZGF0YS1zY3JvbGw9XCJ0cnVlXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICAgICAgICBLVFV0aWwuc2Nyb2xsSW5pdCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgbW9iaWxlTmF0aXZlU2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZW1lbWJlclBvc2l0aW9uOiAoZWwuZGF0YSgncmVtZW1iZXItcG9zaXRpb24nKSA9PSAndHJ1ZScgPyB0cnVlIDogZmFsc2UpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChLVFV0aWwuaXNJblJlc3BvbnNpdmVSYW5nZSgndGFibGV0LWFuZC1tb2JpbGUnKSAmJiBlbC5kYXRhKCdtb2JpbGUtaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5kYXRhKCdtb2JpbGUtaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZGF0YSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRBbGVydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW5pdCBib290c3RyYXAgcG9wb3ZlclxuICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJ1tkYXRhLWNsb3NlPWFsZXJ0XScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuYWxlcnQnKS5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbml0U3RpY2t5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGlja3kgPSBuZXcgU3RpY2t5KCdbZGF0YS1zdGlja3k9XCJ0cnVlXCJdJyk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRBYnNvbHV0ZURyb3Bkb3duID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICB2YXIgZHJvcGRvd25NZW51O1xuXG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnYm9keScpLm9uKCdzaG93LmJzLmRyb3Bkb3duJywgY29udGV4dCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBcdGRyb3Bkb3duTWVudSA9ICQoZS50YXJnZXQpLmZpbmQoJy5kcm9wZG93bi1tZW51Jyk7XG4gICAgICAgIFx0JCgnYm9keScpLmFwcGVuZChkcm9wZG93bk1lbnUuZGV0YWNoKCkpO1xuICAgICAgICBcdGRyb3Bkb3duTWVudS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgXHRkcm9wZG93bk1lbnUucG9zaXRpb24oe1xuICAgICAgICBcdFx0J215JzogJ3JpZ2h0IHRvcCcsXG4gICAgICAgIFx0XHQnYXQnOiAncmlnaHQgYm90dG9tJyxcbiAgICAgICAgXHRcdCdvZic6ICQoZS5yZWxhdGVkVGFyZ2V0KSxcbiAgICAgICAgXHR9KTtcbiAgICAgICAgfSkub24oJ2hpZGUuYnMuZHJvcGRvd24nLCBjb250ZXh0LCBmdW5jdGlvbihlKSB7XG4gICAgICAgIFx0JChlLnRhcmdldCkuYXBwZW5kKGRyb3Bkb3duTWVudS5kZXRhY2goKSk7XG4gICAgICAgIFx0ZHJvcGRvd25NZW51LmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRBYnNvbHV0ZURyb3Bkb3ducyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCdib2R5Jykub24oJ3Nob3cuYnMuZHJvcGRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoICQoZS50YXJnZXQpLmZpbmQoXCJbZGF0YS1hdHRhY2g9J2JvZHknXVwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkcm9wZG93bk1lbnUgPSAkKGUudGFyZ2V0KS5maW5kKCcuZHJvcGRvd24tbWVudScpO1xuXG4gICAgICAgICAgICAkKCdib2R5JykuYXBwZW5kKGRyb3Bkb3duTWVudS5kZXRhY2goKSk7XG4gICAgICAgICAgICBkcm9wZG93bk1lbnUuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgICAgICBkcm9wZG93bk1lbnUucG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICdteSc6ICdyaWdodCB0b3AnLFxuICAgICAgICAgICAgICAgICdhdCc6ICdyaWdodCBib3R0b20nLFxuICAgICAgICAgICAgICAgICdvZic6ICQoZS5yZWxhdGVkVGFyZ2V0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoJ2JvZHknKS5vbignaGlkZS5icy5kcm9wZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICggJChlLnRhcmdldCkuZmluZChcIltkYXRhLWF0dGFjaD0nYm9keSddXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRyb3Bkb3duTWVudSA9ICQoZS50YXJnZXQpLmZpbmQoJy5kcm9wZG93bi1tZW51Jyk7XG5cbiAgICAgICAgICAgICQoZS50YXJnZXQpLmFwcGVuZChkcm9wZG93bk1lbnUuZGV0YWNoKCkpO1xuICAgICAgICAgICAgZHJvcGRvd25NZW51LmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBvcHRpb25zLmNvbG9ycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS1RBcHAuaW5pdENvbXBvbmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0U2Nyb2xsKCk7XG4gICAgICAgICAgICBpbml0VG9vbHRpcHMoKTtcbiAgICAgICAgICAgIGluaXRQb3BvdmVycygpO1xuICAgICAgICAgICAgaW5pdEFsZXJ0cygpO1xuICAgICAgICAgICAgaW5pdFBvcnRsZXRzKCk7XG4gICAgICAgICAgICBpbml0RmlsZUlucHV0KCk7XG4gICAgICAgICAgICBpbml0U3RpY2t5KCk7XG4gICAgICAgICAgICBpbml0QWJzb2x1dGVEcm9wZG93bnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0VG9vbHRpcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5pdFRvb2x0aXBzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdFRvb2x0aXA6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBpbml0VG9vbHRpcChlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdFBvcG92ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRQb3BvdmVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRQb3BvdmVyOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgaW5pdFBvcG92ZXIoZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRQb3J0bGV0OiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaW5pdFBvcnRsZXQoZWwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRQb3J0bGV0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0UG9ydGxldHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0U3RpY2t5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRTdGlja3koKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0QWJzb2x1dGVEcm9wZG93bjogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgaW5pdEFic29sdXRlRHJvcGRvd24oY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmxvY2s6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuXG4gICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDUsXG4gICAgICAgICAgICAgICAgb3ZlcmxheUNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJycsXG4gICAgICAgICAgICAgICAgc2l6ZTogJycsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdicmFuZCcsXG4gICAgICAgICAgICAgICAgY2VudGVyWDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgICAgICAgICAgICAgIHNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogJ2F1dG8nXG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IG9wdGlvbnMudHlwZSA/ICdzcGlubmVyLS0nICsgb3B0aW9ucy50eXBlIDogJyc7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBvcHRpb25zLnN0YXRlID8gJ3NwaW5uZXItLScgKyBvcHRpb25zLnN0YXRlIDogJyc7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuc2l6ZSA/ICdzcGlubmVyLS0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICAgICAgICB2YXIgc3Bpbm5lciA9ICc8ZGl2IGNsYXNzPVwic3Bpbm5lciAnICsgdmVyc2lvbiArICcgJyArIHN0YXRlICsgJyAnICsgc2l6ZSArICdcIj48L2Rpdic7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgJiYgb3B0aW9ucy5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9ICdibG9ja3VpICcgKyAob3B0aW9ucy5zaGFkb3cgPT09IGZhbHNlID8gJ2Jsb2NrdWknIDogJycpO1xuXG4gICAgICAgICAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMgKyAnXCI+PHNwYW4+JyArIG9wdGlvbnMubWVzc2FnZSArICc8L3NwYW4+PHNwYW4+JyArIHNwaW5uZXIgKyAnPC9zcGFuPjwvZGl2Pic7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBLVFV0aWwuZ2V0KCdib2R5JykucHJlcGVuZChlbCk7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGVsLCBjbGFzc2VzKTtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnPHNwYW4+JyArIG9wdGlvbnMubWVzc2FnZSArICc8L3NwYW4+PHNwYW4+JyArIHNwaW5uZXIgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy53aWR0aCA9IEtUVXRpbC5hY3R1YWxXaWR0aChlbCkgKyAxMDtcbiAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlKGVsKTtcblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzICsgJ1wiIHN0eWxlPVwibWFyZ2luLWxlZnQ6LScgKyAob3B0aW9ucy53aWR0aCAvIDIpICsgJ3B4O1wiPjxzcGFuPicgKyBvcHRpb25zLm1lc3NhZ2UgKyAnPC9zcGFuPjxzcGFuPicgKyBzcGlubmVyICsgJzwvc3Bhbj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IHNwaW5uZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogaHRtbCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBvcHRpb25zLmNlbnRlclksXG4gICAgICAgICAgICAgICAgY2VudGVyWDogb3B0aW9ucy5jZW50ZXJYLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICczMCUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvdmVybGF5Q1NTOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5vdmVybGF5Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnd2FpdCcsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogJzEwJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25VbmJsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsICYmIGVsWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsWzBdLCAncG9zaXRpb24nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsWzBdLCAnem9vbScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNzcy50b3AgPSAnNTAlJztcbiAgICAgICAgICAgICAgICAkLmJsb2NrVUkocGFyYW1zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGVsLmJsb2NrKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5ibG9jazogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAkKHRhcmdldCkudW5ibG9jaygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkLnVuYmxvY2tVSSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrUGFnZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIEtUQXBwLmJsb2NrKCdib2R5Jywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5ibG9ja1BhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEtUQXBwLnVuYmxvY2soJ2JvZHknKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9ncmVzczogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2tpbiA9IChvcHRpb25zICYmIG9wdGlvbnMuc2tpbikgPyBvcHRpb25zLnNraW4gOiAnbGlnaHQnO1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudCA9IChvcHRpb25zICYmIG9wdGlvbnMuYWxpZ25tZW50KSA/IG9wdGlvbnMuYWxpZ25tZW50IDogJ3JpZ2h0JztcbiAgICAgICAgICAgIHZhciBzaXplID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplKSA/ICcgc3Bpbm5lci0tJyArIG9wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSAnc3Bpbm5lciAnICsgJ3NwaW5uZXItLScgKyBza2luICsgJyBzcGlubmVyLS0nICsgYWxpZ25tZW50ICsgc2l6ZTtcblxuICAgICAgICAgICAgS1RBcHAudW5wcm9ncmVzcyh0YXJnZXQpO1xuICAgICAgICAgICAgS1RVdGlsLmF0dHIodGFyZ2V0LCAnZGlzYWJsZWQnLCB0cnVlKTtcblxuICAgICAgICAgICAgJCh0YXJnZXQpLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgICAgICAgICAgJCh0YXJnZXQpLmRhdGEoJ3Byb2dyZXNzLWNsYXNzZXMnLCBjbGFzc2VzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnByb2dyZXNzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICQodGFyZ2V0KS5yZW1vdmVDbGFzcygkKHRhcmdldCkuZGF0YSgncHJvZ3Jlc3MtY2xhc3NlcycpKTtcbiAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVBdHRyKHRhcmdldCwgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U3RhdGVDb2xvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yc1tcInN0YXRlXCJdW25hbWVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJhc2VDb2xvcjogZnVuY3Rpb24odHlwZSwgbGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNbXCJiYXNlXCJdW3R5cGVdW2xldmVsIC0gMV07XG4gICAgICAgIH1cbiAgICB9O1xufSgpO1xuXG4vLyB3ZWJwYWNrIHN1cHBvcnRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVEFwcDtcbn1cblxuY29uc3QgS1RBcHBPcHRpb25zID0ge1xuICBcImNvbG9yc1wiOiB7XG4gICAgXCJzdGF0ZVwiOiB7XG4gICAgICBcImJyYW5kXCI6IFwiIzAwN2NjM1wiLFxuICAgICAgXCJtZXRhbFwiOiBcIiNjNGM1ZDZcIixcbiAgICAgIFwibGlnaHRcIjogXCIjZmZmZmZmXCIsXG4gICAgICBcImFjY2VudFwiOiBcIiMwMGM1ZGNcIixcbiAgICAgIFwicHJpbWFyeVwiOiBcIiMwMDdjYzNcIixcbiAgICAgIFwic3VjY2Vzc1wiOiBcIiMzNGJmYTNcIixcbiAgICAgIFwiaW5mb1wiOiBcIiMzNmEzZjdcIixcbiAgICAgIFwid2FybmluZ1wiOiBcIiNmZmI4MjJcIixcbiAgICAgIFwiZGFuZ2VyXCI6IFwiI2ZkMzk5NVwiLFxuICAgICAgXCJmb2N1c1wiOiBcIiMxZDQ2NzBcIlxuICAgIH0sXG4gICAgXCJiYXNlXCI6IHtcbiAgICAgIFwibGFiZWxcIjogW1xuICAgICAgICBcIiNjNWNiZTNcIixcbiAgICAgICAgXCIjYTFhOGMzXCIsXG4gICAgICAgIFwiIzNkNDQ2NVwiLFxuICAgICAgICBcIiMzZTQ0NjZcIlxuICAgICAgXSxcbiAgICAgIFwic2hhcGVcIjogW1xuICAgICAgICBcIiNmMGYzZmZcIixcbiAgICAgICAgXCIjZDlkZmZhXCIsXG4gICAgICAgIFwiI2FmYjRkNFwiLFxuICAgICAgICBcIiM2NDZjOWFcIlxuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuLy8gSW5pdGlhbGl6ZSBLVEFwcCBjbGFzcyBvbiBkb2N1bWVudCByZWFkeVxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgS1RBcHAuaW5pdChLVEFwcE9wdGlvbnMpO1xufSk7XG4iLCIvLyBwbHVnaW4gc2V0dXBcbnZhciBLVEF2YXRhciA9IGZ1bmN0aW9uKGVsZW1lbnRJZCwgb3B0aW9ucykge1xuICAgIC8vIE1haW4gb2JqZWN0XG4gICAgdmFyIHRoZSA9IHRoaXM7XG4gICAgdmFyIGluaXQgPSBmYWxzZTtcblxuICAgIC8vIEdldCBlbGVtZW50IG9iamVjdFxuICAgIHZhciBlbGVtZW50ID0gS1RVdGlsLmdldChlbGVtZW50SWQpO1xuICAgIHZhciBib2R5ID0gS1RVdGlsLmdldCgnYm9keScpO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyAqKiBQcml2YXRlIE1ldGhvZHMgICoqIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIFBsdWdpbiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdFxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChLVFV0aWwuZGF0YShlbGVtZW50KS5oYXMoJ2F2YXRhcicpKSB7XG4gICAgICAgICAgICAgICAgdGhlID0gS1RVdGlsLmRhdGEoZWxlbWVudCkuZ2V0KCdhdmF0YXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgbWVudVxuICAgICAgICAgICAgICAgIFBsdWdpbi5pbml0KG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgbWVudVxuICAgICAgICAgICAgICAgIFBsdWdpbi5idWlsZCgpO1xuXG4gICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEoZWxlbWVudCkuc2V0KCdhdmF0YXInLCB0aGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0IGF2YXRhclxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdGhlLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhlLmV2ZW50cyA9IFtdO1xuXG4gICAgICAgICAgICB0aGUuaW5wdXQgPSBLVFV0aWwuZmluZChlbGVtZW50LCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nKTtcbiAgICAgICAgICAgIHRoZS5ob2xkZXIgPSBLVFV0aWwuZmluZChlbGVtZW50LCAnLmF2YXRhcl9faG9sZGVyJyk7XG4gICAgICAgICAgICB0aGUuY2FuY2VsID0gS1RVdGlsLmZpbmQoZWxlbWVudCwgJy5hdmF0YXJfX2NhbmNlbCcpO1xuICAgICAgICAgICAgdGhlLnNyYyA9IEtUVXRpbC5jc3ModGhlLmhvbGRlciwgJ2JhY2tncm91bmRJbWFnZScpO1xuXG4gICAgICAgICAgICAvLyBtZXJnZSBkZWZhdWx0IGFuZCB1c2VyIGRlZmluZWQgb3B0aW9uc1xuICAgICAgICAgICAgdGhlLm9wdGlvbnMgPSBLVFV0aWwuZGVlcEV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBGb3JtIFdpemFyZFxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGF2YXRhciBjaGFuZ2VcbiAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudCh0aGUuaW5wdXQsICdjaGFuZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGUuaW5wdXQgJiYgdGhlLmlucHV0LmZpbGVzICYmIHRoZS5pbnB1dC5maWxlc1swXSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmhvbGRlciwgJ2JhY2tncm91bmQtaW1hZ2UnLCAndXJsKCcrZS50YXJnZXQucmVzdWx0ICsnKScpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwodGhlLmlucHV0LmZpbGVzWzBdKTtcblxuXHQgICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKHRoZS5lbGVtZW50LCAnYXZhdGFyLS1jaGFuZ2VkJyk7XG5cdCAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgYXZhdGFyIGNhbmNlbFxuICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KHRoZS5jYW5jZWwsICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0ICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKHRoZS5lbGVtZW50LCAnYXZhdGFyLS1jaGFuZ2VkJyk7XG5cdCAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmhvbGRlciwgJ2JhY2tncm91bmQtaW1hZ2UnLCB0aGUuc3JjKTtcblx0ICAgICAgICAgICAgdGhlLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAvL0tUVXRpbC50cmlnZ2VyQ3VzdG9tRXZlbnQobmFtZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoZS5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGUuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9uZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZmlyZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUuZXZlbnRzW2ldLmZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlci5jYWxsKHRoaXMsIHRoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlci5jYWxsKHRoaXMsIHRoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRXZlbnQ6IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIsIG9uZSkge1xuICAgICAgICAgICAgdGhlLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiBvbmUsXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vICoqIFB1YmxpYyBNZXRob2RzICoqIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cblxuICAgIHRoZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnRcbiAgICAgKi9cbiAgICB0aGUub24gPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uYWRkRXZlbnQobmFtZSwgaGFuZGxlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudCB0aGF0IHdpbGwgYmUgZmlyZWQgb25jZVxuICAgICAqL1xuICAgIHRoZS5vbmUgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uYWRkRXZlbnQobmFtZSwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIENvbnN0cnVjdCBwbHVnaW5cbiAgICBQbHVnaW4uY29uc3RydWN0LmFwcGx5KHRoZSwgW29wdGlvbnNdKTtcblxuICAgIHJldHVybiB0aGU7XG59O1xuXG4vLyB3ZWJwYWNrIHN1cHBvcnRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVEF2YXRhcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBwbHVnaW4gc2V0dXBcbnZhciBLVERpYWxvZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBNYWluIG9iamVjdFxuICAgIHZhciB0aGUgPSB0aGlzO1xuXG4gICAgLy8gR2V0IGVsZW1lbnQgb2JqZWN0XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBLVFV0aWwuZ2V0KCdib2R5Jyk7XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICdwbGFjZW1lbnQnIDogJ3RvcCBjZW50ZXInLFxuICAgICAgICAndHlwZScgIDogJ2xvYWRlcicsXG4gICAgICAgICd3aWR0aCcgOiAxMDAsXG4gICAgICAgICdzdGF0ZScgOiAnZGVmYXVsdCcsXG4gICAgICAgICdtZXNzYWdlJyA6ICdMb2FkaW5nLi4uJ1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gKiogUHJpdmF0ZSBNZXRob2RzICAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBQbHVnaW4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RcbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3RydWN0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBQbHVnaW4uaW5pdChvcHRpb25zKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBzdWJ0b2dnbGUgY2xpY2sgdG9nZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGUuZXZlbnRzID0gW107XG5cbiAgICAgICAgICAgIC8vIG1lcmdlIGRlZmF1bHQgYW5kIHVzZXIgZGVmaW5lZCBvcHRpb25zXG4gICAgICAgICAgICB0aGUub3B0aW9ucyA9IEtUVXRpbC5kZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoZS5zdGF0ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IGRpYWxvZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdzaG93Jyk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICAgICAgS1RVdGlsLnNldEhUTUwoZWxlbWVudCwgdGhlLm9wdGlvbnMubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhlbGVtZW50LCAnZGlhbG9nIGRpYWxvZy0tc2hvd24nKTtcbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhlbGVtZW50LCAnZGlhbG9nLS0nICsgdGhlLm9wdGlvbnMuc3RhdGUpO1xuICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGVsZW1lbnQsICdkaWFsb2ctLScgKyB0aGUub3B0aW9ucy50eXBlKTtcblxuICAgICAgICAgICAgaWYgKHRoZS5vcHRpb25zLnBsYWNlbWVudCA9PT0gJ3RvcCBjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGVsZW1lbnQsICdkaWFsb2ctLXRvcC1jZW50ZXInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgICAgICAgICAgdGhlLnN0YXRlID0gJ3Nob3duJztcblxuICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignc2hvd24nKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSBkaWFsb2dcbiAgICAgICAgICovXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdoaWRlJyk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoZS5zdGF0ZSA9ICdoaWRkZW4nO1xuXG4gICAgICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IHRoZS5ldmVudHNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5vbmUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmZpcmVkID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlLmV2ZW50c1tpXS5maXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZXIuY2FsbCh0aGlzLCB0aGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZXIuY2FsbCh0aGlzLCB0aGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyLCBvbmUpIHtcbiAgICAgICAgICAgIHRoZS5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogb25lLFxuICAgICAgICAgICAgICAgIGZpcmVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyAqKiBQdWJsaWMgTWV0aG9kcyAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICovXG5cbiAgICB0aGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgc2hvd24gc3RhdGVcbiAgICAgKi9cbiAgICB0aGUuc2hvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoZS5zdGF0ZSA9PSAnc2hvd24nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBoaWRkZW4gc3RhdGVcbiAgICAgKi9cbiAgICB0aGUuaGlkZGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGUuc3RhdGUgPT0gJ2hpZGRlbic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgZGlhbG9nXG4gICAgICovXG4gICAgdGhlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5zaG93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgZGlhbG9nXG4gICAgICovXG4gICAgdGhlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5oaWRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudFxuICAgICAqIEByZXR1cm5zIHtLVFRvZ2dsZX1cbiAgICAgKi9cbiAgICB0aGUub24gPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uYWRkRXZlbnQobmFtZSwgaGFuZGxlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudCB0aGF0IHdpbGwgYmUgZmlyZWQgb25jZVxuICAgICAqIEByZXR1cm5zIHtLVFRvZ2dsZX1cbiAgICAgKi9cbiAgICB0aGUub25lID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmFkZEV2ZW50KG5hbWUsIGhhbmRsZXIsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBDb25zdHJ1Y3QgcGx1Z2luXG4gICAgUGx1Z2luLmNvbnN0cnVjdC5hcHBseSh0aGUsIFtvcHRpb25zXSk7XG5cbiAgICByZXR1cm4gdGhlO1xufTtcblxuLy8gd2VicGFjayBzdXBwb3J0XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gS1REaWFsb2c7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIEtUSGVhZGVyID0gZnVuY3Rpb24oZWxlbWVudElkLCBvcHRpb25zKSB7XHJcbiAgICAvLyBNYWluIG9iamVjdFxyXG4gICAgdmFyIHRoZSA9IHRoaXM7XHJcbiAgICB2YXIgaW5pdCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEdldCBlbGVtZW50IG9iamVjdFxyXG4gICAgdmFyIGVsZW1lbnQgPSBLVFV0aWwuZ2V0KGVsZW1lbnRJZCk7XHJcbiAgICB2YXIgYm9keSA9IEtUVXRpbC5nZXQoJ2JvZHknKTtcclxuXHJcbiAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgb3B0aW9uc1xyXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgIGNsYXNzaWM6IGZhbHNlLFxyXG4gICAgICAgIG9mZnNldDoge1xyXG4gICAgICAgICAgICBtb2JpbGU6IDE1MCxcclxuICAgICAgICAgICAgZGVza3RvcDogMjAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaW5pbWl6ZToge1xyXG4gICAgICAgICAgICBtb2JpbGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZXNrdG9wOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gKiogUHJpdmF0ZSBNZXRob2RzICAqKiAvL1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIHZhciBQbHVnaW4gPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUnVuIHBsdWdpblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLVEhlYWRlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKEtUVXRpbC5kYXRhKGVsZW1lbnQpLmhhcygnaGVhZGVyJykpIHtcclxuICAgICAgICAgICAgICAgIHRoZSA9IEtUVXRpbC5kYXRhKGVsZW1lbnQpLmdldCgnaGVhZGVyJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBoZWFkZXJcclxuICAgICAgICAgICAgICAgIFBsdWdpbi5pbml0KG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgUGx1Z2luLmJ1aWxkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEoZWxlbWVudCkuc2V0KCdoZWFkZXInLCB0aGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgc3ViaGVhZGVyIGNsaWNrIHRvZ2dsZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLVEhlYWRlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoZS5ldmVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1lcmdlIGRlZmF1bHQgYW5kIHVzZXIgZGVmaW5lZCBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoZS5vcHRpb25zID0gS1RVdGlsLmRlZXBFeHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldCBoZWFkZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7S1RIZWFkZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFNjcm9sbFRvcCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBldmVudFRyaWdnZXJTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydEhlaWdodCA9IEtUVXRpbC5nZXRWaWV3UG9ydCgpLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGRvY3VtZW50SGVpZ2h0ID0gS1RVdGlsLmdldERvY3VtZW50SGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhlLm9wdGlvbnMubWluaW1pemUubW9iaWxlID09PSBmYWxzZSAmJiB0aGUub3B0aW9ucy5taW5pbWl6ZS5kZXNrdG9wID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMCwgb24sIG9mZiwgc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCdkZXNrdG9wJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGUub3B0aW9ucy5vZmZzZXQuZGVza3RvcDtcclxuICAgICAgICAgICAgICAgICAgICBvbiA9IHRoZS5vcHRpb25zLm1pbmltaXplLmRlc2t0b3Aub247XHJcbiAgICAgICAgICAgICAgICAgICAgb2ZmID0gdGhlLm9wdGlvbnMubWluaW1pemUuZGVza3RvcC5vZmY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCd0YWJsZXQtYW5kLW1vYmlsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhlLm9wdGlvbnMub2Zmc2V0Lm1vYmlsZTtcclxuICAgICAgICAgICAgICAgICAgICBvbiA9IHRoZS5vcHRpb25zLm1pbmltaXplLm1vYmlsZS5vbjtcclxuICAgICAgICAgICAgICAgICAgICBvZmYgPSB0aGUub3B0aW9ucy5taW5pbWl6ZS5tb2JpbGUub2ZmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN0ID0gS1RVdGlsLmdldFNjcm9sbFRvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAoS1RVdGlsLmlzSW5SZXNwb25zaXZlUmFuZ2UoJ3RhYmxldC1hbmQtbW9iaWxlJykgJiYgdGhlLm9wdGlvbnMuY2xhc3NpYyAmJiB0aGUub3B0aW9ucy5jbGFzc2ljLm1vYmlsZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoS1RVdGlsLmlzSW5SZXNwb25zaXZlUmFuZ2UoJ2Rlc2t0b3AnKSAmJiB0aGUub3B0aW9ucy5jbGFzc2ljICYmIHRoZS5vcHRpb25zLmNsYXNzaWMuZGVza3RvcClcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdCA+IG9mZnNldCkgeyAvLyBkb3duIHNjcm9sbCBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhib2R5LCBvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhib2R5LCBvZmYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50VHJpZ2dlclN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdtaW5pbWl6ZU9uJywgdGhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHJpZ2dlclN0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBiYWNrIHNjcm9sbCBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhib2R5LCBvZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3MoYm9keSwgb24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50VHJpZ2dlclN0YXRlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdtaW5pbWl6ZU9mZicsIHRoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFRyaWdnZXJTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdCA+IG9mZnNldCAmJiBsYXN0U2Nyb2xsVG9wIDwgc3QpIHsgLy8gZG93biBzY3JvbGwgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3MoYm9keSwgb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3MoYm9keSwgb2ZmKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudFRyaWdnZXJTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignbWluaW1pemVPbicsIHRoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFRyaWdnZXJTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gYmFjayBzY3JvbGwgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3MoYm9keSwgb2ZmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGJvZHksIG9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudFRyaWdnZXJTdGF0ZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignbWluaW1pemVPZmYnLCB0aGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUcmlnZ2VyU3RhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsYXN0U2Nyb2xsVG9wID0gc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhlLmV2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5uYW1lID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQub25lID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmZpcmVkID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUuZXZlbnRzW2ldLmZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVyLmNhbGwodGhpcywgdGhlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVyLmNhbGwodGhpcywgdGhlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGRFdmVudDogZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgb25lKSB7XHJcbiAgICAgICAgICAgIHRoZS5ldmVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcclxuICAgICAgICAgICAgICAgIG9uZTogb25lLFxyXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vICoqIFB1YmxpYyBNZXRob2RzICoqIC8vXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgICovXHJcblxyXG4gICAgdGhlLnNldERlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGUub24gPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5hZGRFdmVudChuYW1lLCBoYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gKiogUGx1Z2luIENvbnN0cnVjdGlvbiAqKiAvL1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIC8vIFJ1biBwbHVnaW5cclxuICAgIFBsdWdpbi5jb25zdHJ1Y3QuYXBwbHkodGhlLCBbb3B0aW9uc10pO1xyXG5cclxuICAgIC8vIEluaXQgZG9uZVxyXG4gICAgaW5pdCA9IHRydWU7XHJcblxyXG4gICAgLy8gUmV0dXJuIHBsdWdpbiBpbnN0YW5jZVxyXG4gICAgcmV0dXJuIHRoZTtcclxufTtcclxuXHJcbi8vIHdlYnBhY2sgc3VwcG9ydFxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVEhlYWRlcjtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBLVE1lbnUgPSBmdW5jdGlvbihlbGVtZW50SWQsIG9wdGlvbnMpIHtcbiAgICAvLyBNYWluIG9iamVjdFxuICAgIHZhciB0aGUgPSB0aGlzO1xuICAgIHZhciBpbml0ID0gZmFsc2U7XG5cbiAgICAvLyBHZXQgZWxlbWVudCBvYmplY3RcbiAgICB2YXIgZWxlbWVudCA9IEtUVXRpbC5nZXQoZWxlbWVudElkKTtcbiAgICB2YXIgYm9keSA9IEtUVXRpbC5nZXQoJ2JvZHknKTtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAvLyBzY3JvbGxhYmxlIGFyZWEgd2l0aCBQZXJmZWN0IFNjcm9sbFxuICAgICAgICBzY3JvbGw6IHtcbiAgICAgICAgICAgIHJlbWVtYmVyUG9zaXRpb246IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWNjb3JkaW9uIHN1Ym1lbnUgbW9kZVxuICAgICAgICBhY2NvcmRpb246IHtcbiAgICAgICAgICAgIHNsaWRlU3BlZWQ6IDIwMCwgLy8gYWNjb3JkaW9uIHRvZ2dsZSBzbGlkZSBzcGVlZCBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGF1dG9TY3JvbGw6IGZhbHNlLCAvLyBlbmFibGUgYXV0byBzY3JvbGxpbmcoZm9jdXMpIHRvIHRoZSBjbGlja2VkIG1lbnUgaXRlbVxuICAgICAgICAgICAgYXV0b1Njcm9sbFNwZWVkOiAxMjAwLFxuICAgICAgICAgICAgZXhwYW5kQWxsOiB0cnVlIC8vIGFsbG93IGhhdmluZyBtdWx0aXBsZSBleHBhbmRlZCBhY2NvcmRpb25zIGluIHRoZSBtZW51XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZHJvcGRvd24gc3VibWVudSBtb2RlXG4gICAgICAgIGRyb3Bkb3duOiB7XG4gICAgICAgICAgICB0aW1lb3V0OiA1MDAgLy8gdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gc2hvdyBhbmQgaGlkZSB0aGUgaG92ZXJhYmxlIHN1Ym1lbnUgZHJvcGRvd25cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gKiogUHJpdmF0ZSBNZXRob2RzICAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBQbHVnaW4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW4gcGx1Z2luXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChLVFV0aWwuZGF0YShlbGVtZW50KS5oYXMoJ21lbnUnKSkge1xuICAgICAgICAgICAgICAgIHRoZSA9IEtUVXRpbC5kYXRhKGVsZW1lbnQpLmdldCgnbWVudScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBtZW51XG4gICAgICAgICAgICAgICAgUGx1Z2luLmluaXQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCBtZW51XG4gICAgICAgICAgICAgICAgUGx1Z2luLnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBidWlsZCBtZW51XG4gICAgICAgICAgICAgICAgUGx1Z2luLmJ1aWxkKCk7XG5cbiAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShlbGVtZW50KS5zZXQoJ21lbnUnLCB0aGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHN1Ym1lbnUgY2xpY2sgdG9nZ2xlXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGUuZXZlbnRzID0gW107XG5cbiAgICAgICAgICAgIHRoZS5ldmVudEhhbmRsZXJzID0ge307XG5cbiAgICAgICAgICAgIC8vIG1lcmdlIGRlZmF1bHQgYW5kIHVzZXIgZGVmaW5lZCBvcHRpb25zXG4gICAgICAgICAgICB0aGUub3B0aW9ucyA9IEtUVXRpbC5kZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIHBhdXNlIG1lbnVcbiAgICAgICAgICAgIHRoZS5wYXVzZURyb3Bkb3duSG92ZXJUaW1lID0gMDtcblxuICAgICAgICAgICAgdGhlLnVpZCA9IEtUVXRpbC5nZXRVbmlxdWVJRCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gbWVyZ2UgZGVmYXVsdCBhbmQgdXNlciBkZWZpbmVkIG9wdGlvbnNcbiAgICAgICAgICAgIHRoZS5vcHRpb25zID0gS1RVdGlsLmRlZXBFeHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gcGF1c2UgbWVudVxuICAgICAgICAgICAgdGhlLnBhdXNlRHJvcGRvd25Ib3ZlclRpbWUgPSAwO1xuXG4gICAgICAgICAgICAgLy8gcmVzZXQgbWVudVxuICAgICAgICAgICAgUGx1Z2luLnJlc2V0KCk7XG5cbiAgICAgICAgICAgIHRoZS5ldmVudEhhbmRsZXJzID0ge307XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIG1lbnVcbiAgICAgICAgICAgIFBsdWdpbi5idWlsZCgpO1xuXG4gICAgICAgICAgICBLVFV0aWwuZGF0YShlbGVtZW50KS5zZXQoJ21lbnUnLCB0aGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgLy8gcmVzZXQgbWVudVxuICAgICAgICAgICAgUGx1Z2luLnJlc2V0KCk7XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIG1lbnVcbiAgICAgICAgICAgIFBsdWdpbi5idWlsZCgpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBzdWJtZW51IHByb3BzXG4gICAgICAgICAgICBQbHVnaW4ucmVzZXRTdWJtZW51UHJvcHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgbWVudVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBhY2NvcmRpb24gc3VibWVudSB0b2dnbGVcbiAgICAgICAgICAgIHRoZS5ldmVudEhhbmRsZXJzWydldmVudF8xJ10gPSBLVFV0aWwub24oIGVsZW1lbnQsICcubWVudV9fdG9nZ2xlJywgJ2NsaWNrJywgUGx1Z2luLmhhbmRsZVN1Ym1lbnVBY2NvcmRpb24pO1xuXG4gICAgICAgICAgICAvLyBEcm9wZG93biBtb2RlKGhvdmVyYWJsZSlcbiAgICAgICAgICAgIGlmIChQbHVnaW4uZ2V0U3VibWVudU1vZGUoKSA9PT0gJ2Ryb3Bkb3duJyB8fCBQbHVnaW4uaXNDb25kaXRpb25hbFN1Ym1lbnVEcm9wZG93bigpKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJvcGRvd24gc3VibWVudSAtIGhvdmVyIHRvZ2dsZVxuICAgICAgICAgICAgICAgIHRoZS5ldmVudEhhbmRsZXJzWydldmVudF8yJ10gPSBLVFV0aWwub24oIGVsZW1lbnQsICdbZGF0YS1rdG1lbnUtc3VibWVudS10b2dnbGU9XCJob3ZlclwiXScsICdtb3VzZW92ZXInLCBQbHVnaW4uaGFuZGxlU3VibWVudURyb2Rvd25Ib3ZlckVudGVyKTtcbiAgICAgICAgICAgICAgICB0aGUuZXZlbnRIYW5kbGVyc1snZXZlbnRfMyddID0gS1RVdGlsLm9uKCBlbGVtZW50LCAnW2RhdGEta3RtZW51LXN1Ym1lbnUtdG9nZ2xlPVwiaG92ZXJcIl0nLCAnbW91c2VvdXQnLCBQbHVnaW4uaGFuZGxlU3VibWVudURyb2Rvd25Ib3ZlckV4aXQpO1xuXG4gICAgICAgICAgICAgICAgLy8gZHJvcGRvd24gc3VibWVudSAtIGNsaWNrIHRvZ2dsZVxuICAgICAgICAgICAgICAgIHRoZS5ldmVudEhhbmRsZXJzWydldmVudF80J10gPSBLVFV0aWwub24oIGVsZW1lbnQsICdbZGF0YS1rdG1lbnUtc3VibWVudS10b2dnbGU9XCJjbGlja1wiXSA+IC5tZW51X190b2dnbGUsIFtkYXRhLWt0bWVudS1zdWJtZW51LXRvZ2dsZT1cImNsaWNrXCJdID4gLm1lbnVfX2xpbmsgLm1lbnVfX3RvZ2dsZScsICdjbGljaycsIFBsdWdpbi5oYW5kbGVTdWJtZW51RHJvcGRvd25DbGljayk7XG4gICAgICAgICAgICAgICAgdGhlLmV2ZW50SGFuZGxlcnNbJ2V2ZW50XzUnXSA9IEtUVXRpbC5vbiggZWxlbWVudCwgJ1tkYXRhLWt0bWVudS1zdWJtZW51LXRvZ2dsZT1cInRhYlwiXSA+IC5tZW51X190b2dnbGUsIFtkYXRhLWt0bWVudS1zdWJtZW51LXRvZ2dsZT1cInRhYlwiXSA+IC5tZW51X19saW5rIC5tZW51X190b2dnbGUnLCAnY2xpY2snLCBQbHVnaW4uaGFuZGxlU3VibWVudURyb3Bkb3duVGFiQ2xpY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbGluayBjbGlja1xuICAgICAgICAgICAgdGhlLmV2ZW50SGFuZGxlcnNbJ2V2ZW50XzYnXSA9IEtUVXRpbC5vbihlbGVtZW50LCAnLm1lbnVfX2l0ZW0gPiAubWVudV9fbGluazpub3QoLm1lbnVfX3RvZ2dsZSk6bm90KC5tZW51X19saW5rLS10b2dnbGUtc2tpcCknLCAnY2xpY2snLCBQbHVnaW4uaGFuZGxlTGlua0NsaWNrKTtcblxuICAgICAgICAgICAgLy8gSW5pdCBzY3JvbGxhYmxlIG1lbnVcbiAgICAgICAgICAgIGlmICh0aGUub3B0aW9ucy5zY3JvbGwgJiYgdGhlLm9wdGlvbnMuc2Nyb2xsLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIFBsdWdpbi5zY3JvbGxJbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IG1lbnVcbiAgICAgICAgICogQHJldHVybnMge0tUTWVudX1cbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtUVXRpbC5vZmYoIGVsZW1lbnQsICdjbGljaycsIHRoZS5ldmVudEhhbmRsZXJzWydldmVudF8xJ10pO1xuXG4gICAgICAgICAgICAvLyBkcm9wZG93biBzdWJtZW51IC0gaG92ZXIgdG9nZ2xlXG4gICAgICAgICAgICBLVFV0aWwub2ZmKCBlbGVtZW50LCAnbW91c2VvdmVyJywgdGhlLmV2ZW50SGFuZGxlcnNbJ2V2ZW50XzInXSk7XG4gICAgICAgICAgICBLVFV0aWwub2ZmKCBlbGVtZW50LCAnbW91c2VvdXQnLCB0aGUuZXZlbnRIYW5kbGVyc1snZXZlbnRfMyddKTtcblxuICAgICAgICAgICAgLy8gZHJvcGRvd24gc3VibWVudSAtIGNsaWNrIHRvZ2dsZVxuICAgICAgICAgICAgS1RVdGlsLm9mZiggZWxlbWVudCwgJ2NsaWNrJywgdGhlLmV2ZW50SGFuZGxlcnNbJ2V2ZW50XzQnXSk7XG4gICAgICAgICAgICBLVFV0aWwub2ZmKCBlbGVtZW50LCAnY2xpY2snLCB0aGUuZXZlbnRIYW5kbGVyc1snZXZlbnRfNSddKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGxpbmsgY2xpY2tcbiAgICAgICAgICAgIEtUVXRpbC5vZmYoZWxlbWVudCwgJ2NsaWNrJywgdGhlLmV2ZW50SGFuZGxlcnNbJ2V2ZW50XzYnXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgc2Nyb2xsIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsSW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIHRoZS5vcHRpb25zLnNjcm9sbCAmJiB0aGUub3B0aW9ucy5zY3JvbGwuaGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5zY3JvbGxEZXN0cm95KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIEtUVXRpbC5zY3JvbGxJbml0KGVsZW1lbnQsIHttb2JpbGVOYXRpdmVTY3JvbGw6IHRydWUsIHdpbmRvd1Njcm9sbDogZmFsc2UsIHJlc2V0SGVpZ2h0T25EZXN0cm95OiB0cnVlLCBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsIGhlaWdodDogdGhlLm9wdGlvbnMuc2Nyb2xsLmhlaWdodCwgcmVtZW1iZXJQb3NpdGlvbjogdGhlLm9wdGlvbnMuc2Nyb2xsLnJlbWVtYmVyUG9zaXRpb259KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLnNjcm9sbERlc3Ryb3koZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBzY3JvbGwgbWVudVxuICAgICAgICAqL1xuICAgICAgICBzY3JvbGxVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCB0aGUub3B0aW9ucy5zY3JvbGwgJiYgdGhlLm9wdGlvbnMuc2Nyb2xsLmhlaWdodCApIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuc2Nyb2xsVXBkYXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgdG9wXG4gICAgICAgICovXG4gICAgICAgIHNjcm9sbFRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIHRoZS5vcHRpb25zLnNjcm9sbCAmJiB0aGUub3B0aW9ucy5zY3JvbGwuaGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5zY3JvbGxUb3AoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzdWJtZW51IG1vZGUgZm9yIGN1cnJlbnQgYnJlYWtwb2ludCBhbmQgbWVudSBzdGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3VibWVudU1vZGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBpZiAoIEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCdkZXNrdG9wJykgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIEtUVXRpbC5oYXNBdHRyKGVsLCAnZGF0YS1rdG1lbnUtc3VibWVudS10b2dnbGUnKSAmJiBLVFV0aWwuYXR0cihlbCwgJ2RhdGEta3RtZW51LXN1Ym1lbnUtdG9nZ2xlJykgPT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Ryb3Bkb3duJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIEtUVXRpbC5pc3NldCh0aGUub3B0aW9ucy5zdWJtZW51LCAnZGVza3RvcC5zdGF0ZS5ib2R5JykgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggS1RVdGlsLmhhc0NsYXNzZXMoYm9keSwgdGhlLm9wdGlvbnMuc3VibWVudS5kZXNrdG9wLnN0YXRlLmJvZHkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZS5vcHRpb25zLnN1Ym1lbnUuZGVza3RvcC5zdGF0ZS5tb2RlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZS5vcHRpb25zLnN1Ym1lbnUuZGVza3RvcC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggS1RVdGlsLmlzc2V0KHRoZS5vcHRpb25zLnN1Ym1lbnUsICdkZXNrdG9wJykgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGUub3B0aW9ucy5zdWJtZW51LmRlc2t0b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggS1RVdGlsLmlzSW5SZXNwb25zaXZlUmFuZ2UoJ3RhYmxldCcpICYmIEtUVXRpbC5pc3NldCh0aGUub3B0aW9ucy5zdWJtZW51LCAndGFibGV0JykgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZS5vcHRpb25zLnN1Ym1lbnUudGFibGV0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggS1RVdGlsLmlzSW5SZXNwb25zaXZlUmFuZ2UoJ21vYmlsZScpICYmIEtUVXRpbC5pc3NldCh0aGUub3B0aW9ucy5zdWJtZW51LCAnbW9iaWxlJykgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZS5vcHRpb25zLnN1Ym1lbnUubW9iaWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzdWJtZW51IG1vZGUgZm9yIGN1cnJlbnQgYnJlYWtwb2ludCBhbmQgbWVudSBzdGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb25kaXRpb25hbFN1Ym1lbnVEcm9wZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCdkZXNrdG9wJykgJiYgS1RVdGlsLmlzc2V0KHRoZS5vcHRpb25zLnN1Ym1lbnUsICdkZXNrdG9wLnN0YXRlLmJvZHknKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHN1Ym1lbnUgYXR0cmlidXRlc1xuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXRTdWJtZW51UHJvcHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzdWJtZW51cyA9IEtUVXRpbC5maW5kQWxsKGVsZW1lbnQsICcubWVudV9fc3VibWVudScpO1xuICAgICAgICAgICAgaWYgKCBzdWJtZW51cyApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3VibWVudXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmNzcyhzdWJtZW51c1swXSwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5jc3Moc3VibWVudXNbMF0sICdvdmVyZmxvdycsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgc3VibWVudSBob3ZlciB0b2dnbGVcbiAgICAgICAgICogQHJldHVybnMge0tUTWVudX1cbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVN1Ym1lbnVEcm9kb3duSG92ZXJFbnRlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCBQbHVnaW4uZ2V0U3VibWVudU1vZGUodGhpcykgPT09ICdhY2NvcmRpb24nICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aGUucmVzdW1lRHJvcGRvd25Ib3ZlcigpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1ob3ZlcicpID09ICcxJyApIHtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1ob3ZlcicpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZW91dCcpICk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGltZW91dCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBQbHVnaW4uc2hvd1N1Ym1lbnVEcm9wZG93bihpdGVtKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBzdWJtZW51IGhvdmVyIHRvZ2dsZVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlU3VibWVudURyb2Rvd25Ib3ZlckV4aXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICggdGhlLnJlc3VtZURyb3Bkb3duSG92ZXIoKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIFBsdWdpbi5nZXRTdWJtZW51TW9kZSh0aGlzKSA9PT0gJ2FjY29yZGlvbicgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHRoZS5vcHRpb25zLmRyb3Bkb3duLnRpbWVvdXQ7XG5cbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWhvdmVyJykgPT0gJzEnICkge1xuICAgICAgICAgICAgICAgICAgICBQbHVnaW4uaGlkZVN1Ym1lbnVEcm9wZG93bihpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lKTtcblxuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaG92ZXInLCAnMScpO1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZW91dCcsIHRpbWVvdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHN1Ym1lbnUgY2xpY2sgdG9nZ2xlXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVTdWJtZW51RHJvcGRvd25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCBQbHVnaW4uZ2V0U3VibWVudU1vZGUodGhpcykgPT09ICdhY2NvcmRpb24nICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmNsb3Nlc3QoJy5tZW51X19pdGVtJyk7XG5cbiAgICAgICAgICAgIGlmICggaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEta3RtZW51LXN1Ym1lbnUtbW9kZScpID09ICdhY2NvcmRpb24nICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBLVFV0aWwuaGFzQ2xhc3MoaXRlbSwgJ21lbnVfX2l0ZW0tLWhvdmVyJykgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhpdGVtLCAnbWVudV9faXRlbS0tb3Blbi1kcm9wZG93bicpO1xuICAgICAgICAgICAgICAgIFBsdWdpbi5zaG93U3VibWVudURyb3Bkb3duKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3MoaXRlbSwgJ21lbnVfX2l0ZW0tLW9wZW4tZHJvcGRvd24nICk7XG4gICAgICAgICAgICAgICAgUGx1Z2luLmhpZGVTdWJtZW51RHJvcGRvd24oaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyB0YWIgY2xpY2sgdG9nZ2xlXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVTdWJtZW51RHJvcGRvd25UYWJDbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKFBsdWdpbi5nZXRTdWJtZW51TW9kZSh0aGlzKSA9PT0gJ2FjY29yZGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5jbG9zZXN0KCcubWVudV9faXRlbScpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEta3RtZW51LXN1Ym1lbnUtbW9kZScpID09ICdhY2NvcmRpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoS1RVdGlsLmhhc0NsYXNzKGl0ZW0sICdtZW51X19pdGVtLS1ob3ZlcicpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGl0ZW0sICdtZW51X19pdGVtLS1vcGVuLWRyb3Bkb3duJyk7XG4gICAgICAgICAgICAgICAgUGx1Z2luLnNob3dTdWJtZW51RHJvcGRvd24oaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBsaW5rIGNsaWNrXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVMaW5rQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzdWJtZW51ID0gdGhpcy5jbG9zZXN0KCcubWVudV9faXRlbS5tZW51X19pdGVtLS1zdWJtZW51Jyk7IC8vXG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdsaW5rQ2xpY2snLCB0aGlzLCBlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHN1Ym1lbnUgJiYgUGx1Z2luLmdldFN1Ym1lbnVNb2RlKHN1Ym1lbnUpID09PSAnZHJvcGRvd24nICkge1xuICAgICAgICAgICAgICAgIFBsdWdpbi5oaWRlU3VibWVudURyb3Bkb3ducygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHN1Ym1lbnUgZHJvcGRvd24gY2xvc2Ugb24gbGluayBjbGlja1xuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlU3VibWVudURyb3Bkb3duQ2xvc2U6IGZ1bmN0aW9uKGUsIGVsKSB7XG4gICAgICAgICAgICAvLyBleGl0IGlmIGl0cyBub3Qgc3VibWVudSBkcm9wZG93biBtb2RlXG4gICAgICAgICAgICBpZiAoUGx1Z2luLmdldFN1Ym1lbnVNb2RlKGVsKSA9PT0gJ2FjY29yZGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaG93biA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1lbnVfX2l0ZW0ubWVudV9faXRlbS0tc3VibWVudS5tZW51X19pdGVtLS1ob3Zlcjpub3QoLm1lbnVfX2l0ZW0tLXRhYnMpJyk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnRseSBjbGlja2VkIGxpbmsncyBwYXJlbnQgaXRlbSBoYVxuICAgICAgICAgICAgaWYgKHNob3duLmxlbmd0aCA+IDAgJiYgS1RVdGlsLmhhc0NsYXNzKGVsLCAnbWVudV9fdG9nZ2xlJykgPT09IGZhbHNlICYmIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZW51X190b2dnbGUnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9zZSBvcGVuZWQgZHJvcGRvd24gbWVudXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2hvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luLmhpZGVTdWJtZW51RHJvcGRvd24oc2hvd25bMF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlU3VibWVudUFjY29yZGlvbjogZnVuY3Rpb24oZSwgZWwpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZWwgPyBlbCA6IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICggUGx1Z2luLmdldFN1Ym1lbnVNb2RlKGVsKSA9PT0gJ2Ryb3Bkb3duJyAmJiAocXVlcnkgPSBpdGVtLmNsb3Nlc3QoJy5tZW51X19pdGVtJykgKSApIHtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkuZ2V0QXR0cmlidXRlKCdkYXRhLWt0bWVudS1zdWJtZW51LW1vZGUnKSAhPSAnYWNjb3JkaW9uJyApIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGkgPSBpdGVtLmNsb3Nlc3QoJy5tZW51X19pdGVtJyk7XG4gICAgICAgICAgICB2YXIgc3VibWVudSA9IEtUVXRpbC5jaGlsZChsaSwgJy5tZW51X19zdWJtZW51LCAubWVudV9faW5uZXInKTtcblxuICAgICAgICAgICAgaWYgKEtUVXRpbC5oYXNDbGFzcyhpdGVtLmNsb3Nlc3QoJy5tZW51X19pdGVtJyksICdtZW51X19pdGVtLS1vcGVuLWFsd2F5cycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGxpICYmIHN1Ym1lbnUgKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZCA9IHRoZS5vcHRpb25zLmFjY29yZGlvbi5zbGlkZVNwZWVkO1xuICAgICAgICAgICAgICAgIHZhciBoYXNDbG9zYWJsZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICggS1RVdGlsLmhhc0NsYXNzKGxpLCAnbWVudV9faXRlbS0tb3BlbicpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZSBvdGhlciBhY2NvcmRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhlLm9wdGlvbnMuYWNjb3JkaW9uLmV4cGFuZEFsbCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VibmF2ID0gaXRlbS5jbG9zZXN0KCcubWVudV9fbmF2LCAubWVudV9fc3VibmF2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2FibGVzID0gS1RVdGlsLmNoaWxkcmVuKHN1Ym5hdiwgJy5tZW51X19pdGVtLm1lbnVfX2l0ZW0tLW9wZW4ubWVudV9faXRlbS0tc3VibWVudTpub3QoLm1lbnVfX2l0ZW0tLWhlcmUpOm5vdCgubWVudV9faXRlbS0tb3Blbi1hbHdheXMpJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3VibmF2ICYmIGNsb3NhYmxlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2xvc2FibGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbF8gPSBjbG9zYWJsZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJtZW51XyA9IEtUVXRpbC5jaGlsZChlbF8sICcubWVudV9fc3VibWVudScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN1Ym1lbnVfICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1RVdGlsLnNsaWRlVXAoc3VibWVudV8sIHNwZWVkLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4uc2Nyb2xsVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGVsXywgJ21lbnVfX2l0ZW0tLW9wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLnNsaWRlRG93bihzdWJtZW51LCBzcGVlZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4uc2Nyb2xsVG9JdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgUGx1Z2luLnNjcm9sbFVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdzdWJtZW51VG9nZ2xlJywgc3VibWVudSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhsaSwgJ21lbnVfX2l0ZW0tLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5zbGlkZVVwKHN1Ym1lbnUsIHNwZWVkLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBsdWdpbi5zY3JvbGxUb0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdzdWJtZW51VG9nZ2xlJywgc3VibWVudSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhsaSwgJ21lbnVfX2l0ZW0tLW9wZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNjcm9sbCB0byBpdGVtIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxUb0l0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBhdXRvIHNjcm9sbCBmb3IgYWNjb3JkaW9uIHN1Ym1lbnVzXG4gICAgICAgICAgICBpZiAoIEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCdkZXNrdG9wJykgJiYgdGhlLm9wdGlvbnMuYWNjb3JkaW9uLmF1dG9TY3JvbGwgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEta3RtZW51LXNjcm9sbCcpICE9PSAnMScgKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLnNjcm9sbFRvKGl0ZW0sIHRoZS5vcHRpb25zLmFjY29yZGlvbi5hdXRvU2Nyb2xsU3BlZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHN1Ym1lbnUgZHJvcGRvd25cbiAgICAgICAgICogQHJldHVybnMge0tUTWVudX1cbiAgICAgICAgICovXG4gICAgICAgIGhpZGVTdWJtZW51RHJvcGRvd246IGZ1bmN0aW9uKGl0ZW0sIGNsYXNzQWxzbykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN1Ym1lbnUgYWN0aXZhdGlvbiBjbGFzc1xuICAgICAgICAgICAgaWYgKCBjbGFzc0Fsc28gKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGl0ZW0sICdtZW51X19pdGVtLS1ob3ZlcicpO1xuICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhpdGVtLCAnbWVudV9faXRlbS0tYWN0aXZlLXRhYicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhciB0aW1lb3V0XG4gICAgICAgICAgICBpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1ob3ZlcicpO1xuXG4gICAgICAgICAgICBpZiAoIGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWt0bWVudS1kcm9wZG93bi10b2dnbGUtY2xhc3MnKSApIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3MoYm9keSwgaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEta3RtZW51LWRyb3Bkb3duLXRvZ2dsZS1jbGFzcycpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS10aW1lb3V0Jyk7XG4gICAgICAgICAgICBpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10aW1lb3V0Jyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgc3VibWVudSBkcm9wZG93bnNcbiAgICAgICAgICogQHJldHVybnMge0tUTWVudX1cbiAgICAgICAgICovXG4gICAgICAgIGhpZGVTdWJtZW51RHJvcGRvd25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcztcbiAgICAgICAgICAgIGlmICggaXRlbXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZW51X19pdGVtLS1zdWJtZW51Lm1lbnVfX2l0ZW0tLWhvdmVyOm5vdCgubWVudV9faXRlbS0tdGFicyk6bm90KFtkYXRhLWt0bWVudS1zdWJtZW51LXRvZ2dsZT1cInRhYlwiXSknKSApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgY250ID0gaXRlbXMubGVuZ3RoOyBqIDwgY250OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luLmhpZGVTdWJtZW51RHJvcGRvd24oaXRlbXNbal0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1N1Ym1lbnVEcm9wZG93bjogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gY2xvc2UgYWN0aXZlIHN1Ym1lbnVzXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1lbnVfX2l0ZW0tLXN1Ym1lbnUubWVudV9faXRlbS0taG92ZXIsIC5tZW51X19pdGVtLS1zdWJtZW51Lm1lbnVfX2l0ZW0tLWFjdGl2ZS10YWInKTtcblxuICAgICAgICAgICAgaWYgKCBsaXN0ICkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICggaXRlbSAhPT0gZWwgJiYgZWwuY29udGFpbnMoaXRlbSkgPT09IGZhbHNlICYmIGl0ZW0uY29udGFpbnMoZWwpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBsdWdpbi5oaWRlU3VibWVudURyb3Bkb3duKGVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHN1Ym1lbnUgYWN0aXZhdGlvbiBjbGFzc1xuICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGl0ZW0sICdtZW51X19pdGVtLS1ob3ZlcicpO1xuXG4gICAgICAgICAgICBpZiAoIGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWt0bWVudS1kcm9wZG93bi10b2dnbGUtY2xhc3MnKSApIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3MoYm9keSwgaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEta3RtZW51LWRyb3Bkb3duLXRvZ2dsZS1jbGFzcycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBzdWJtZW51IHNsaWRlIHRvZ2dsZVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU3VibWVudURyb3Bkb3duQ2xpY2tEcm9wb2ZmOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5O1xuICAgICAgICAgICAgdmFyIHpJbmRleCA9IChxdWVyeSA9IEtUVXRpbC5jaGlsZChlbCwgJy5tZW51X19zdWJtZW51JykgPyBLVFV0aWwuY3NzKHF1ZXJ5LCAnei1pbmRleCcpIDogMCkgLSAxO1xuXG4gICAgICAgICAgICB2YXIgZHJvcG9mZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJtZW51X19kcm9wb2ZmXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IGJvdHRvbTogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IHotaW5kZXg6ICcgKyB6SW5kZXggKyAnXCI+PC9kaXY+Jyk7XG5cbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZHJvcG9mZik7XG5cbiAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudChkcm9wb2ZmLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBQbHVnaW4uaGlkZVN1Ym1lbnVEcm9wZG93bihlbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBzdWJtZW51IGhvdmVyIHRvZ2dsZVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgcGF1c2VEcm9wZG93bkhvdmVyOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHRoZS5wYXVzZURyb3Bkb3duSG92ZXJUaW1lID0gZGF0ZS5nZXRUaW1lKCkgKyB0aW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHN1Ym1lbnUgaG92ZXIgdG9nZ2xlXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICByZXN1bWVEcm9wZG93bkhvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIChkYXRlLmdldFRpbWUoKSA+IHRoZS5wYXVzZURyb3Bkb3duSG92ZXJUaW1lID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgbWVudSdzIGN1cnJlbnQgYWN0aXZlIGl0ZW1cbiAgICAgICAgICogQHJldHVybnMge0tUTWVudX1cbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0QWN0aXZlSXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgICAgICB2YXIgcGFyZW50cztcblxuICAgICAgICAgICAgbGlzdCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1lbnVfX2l0ZW0tLWFjdGl2ZScpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbMF07XG4gICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGVsLCAnbWVudV9faXRlbS0tYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmhpZGUoIEtUVXRpbC5jaGlsZChlbCwgJy5tZW51X19zdWJtZW51JykgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRzID0gS1RVdGlsLnBhcmVudHMoZWwsICcubWVudV9faXRlbS0tc3VibWVudScpIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaV8gPSAwLCBsZW5fID0gcGFyZW50cy5sZW5ndGg7IGlfIDwgbGVuXzsgaV8rKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxfID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGVsXywgJ21lbnVfX2l0ZW0tLW9wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmhpZGUoIEtUVXRpbC5jaGlsZChlbF8sICcubWVudV9fc3VibWVudScpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbG9zZSBvcGVuIHN1Ym1lbnVzXG4gICAgICAgICAgICBpZiAoIHRoZS5vcHRpb25zLmFjY29yZGlvbi5leHBhbmRBbGwgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGlmICggbGlzdCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1lbnVfX2l0ZW0tLW9wZW4nKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhwYXJlbnRzWzBdLCAnbWVudV9faXRlbS0tb3BlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG1lbnUncyBhY3RpdmUgaXRlbVxuICAgICAgICAgKiBAcmV0dXJucyB7S1RNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWN0aXZlSXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgICAgICAgICAgUGx1Z2luLnJlc2V0QWN0aXZlSXRlbSgpO1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50cyA9IEtUVXRpbC5wYXJlbnRzKGl0ZW0sICcubWVudV9faXRlbS0tc3VibWVudScpIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3MoS1RVdGlsLmdldChwYXJlbnRzW2ldKSwgJ21lbnVfX2l0ZW0tLW9wZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKEtUVXRpbC5nZXQoaXRlbSksICdtZW51X19pdGVtLS1hY3RpdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBwYWdlIGJyZWFkY3J1bWJzIGZvciB0aGUgbWVudSdzIGFjdGl2ZSBpdGVtXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCcmVhZGNydW1iczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5O1xuICAgICAgICAgICAgdmFyIGJyZWFkY3J1bWJzID0gW107XG4gICAgICAgICAgICB2YXIgbGluayA9IEtUVXRpbC5jaGlsZChpdGVtLCAnLm1lbnVfX2xpbmsnKTtcblxuICAgICAgICAgICAgYnJlYWRjcnVtYnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogKHF1ZXJ5ID0gS1RVdGlsLmNoaWxkKGxpbmssICcubWVudV9fbGluay10ZXh0JykgPyBxdWVyeS5pbm5lckhUTUwgOiAnJyksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxpbmsuZ2V0QXR0cmlidXRlKCd0aXRsZScpLFxuICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50cyA9IEtUVXRpbC5wYXJlbnRzKGl0ZW0sICcubWVudV9faXRlbS0tc3VibWVudScpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VibWVudUxpbmsgPSBLVFV0aWwuY2hpbGQocGFyZW50c1tpXSwgJy5tZW51X19saW5rJyk7XG5cbiAgICAgICAgICAgICAgICBicmVhZGNydW1icy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKHF1ZXJ5ID0gS1RVdGlsLmNoaWxkKHN1Ym1lbnVMaW5rLCAnLm1lbnVfX2xpbmstdGV4dCcpID8gcXVlcnkuaW5uZXJIVE1MIDogJycpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3VibWVudUxpbmsuZ2V0QXR0cmlidXRlKCd0aXRsZScpLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBzdWJtZW51TGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIGJyZWFkY3J1bWJzLnJldmVyc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBwYWdlIHRpdGxlIGZvciB0aGUgbWVudSdzIGFjdGl2ZSBpdGVtXG4gICAgICAgICAqIEByZXR1cm5zIHtLVE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYWdlVGl0bGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBxdWVyeTtcblxuICAgICAgICAgICAgcmV0dXJuIChxdWVyeSA9IEtUVXRpbC5jaGlsZChpdGVtLCAnLm1lbnVfX2xpbmstdGV4dCcpID8gcXVlcnkuaW5uZXJIVE1MIDogJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihuYW1lLCB0YXJnZXQsIGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlLmV2ZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGUuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICggZXZlbnQubmFtZSA9PSBuYW1lICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZW50Lm9uZSA9PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5maXJlZCA9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUuZXZlbnRzW2ldLmZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlci5jYWxsKHRoaXMsIHRhcmdldCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlci5jYWxsKHRoaXMsIHRhcmdldCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRXZlbnQ6IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIsIG9uZSkge1xuICAgICAgICAgICAgdGhlLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiBvbmUsXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVFdmVudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoZS5ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhlLmV2ZW50c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vICoqIFB1YmxpYyBNZXRob2RzICoqIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cblxuICAgIHRoZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2Nyb2xsXG4gICAgICovXG4gICAgdGhlLnNjcm9sbFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLnNjcm9sbFVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZS1pbml0IHNjcm9sbFxuICAgICAqL1xuICAgIHRoZS5zY3JvbGxSZUluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5zY3JvbGxJbml0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0b3BcbiAgICAgKi9cbiAgICB0aGUuc2Nyb2xsVG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uc2Nyb2xsVG9wKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhY3RpdmUgbWVudSBpdGVtXG4gICAgICovXG4gICAgdGhlLnNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uc2V0QWN0aXZlSXRlbShpdGVtKTtcbiAgICB9O1xuXG4gICAgdGhlLnJlbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLnJlbG9hZCgpO1xuICAgIH07XG5cbiAgICB0aGUudXBkYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUGx1Z2luLnVwZGF0ZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGJyZWFkY3J1bWIgZm9yIG1lbnUgaXRlbVxuICAgICAqL1xuICAgIHRoZS5nZXRCcmVhZGNydW1icyA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5nZXRCcmVhZGNydW1icyhpdGVtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHBhZ2UgdGl0bGUgZm9yIG1lbnUgaXRlbVxuICAgICAqL1xuICAgIHRoZS5nZXRQYWdlVGl0bGUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uZ2V0UGFnZVRpdGxlKGl0ZW0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3VibWVudSBtb2RlXG4gICAgICovXG4gICAgdGhlLmdldFN1Ym1lbnVNb2RlID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5nZXRTdWJtZW51TW9kZShlbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgZHJvcGRvd25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoZS5oaWRlRHJvcGRvd24gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIFBsdWdpbi5oaWRlU3VibWVudURyb3Bkb3duKGl0ZW0sIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGRyb3Bkb3duc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhlLmhpZGVEcm9wZG93bnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUGx1Z2luLmhpZGVTdWJtZW51RHJvcGRvd25zKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgbWVudSBmb3IgZ2l2ZW4gdGltZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhlLnBhdXNlRHJvcGRvd25Ib3ZlciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgUGx1Z2luLnBhdXNlRHJvcGRvd25Ib3Zlcih0aW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBtZW51IGZvciBnaXZlbiB0aW1lXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGUucmVzdW1lRHJvcGRvd25Ib3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLnJlc3VtZURyb3Bkb3duSG92ZXIoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZXZlbnRcbiAgICAgKi9cbiAgICB0aGUub24gPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uYWRkRXZlbnQobmFtZSwgaGFuZGxlcik7XG4gICAgfTtcblxuICAgIHRoZS5vZmYgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4ucmVtb3ZlRXZlbnQobmFtZSk7XG4gICAgfTtcblxuICAgIHRoZS5vbmUgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uYWRkRXZlbnQobmFtZSwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyAqKiBQbHVnaW4gQ29uc3RydWN0aW9uICoqIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLy8gUnVuIHBsdWdpblxuICAgIFBsdWdpbi5jb25zdHJ1Y3QuYXBwbHkodGhlLCBbb3B0aW9uc10pO1xuXG4gICAgLy8gSGFuZGxlIHBsdWdpbiBvbiB3aW5kb3cgcmVzaXplXG4gICAgS1RVdGlsLmFkZFJlc2l6ZUhhbmRsZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICB0aGUucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEluaXQgZG9uZVxuICAgIGluaXQgPSB0cnVlO1xuXG4gICAgLy8gUmV0dXJuIHBsdWdpbiBpbnN0YW5jZVxuICAgIHJldHVybiB0aGU7XG59O1xuXG4vLyB3ZWJwYWNrIHN1cHBvcnRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVE1lbnU7XG59XG5cbi8vIFBsdWdpbiBnbG9iYWwgbGF6eSBpbml0aWFsaXphdGlvblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGJvZHkgPSBLVFV0aWwuZ2V0KCdib2R5Jyk7XG4gICAgdmFyIHF1ZXJ5O1xuICAgIGlmICggcXVlcnkgPSBib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZW51X19uYXYgLm1lbnVfX2l0ZW0ubWVudV9faXRlbS0tc3VibWVudS5tZW51X19pdGVtLS1ob3Zlcjpub3QoLm1lbnVfX2l0ZW0tLXRhYnMpW2RhdGEta3RtZW51LXN1Ym1lbnUtdG9nZ2xlPVwiY2xpY2tcIl0nKSApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHF1ZXJ5W2ldLmNsb3Nlc3QoJy5tZW51X19uYXYnKS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZSA9IEtUVXRpbC5kYXRhKGVsZW1lbnQpLmdldCgnbWVudScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhdGhlICkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICF0aGUgfHwgdGhlLmdldFN1Ym1lbnVNb2RlKCkgIT09ICdkcm9wZG93bicgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggZS50YXJnZXQgIT09IGVsZW1lbnQgJiYgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGUuaGlkZURyb3Bkb3ducygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBLVE9mZmNhbnZhcyA9IGZ1bmN0aW9uKGVsZW1lbnRJZCwgb3B0aW9ucykge1xyXG4gICAgLy8gTWFpbiBvYmplY3RcclxuICAgIHZhciB0aGUgPSB0aGlzO1xyXG4gICAgdmFyIGluaXQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBHZXQgZWxlbWVudCBvYmplY3RcclxuICAgIHZhciBlbGVtZW50ID0gS1RVdGlsLmdldChlbGVtZW50SWQpO1xyXG4gICAgdmFyIGJvZHkgPSBLVFV0aWwuZ2V0KCdib2R5Jyk7XHJcblxyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgb3B0aW9uc1xyXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge307XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gKiogUHJpdmF0ZSBNZXRob2RzICAqKiAvL1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIHZhciBQbHVnaW4gPSB7XHJcbiAgICAgICAgY29uc3RydWN0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChLVFV0aWwuZGF0YShlbGVtZW50KS5oYXMoJ29mZmNhbnZhcycpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGUgPSBLVFV0aWwuZGF0YShlbGVtZW50KS5nZXQoJ29mZmNhbnZhcycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgb2ZmY2FudmFzXHJcbiAgICAgICAgICAgICAgICBQbHVnaW4uaW5pdChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgb2ZmY2FudmFzXHJcbiAgICAgICAgICAgICAgICBQbHVnaW4uYnVpbGQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShlbGVtZW50KS5zZXQoJ29mZmNhbnZhcycsIHRoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGUuZXZlbnRzID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBtZXJnZSBkZWZhdWx0IGFuZCB1c2VyIGRlZmluZWQgb3B0aW9uc1xyXG4gICAgICAgICAgICB0aGUub3B0aW9ucyA9IEtUVXRpbC5kZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoZS5vdmVybGF5O1xyXG5cclxuICAgICAgICAgICAgdGhlLmNsYXNzQmFzZSA9IHRoZS5vcHRpb25zLmJhc2VDbGFzcztcclxuICAgICAgICAgICAgdGhlLmNsYXNzU2hvd24gPSB0aGUuY2xhc3NCYXNlICsgJy0tb24nO1xyXG4gICAgICAgICAgICB0aGUuY2xhc3NPdmVybGF5ID0gdGhlLmNsYXNzQmFzZSArICctb3ZlcmxheSc7XHJcblxyXG4gICAgICAgICAgICB0aGUuc3RhdGUgPSBLVFV0aWwuaGFzQ2xhc3MoZWxlbWVudCwgdGhlLmNsYXNzU2hvd24pID8gJ3Nob3duJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gb2ZmY2FudmFzIHRvZ2dsZVxyXG4gICAgICAgICAgICBpZiAodGhlLm9wdGlvbnMudG9nZ2xlQnkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlLm9wdGlvbnMudG9nZ2xlQnkgPT09ICdzdHJpbmcnKSB7IFxyXG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudCggdGhlLm9wdGlvbnMudG9nZ2xlQnksICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7IFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGUub3B0aW9ucy50b2dnbGVCeSAmJiB0aGUub3B0aW9ucy50b2dnbGVCeVswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGUub3B0aW9ucy50b2dnbGVCeVswXS50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGUub3B0aW9ucy50b2dnbGVCeSkgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudCggdGhlLm9wdGlvbnMudG9nZ2xlQnlbaV0udGFyZ2V0LCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBsdWdpbi50b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhlLm9wdGlvbnMudG9nZ2xlQnkpIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuYWRkRXZlbnQoIHRoZS5vcHRpb25zLnRvZ2dsZUJ5W2ldLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBsdWdpbi50b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhlLm9wdGlvbnMudG9nZ2xlQnkgJiYgdGhlLm9wdGlvbnMudG9nZ2xlQnkudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KCB0aGUub3B0aW9ucy50b2dnbGVCeS50YXJnZXQsICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7IFxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gb2ZmY2FudmFzIGNsb3NlXHJcbiAgICAgICAgICAgIHZhciBjbG9zZUJ5ID0gS1RVdGlsLmdldCh0aGUub3B0aW9ucy5jbG9zZUJ5KTtcclxuICAgICAgICAgICAgaWYgKGNsb3NlQnkpIHtcclxuICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudChjbG9zZUJ5LCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2luZG93IHJlc2l6ZVxyXG4gICAgICAgICAgICBLVFV0aWwuYWRkUmVzaXplSGFuZGxlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChLVFV0aWwuY3NzKGVsZW1lbnQsICdsZWZ0JykpID49IDAgfHwgcGFyc2VJbnQoS1RVdGlsLmNzcyhlbGVtZW50LCAncmlnaHQnKSA+PSAwKSB8fCBLVFV0aWwuY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpICE9ICdmaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsZW1lbnQsICdvcGFjaXR5JywgJzEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNTaG93bjogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhlLnN0YXRlID09ICdzaG93bicgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7O1xyXG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCd0b2dnbGUnKTsgXHJcblxyXG4gICAgICAgICAgICBpZiAodGhlLnN0YXRlID09ICdzaG93bicpIHtcclxuICAgICAgICAgICAgICAgIFBsdWdpbi5oaWRlKHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgUGx1Z2luLnNob3codGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaG93OiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRoZS5zdGF0ZSA9PSAnc2hvd24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ2JlZm9yZVNob3cnKTtcclxuXHJcbiAgICAgICAgICAgIFBsdWdpbi50b2dnbGVyQ2xhc3ModGFyZ2V0LCAnc2hvdycpO1xyXG5cclxuICAgICAgICAgICAgLy8gT2ZmY2FudmFzIHBhbmVsXHJcbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhib2R5LCB0aGUuY2xhc3NTaG93bik7XHJcbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhlbGVtZW50LCB0aGUuY2xhc3NTaG93bik7XHJcbiAgICAgICAgICAgIEtUVXRpbC5jc3MoZWxlbWVudCwgJ29wYWNpdHknLCAnMScpO1xyXG5cclxuICAgICAgICAgICAgdGhlLnN0YXRlID0gJ3Nob3duJztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGUub3B0aW9ucy5vdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGUub3ZlcmxheSA9IEtUVXRpbC5pbnNlcnRBZnRlcihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKSAsIGVsZW1lbnQgKTtcclxuICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyh0aGUub3ZlcmxheSwgdGhlLmNsYXNzT3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICBLVFV0aWwuYWRkRXZlbnQodGhlLm92ZXJsYXksICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4uaGlkZSh0YXJnZXQpOyAgICAgICBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlclNob3cnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoaWRlOiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRoZS5zdGF0ZSA9PSAnaGlkZGVuJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdiZWZvcmVIaWRlJyk7XHJcblxyXG4gICAgICAgICAgICBQbHVnaW4udG9nZ2xlckNsYXNzKHRhcmdldCwgJ2hpZGUnKTtcclxuXHJcbiAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhib2R5LCB0aGUuY2xhc3NTaG93bik7XHJcbiAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhlbGVtZW50LCB0aGUuY2xhc3NTaG93bik7XHJcblxyXG4gICAgICAgICAgICB0aGUuc3RhdGUgPSAnaGlkZGVuJztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGUub3B0aW9ucy5vdmVybGF5ICYmIHRoZS5vdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlKHRoZS5vdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgS1RVdGlsLnRyYW5zaXRpb25FbmQoZWxlbWVudCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsZW1lbnQsICdvcGFjaXR5JywgJzAnKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlckhpZGUnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b2dnbGVyQ2xhc3M6IGZ1bmN0aW9uKHRhcmdldCwgbW9kZSkge1xyXG4gICAgICAgICAgICAvLyBUb2dnbGVyXHJcbiAgICAgICAgICAgIHZhciBpZCA9IEtUVXRpbC5hdHRyKHRhcmdldCwgJ2lkJyk7XHJcbiAgICAgICAgICAgIHZhciB0b2dnbGVCeTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGUub3B0aW9ucy50b2dnbGVCeSAmJiB0aGUub3B0aW9ucy50b2dnbGVCeVswXSAmJiB0aGUub3B0aW9ucy50b2dnbGVCeVswXS50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhlLm9wdGlvbnMudG9nZ2xlQnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhlLm9wdGlvbnMudG9nZ2xlQnlbaV0udGFyZ2V0ID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVCeSA9IHRoZS5vcHRpb25zLnRvZ2dsZUJ5W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoZS5vcHRpb25zLnRvZ2dsZUJ5ICYmIHRoZS5vcHRpb25zLnRvZ2dsZUJ5LnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlQnkgPSB0aGUub3B0aW9ucy50b2dnbGVCeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRvZ2dsZUJ5KSB7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gS1RVdGlsLmdldCh0b2dnbGVCeS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3Nob3cnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGVsLCB0b2dnbGVCeS5zdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdoaWRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhlbCwgdG9nZ2xlQnkuc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhlLmV2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5uYW1lID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQub25lID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmZpcmVkID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUuZXZlbnRzW2ldLmZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVyLmNhbGwodGhpcywgdGhlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVyLmNhbGwodGhpcywgdGhlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGRFdmVudDogZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgb25lKSB7XHJcbiAgICAgICAgICAgIHRoZS5ldmVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcclxuICAgICAgICAgICAgICAgIG9uZTogb25lLFxyXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vICoqIFB1YmxpYyBNZXRob2RzICoqIC8vXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgdGhlLnNldERlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcclxuICAgIH07XHJcblxyXG4gICAgdGhlLmlzU2hvd24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLmlzU2hvd24oKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhlLmhpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLmhpZGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhlLnNob3cgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLnNob3coKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhlLm9uID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBQbHVnaW4uYWRkRXZlbnQobmFtZSwgaGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoZS5vbmUgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5hZGRFdmVudChuYW1lLCBoYW5kbGVyLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gKiogUGx1Z2luIENvbnN0cnVjdGlvbiAqKiAvL1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIC8vIFJ1biBwbHVnaW5cclxuICAgIFBsdWdpbi5jb25zdHJ1Y3QuYXBwbHkodGhlLCBbb3B0aW9uc10pO1xyXG5cclxuICAgIC8vIEluaXQgZG9uZVxyXG4gICAgaW5pdCA9IHRydWU7XHJcblxyXG4gICAgLy8gUmV0dXJuIHBsdWdpbiBpbnN0YW5jZVxyXG4gICAgcmV0dXJuIHRoZTtcclxufTtcclxuXHJcbi8vIHdlYnBhY2sgc3VwcG9ydFxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVE9mZmNhbnZhcztcclxufSIsIlwidXNlIHN0cmljdFwiO1xuLy8gcGx1Z2luIHNldHVwXG52YXIgS1RQb3J0bGV0ID0gZnVuY3Rpb24oZWxlbWVudElkLCBvcHRpb25zKSB7XG4gICAgLy8gTWFpbiBvYmplY3RcbiAgICB2YXIgdGhlID0gdGhpcztcbiAgICB2YXIgaW5pdCA9IGZhbHNlO1xuXG4gICAgLy8gR2V0IGVsZW1lbnQgb2JqZWN0XG4gICAgdmFyIGVsZW1lbnQgPSBLVFV0aWwuZ2V0KGVsZW1lbnRJZCk7XG4gICAgdmFyIGJvZHkgPSBLVFV0aWwuZ2V0KCdib2R5Jyk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgb3B0aW9uc1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgYm9keVRvZ2dsZVNwZWVkOiA0MDAsXG4gICAgICAgIHRvb2x0aXBzOiB0cnVlLFxuICAgICAgICB0b29sczoge1xuICAgICAgICAgICAgdG9nZ2xlOiB7XG4gICAgICAgICAgICAgICAgY29sbGFwc2U6ICdDb2xsYXBzZScsXG4gICAgICAgICAgICAgICAgZXhwYW5kOiAnRXhwYW5kJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbG9hZDogJ1JlbG9hZCcsXG4gICAgICAgICAgICByZW1vdmU6ICdSZW1vdmUnLFxuICAgICAgICAgICAgZnVsbHNjcmVlbjoge1xuICAgICAgICAgICAgICAgIG9uOiAnRnVsbHNjcmVlbicsXG4gICAgICAgICAgICAgICAgb2ZmOiAnRXhpdCBGdWxsc2NyZWVuJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAgIG9mZnNldDogMzAwLFxuICAgICAgICAgICAgekluZGV4OiAxMDFcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gKiogUHJpdmF0ZSBNZXRob2RzICAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBQbHVnaW4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RcbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3RydWN0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoS1RVdGlsLmRhdGEoZWxlbWVudCkuaGFzKCdwb3J0bGV0JykpIHtcbiAgICAgICAgICAgICAgICB0aGUgPSBLVFV0aWwuZGF0YShlbGVtZW50KS5nZXQoJ3BvcnRsZXQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgbWVudVxuICAgICAgICAgICAgICAgIFBsdWdpbi5pbml0KG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgbWVudVxuICAgICAgICAgICAgICAgIFBsdWdpbi5idWlsZCgpO1xuXG4gICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEoZWxlbWVudCkuc2V0KCdwb3J0bGV0JywgdGhlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCBwb3J0bGV0XG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGUuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0aGUuZXZlbnRzID0gW107XG5cbiAgICAgICAgICAgIC8vIG1lcmdlIGRlZmF1bHQgYW5kIHVzZXIgZGVmaW5lZCBvcHRpb25zXG4gICAgICAgICAgICB0aGUub3B0aW9ucyA9IEtUVXRpbC5kZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGUuaGVhZCA9IEtUVXRpbC5jaGlsZChlbGVtZW50LCAnLnBvcnRsZXRfX2hlYWQnKTtcbiAgICAgICAgICAgIHRoZS5mb290ID0gS1RVdGlsLmNoaWxkKGVsZW1lbnQsICcucG9ydGxldF9fZm9vdCcpO1xuXG4gICAgICAgICAgICBpZiAoS1RVdGlsLmNoaWxkKGVsZW1lbnQsICcucG9ydGxldF9fYm9keScpKSB7XG4gICAgICAgICAgICAgICAgdGhlLmJvZHkgPSBLVFV0aWwuY2hpbGQoZWxlbWVudCwgJy5wb3J0bGV0X19ib2R5Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEtUVXRpbC5jaGlsZChlbGVtZW50LCAnLmZvcm0nKSkge1xuICAgICAgICAgICAgICAgIHRoZS5ib2R5ID0gS1RVdGlsLmNoaWxkKGVsZW1lbnQsICcuZm9ybScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBGb3JtIFdpemFyZFxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlXG4gICAgICAgICAgICB2YXIgcmVtb3ZlID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD1yZW1vdmVdJyk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KHJlbW92ZSwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVsb2FkXG4gICAgICAgICAgICB2YXIgcmVsb2FkID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD1yZWxvYWRdJyk7XG4gICAgICAgICAgICBpZiAocmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KHJlbG9hZCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVG9nZ2xlXG4gICAgICAgICAgICB2YXIgdG9nZ2xlID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD10b2dnbGVdJyk7XG4gICAgICAgICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KHRvZ2dsZSwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PSBGdWxsc2NyZWVuXG4gICAgICAgICAgICB2YXIgZnVsbHNjcmVlbiA9IEtUVXRpbC5maW5kKHRoZS5oZWFkLCAnW2RhdGEta3Rwb3J0bGV0LXRvb2w9ZnVsbHNjcmVlbl0nKTtcbiAgICAgICAgICAgIGlmIChmdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KGZ1bGxzY3JlZW4sICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBQbHVnaW4uZnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBQbHVnaW4uc2V0dXBUb29sdGlwcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUgc3RpY2t0IG1vZGVcbiAgICAgICAgICovXG4gICAgICAgIGluaXRTdGlja3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoZS5vcHRpb25zLnN0aWNreS5vZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmICghdGhlLmhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblx0ICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgUGx1Z2luLm9uU2Nyb2xsU3RpY2t5KTtcbiAgICAgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBXaW5kb3cgc2Nyb2xsIGhhbmRsZSBldmVudCBmb3Igc3RpY2t5IHBvcnRsZXRcblx0ICAgICAqL1xuXHQgICAgb25TY3JvbGxTdGlja3k6IGZ1bmN0aW9uKGUpIHtcblx0XHQgICAgdmFyIG9mZnNldCA9IHRoZS5vcHRpb25zLnN0aWNreS5vZmZzZXQ7XG5cblx0XHQgICAgaWYoaXNOYU4ob2Zmc2V0KSkgcmV0dXJuO1xuXG5cdFx0ICAgIHZhciBzdCA9IEtUVXRpbC5nZXRTY3JvbGxUb3AoKTtcblxuXHRcdCAgICBpZiAoc3QgPj0gb2Zmc2V0ICYmIEtUVXRpbC5oYXNDbGFzcyhib2R5LCAncG9ydGxldC0tc3RpY2t5JykgPT09IGZhbHNlKSB7XG5cdFx0XHQgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignc3RpY2t5T24nKTtcblxuXHRcdFx0ICAgIEtUVXRpbC5hZGRDbGFzcyhib2R5LCAncG9ydGxldC0tc3RpY2t5Jyk7XG5cdFx0XHQgICAgS1RVdGlsLmFkZENsYXNzKGVsZW1lbnQsICdwb3J0bGV0LS1zdGlja3knKTtcblxuXHRcdFx0ICAgIFBsdWdpbi51cGRhdGVTdGlja3koKTtcblxuXHRcdCAgICB9IGVsc2UgaWYgKChzdCoxLjUpIDw9IG9mZnNldCAmJiBLVFV0aWwuaGFzQ2xhc3MoYm9keSwgJ3BvcnRsZXQtLXN0aWNreScpKSB7XG5cdFx0XHQgICAgLy8gYmFjayBzY3JvbGwgbW9kZVxuXHRcdFx0ICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ3N0aWNreU9mZicpO1xuXG5cdFx0XHQgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGJvZHksICdwb3J0bGV0LS1zdGlja3knKTtcblx0XHRcdCAgICBLVFV0aWwucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ3BvcnRsZXQtLXN0aWNreScpO1xuXG5cdFx0XHQgICAgUGx1Z2luLnJlc2V0U3RpY2t5KCk7XG5cdFx0ICAgIH1cblx0ICAgIH0sXG5cbiAgICAgICAgdXBkYXRlU3RpY2t5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhlLmhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3A7XG5cbiAgICAgICAgICAgIGlmIChLVFV0aWwuaGFzQ2xhc3MoYm9keSwgJ3BvcnRsZXQtLXN0aWNreScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoZS5vcHRpb25zLnN0aWNreS5wb3NpdGlvbi50b3AgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBwYXJzZUludCh0aGUub3B0aW9ucy5zdGlja3kucG9zaXRpb24udG9wLmNhbGwodGhpcywgdGhlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gcGFyc2VJbnQodGhlLm9wdGlvbnMuc3RpY2t5LnBvc2l0aW9uLnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoZS5vcHRpb25zLnN0aWNreS5wb3NpdGlvbi5sZWZ0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlSW50KHRoZS5vcHRpb25zLnN0aWNreS5wb3NpdGlvbi5sZWZ0LmNhbGwodGhpcywgdGhlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlSW50KHRoZS5vcHRpb25zLnN0aWNreS5wb3NpdGlvbi5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoZS5vcHRpb25zLnN0aWNreS5wb3NpdGlvbi5yaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VJbnQodGhlLm9wdGlvbnMuc3RpY2t5LnBvc2l0aW9uLnJpZ2h0LmNhbGwodGhpcywgdGhlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUludCh0aGUub3B0aW9ucy5zdGlja3kucG9zaXRpb24ucmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmhlYWQsICd6LWluZGV4JywgdGhlLm9wdGlvbnMuc3RpY2t5LnpJbmRleCk7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmNzcyh0aGUuaGVhZCwgJ3RvcCcsIHRvcCArICdweCcpO1xuICAgICAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmhlYWQsICdsZWZ0JywgbGVmdCArICdweCcpO1xuICAgICAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmhlYWQsICdyaWdodCcsIHJpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXRTdGlja3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGUuaGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEtUVXRpbC5oYXNDbGFzcyhib2R5LCAncG9ydGxldC0tc3RpY2t5JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmNzcyh0aGUuaGVhZCwgJ3otaW5kZXgnLCAnJyk7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmNzcyh0aGUuaGVhZCwgJ3RvcCcsICcnKTtcbiAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKHRoZS5oZWFkLCAnbGVmdCcsICcnKTtcbiAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKHRoZS5oZWFkLCAncmlnaHQnLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBwb3J0bGV0XG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKFBsdWdpbi5ldmVudFRyaWdnZXIoJ2JlZm9yZVJlbW92ZScpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEtUVXRpbC5oYXNDbGFzcyhib2R5LCAncG9ydGxldC0tZnVsbHNjcmVlbicpICYmIEtUVXRpbC5oYXNDbGFzcyhlbGVtZW50LCAncG9ydGxldC0tZnVsbHNjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgUGx1Z2luLmZ1bGxzY3JlZW4oJ29mZicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBQbHVnaW4ucmVtb3ZlVG9vbHRpcHMoKTtcblxuICAgICAgICAgICAgS1RVdGlsLnJlbW92ZShlbGVtZW50KTtcblxuICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignYWZ0ZXJSZW1vdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGNvbnRlbnRcbiAgICAgICAgICovXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgICAgICAgdGhlLmJvZHkuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJvZHlcbiAgICAgICAgICovXG4gICAgICAgIGdldEJvZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoZS5ib2R5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc2VsZlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VsZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dXAgdG9vbHRpcHNcbiAgICAgICAgICovXG4gICAgICAgIHNldHVwVG9vbHRpcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoZS5vcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbGxhcHNlZCA9IEtUVXRpbC5oYXNDbGFzcyhlbGVtZW50LCAncG9ydGxldC0tY29sbGFwc2UnKSB8fCBLVFV0aWwuaGFzQ2xhc3MoZWxlbWVudCwgJ3BvcnRsZXQtLWNvbGxhcHNlZCcpO1xuICAgICAgICAgICAgICAgIHZhciBmdWxsc2NyZWVuT24gPSBLVFV0aWwuaGFzQ2xhc3MoYm9keSwgJ3BvcnRsZXQtLWZ1bGxzY3JlZW4nKSAmJiBLVFV0aWwuaGFzQ2xhc3MoZWxlbWVudCwgJ3BvcnRsZXQtLWZ1bGxzY3JlZW4nKTtcblxuICAgICAgICAgICAgICAgIC8vPT0gUmVtb3ZlXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZSA9IEtUVXRpbC5maW5kKHRoZS5oZWFkLCAnW2RhdGEta3Rwb3J0bGV0LXRvb2w9cmVtb3ZlXScpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IChmdWxsc2NyZWVuT24gPyAnYm90dG9tJyA6ICd0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcCA9IG5ldyBUb29sdGlwKHJlbW92ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRoZS5vcHRpb25zLnRvb2xzLnJlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAoZnVsbHNjcmVlbk9uID8gJzAsMTBweCwwLDAnIDogJzAsNXB4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiAnaG92ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcCB0b29sdGlwLXBvcnRsZXQgdG9vbHRpcCBicy10b29sdGlwLScgKyBwbGFjZW1lbnQgKyAnXCIgcm9sZT1cInRvb2x0aXBcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93IGFycm93XCI+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5kYXRhKHJlbW92ZSkuc2V0KCd0b29sdGlwJywgdGlwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLz09IFJlbG9hZFxuICAgICAgICAgICAgICAgIHZhciByZWxvYWQgPSBLVFV0aWwuZmluZCh0aGUuaGVhZCwgJ1tkYXRhLWt0cG9ydGxldC10b29sPXJlbG9hZF0nKTtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAoZnVsbHNjcmVlbk9uID8gJ2JvdHRvbScgOiAndG9wJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXAgPSBuZXcgVG9vbHRpcChyZWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGUub3B0aW9ucy50b29scy5yZWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogKGZ1bGxzY3JlZW5PbiA/ICcwLDEwcHgsMCwwJyA6ICcwLDVweCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogJ2hvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXAgdG9vbHRpcC1wb3J0bGV0IHRvb2x0aXAgYnMtdG9vbHRpcC0nICsgcGxhY2VtZW50ICsgJ1wiIHJvbGU9XCJ0b29sdGlwXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvdyBhcnJvd1wiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+J1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShyZWxvYWQpLnNldCgndG9vbHRpcCcsIHRpcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy89PSBUb2dnbGVcbiAgICAgICAgICAgICAgICB2YXIgdG9nZ2xlID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD10b2dnbGVdJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gKGZ1bGxzY3JlZW5PbiA/ICdib3R0b20nIDogJ3RvcCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwID0gbmV3IFRvb2x0aXAodG9nZ2xlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogKGNvbGxhcHNlZCA/IHRoZS5vcHRpb25zLnRvb2xzLnRvZ2dsZS5leHBhbmQgOiB0aGUub3B0aW9ucy50b29scy50b2dnbGUuY29sbGFwc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IChmdWxsc2NyZWVuT24gPyAnMCwxMHB4LDAsMCcgOiAnMCw1cHgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdob3ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwIHRvb2x0aXAtcG9ydGxldCB0b29sdGlwIGJzLXRvb2x0aXAtJyArIHBsYWNlbWVudCArICdcIiByb2xlPVwidG9vbHRpcFwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3cgYXJyb3dcIj48L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PidcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEodG9nZ2xlKS5zZXQoJ3Rvb2x0aXAnLCB0aXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vPT0gRnVsbHNjcmVlblxuICAgICAgICAgICAgICAgIHZhciBmdWxsc2NyZWVuID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD1mdWxsc2NyZWVuXScpO1xuICAgICAgICAgICAgICAgIGlmIChmdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAoZnVsbHNjcmVlbk9uID8gJ2JvdHRvbScgOiAndG9wJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXAgPSBuZXcgVG9vbHRpcChmdWxsc2NyZWVuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogKGZ1bGxzY3JlZW5PbiA/IHRoZS5vcHRpb25zLnRvb2xzLmZ1bGxzY3JlZW4ub2ZmIDogdGhlLm9wdGlvbnMudG9vbHMuZnVsbHNjcmVlbi5vbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogKGZ1bGxzY3JlZW5PbiA/ICcwLDEwcHgsMCwwJyA6ICcwLDVweCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogJ2hvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXAgdG9vbHRpcC1wb3J0bGV0IHRvb2x0aXAgYnMtdG9vbHRpcC0nICsgcGxhY2VtZW50ICsgJ1wiIHJvbGU9XCJ0b29sdGlwXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvdyBhcnJvd1wiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+J1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShmdWxsc2NyZWVuKS5zZXQoJ3Rvb2x0aXAnLCB0aXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dXAgdG9vbHRpcHNcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVRvb2x0aXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGUub3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICAgIC8vPT0gUmVtb3ZlXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZSA9IEtUVXRpbC5maW5kKHRoZS5oZWFkLCAnW2RhdGEta3Rwb3J0bGV0LXRvb2w9cmVtb3ZlXScpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmUgJiYgS1RVdGlsLmRhdGEocmVtb3ZlKS5oYXMoJ3Rvb2x0aXAnKSkge1xuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShyZW1vdmUpLmdldCgndG9vbHRpcCcpLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLz09IFJlbG9hZFxuICAgICAgICAgICAgICAgIHZhciByZWxvYWQgPSBLVFV0aWwuZmluZCh0aGUuaGVhZCwgJ1tkYXRhLWt0cG9ydGxldC10b29sPXJlbG9hZF0nKTtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2FkICYmIEtUVXRpbC5kYXRhKHJlbG9hZCkuaGFzKCd0b29sdGlwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEocmVsb2FkKS5nZXQoJ3Rvb2x0aXAnKS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy89PSBUb2dnbGVcbiAgICAgICAgICAgICAgICB2YXIgdG9nZ2xlID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD10b2dnbGVdJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZSAmJiBLVFV0aWwuZGF0YSh0b2dnbGUpLmhhcygndG9vbHRpcCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5kYXRhKHRvZ2dsZSkuZ2V0KCd0b29sdGlwJykuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vPT0gRnVsbHNjcmVlblxuICAgICAgICAgICAgICAgIHZhciBmdWxsc2NyZWVuID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD1mdWxsc2NyZWVuXScpO1xuICAgICAgICAgICAgICAgIGlmIChmdWxsc2NyZWVuICYmIEtUVXRpbC5kYXRhKGZ1bGxzY3JlZW4pLmhhcygndG9vbHRpcCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5kYXRhKGZ1bGxzY3JlZW4pLmdldCgndG9vbHRpcCcpLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ3JlbG9hZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGVcbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoS1RVdGlsLmhhc0NsYXNzKGVsZW1lbnQsICdwb3J0bGV0LS1jb2xsYXBzZScpIHx8IEtUVXRpbC5oYXNDbGFzcyhlbGVtZW50LCAncG9ydGxldC0tY29sbGFwc2VkJykpIHtcbiAgICAgICAgICAgICAgICBQbHVnaW4uZXhwYW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFBsdWdpbi5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsYXBzZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKFBsdWdpbi5ldmVudFRyaWdnZXIoJ2JlZm9yZUNvbGxhcHNlJykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLVFV0aWwuc2xpZGVVcCh0aGUuYm9keSwgdGhlLm9wdGlvbnMuYm9keVRvZ2dsZVNwZWVkLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlckNvbGxhcHNlJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGVsZW1lbnQsICdwb3J0bGV0LS1jb2xsYXBzZScpO1xuXG4gICAgICAgICAgICB2YXIgdG9nZ2xlID0gS1RVdGlsLmZpbmQodGhlLmhlYWQsICdbZGF0YS1rdHBvcnRsZXQtdG9vbD10b2dnbGVdJyk7XG4gICAgICAgICAgICBpZiAodG9nZ2xlICYmIEtUVXRpbC5kYXRhKHRvZ2dsZSkuaGFzKCd0b29sdGlwJykpIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YSh0b2dnbGUpLmdldCgndG9vbHRpcCcpLnVwZGF0ZVRpdGxlQ29udGVudCh0aGUub3B0aW9ucy50b29scy50b2dnbGUuZXhwYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwYW5kXG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKFBsdWdpbi5ldmVudFRyaWdnZXIoJ2JlZm9yZUV4cGFuZCcpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS1RVdGlsLnNsaWRlRG93bih0aGUuYm9keSwgdGhlLm9wdGlvbnMuYm9keVRvZ2dsZVNwZWVkLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlckV4cGFuZCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhlbGVtZW50LCAncG9ydGxldC0tY29sbGFwc2UnKTtcbiAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhlbGVtZW50LCAncG9ydGxldC0tY29sbGFwc2VkJyk7XG5cbiAgICAgICAgICAgIHZhciB0b2dnbGUgPSBLVFV0aWwuZmluZCh0aGUuaGVhZCwgJ1tkYXRhLWt0cG9ydGxldC10b29sPXRvZ2dsZV0nKTtcbiAgICAgICAgICAgIGlmICh0b2dnbGUgJiYgS1RVdGlsLmRhdGEodG9nZ2xlKS5oYXMoJ3Rvb2x0aXAnKSkge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5kYXRhKHRvZ2dsZSkuZ2V0KCd0b29sdGlwJykudXBkYXRlVGl0bGVDb250ZW50KHRoZS5vcHRpb25zLnRvb2xzLnRvZ2dsZS5jb2xsYXBzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZ1bGxzY3JlZW5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bGxzY3JlZW46IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgICAgIHZhciBkID0ge307XG4gICAgICAgICAgICB2YXIgc3BlZWQgPSAzMDA7XG5cbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnb2ZmJyB8fCAoS1RVdGlsLmhhc0NsYXNzKGJvZHksICdwb3J0bGV0LS1mdWxsc2NyZWVuJykgJiYgS1RVdGlsLmhhc0NsYXNzKGVsZW1lbnQsICdwb3J0bGV0LS1mdWxsc2NyZWVuJykpKSB7XG4gICAgICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignYmVmb3JlRnVsbHNjcmVlbk9mZicpO1xuXG4gICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGJvZHksICdwb3J0bGV0LS1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdwb3J0bGV0LS1mdWxsc2NyZWVuJyk7XG5cbiAgICAgICAgICAgICAgICBQbHVnaW4ucmVtb3ZlVG9vbHRpcHMoKTtcbiAgICAgICAgICAgICAgICBQbHVnaW4uc2V0dXBUb29sdGlwcygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoZS5mb290KSB7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmJvZHksICdtYXJnaW4tYm90dG9tJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKHRoZS5mb290LCAnbWFyZ2luLXRvcCcsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlckZ1bGxzY3JlZW5PZmYnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignYmVmb3JlRnVsbHNjcmVlbk9uJyk7XG5cbiAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3MoZWxlbWVudCwgJ3BvcnRsZXQtLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3MoYm9keSwgJ3BvcnRsZXQtLWZ1bGxzY3JlZW4nKTtcblxuICAgICAgICAgICAgICAgIFBsdWdpbi5yZW1vdmVUb29sdGlwcygpO1xuICAgICAgICAgICAgICAgIFBsdWdpbi5zZXR1cFRvb2x0aXBzKCk7XG5cblxuICAgICAgICAgICAgICAgIGlmICh0aGUuZm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0MSA9IHBhcnNlSW50KEtUVXRpbC5jc3ModGhlLmZvb3QsICdoZWlnaHQnKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQyID0gcGFyc2VJbnQoS1RVdGlsLmNzcyh0aGUuZm9vdCwgJ2hlaWdodCcpKSArIHBhcnNlSW50KEtUVXRpbC5jc3ModGhlLmhlYWQsICdoZWlnaHQnKSk7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5jc3ModGhlLmJvZHksICdtYXJnaW4tYm90dG9tJywgaGVpZ2h0MSArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKHRoZS5mb290LCAnbWFyZ2luLXRvcCcsICctJyArIGhlaWdodDIgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlckZ1bGxzY3JlZW5PbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAvL0tUVXRpbC50cmlnZ2VyQ3VzdG9tRXZlbnQobmFtZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoZS5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGUuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9uZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZmlyZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUuZXZlbnRzW2ldLmZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlci5jYWxsKHRoaXMsIHRoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlci5jYWxsKHRoaXMsIHRoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRXZlbnQ6IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIsIG9uZSkge1xuICAgICAgICAgICAgdGhlLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiBvbmUsXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vICoqIFB1YmxpYyBNZXRob2RzICoqIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cblxuICAgIHRoZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcG9ydGxldFxuICAgICAqIEByZXR1cm5zIHtLVFBvcnRsZXR9XG4gICAgICovXG4gICAgdGhlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLnJlbW92ZShodG1sKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHBvcnRsZXRcbiAgICAgKiBAcmV0dXJucyB7S1RQb3J0bGV0fVxuICAgICAqL1xuICAgIHRoZS5pbml0U3RpY2t5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uaW5pdFN0aWNreSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcG9ydGxldFxuICAgICAqIEByZXR1cm5zIHtLVFBvcnRsZXR9XG4gICAgICovXG4gICAgdGhlLnVwZGF0ZVN0aWNreSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLnVwZGF0ZVN0aWNreSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcG9ydGxldFxuICAgICAqIEByZXR1cm5zIHtLVFBvcnRsZXR9XG4gICAgICovXG4gICAgdGhlLnJlc2V0U3RpY2t5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4ucmVzZXRTdGlja3koKTtcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0aWNreSBwb3J0bGV0XG5cdCAqL1xuXHR0aGUuZGVzdHJveVN0aWNreSA9IGZ1bmN0aW9uKCkge1xuXHRcdFBsdWdpbi5yZXNldFN0aWNreSgpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBQbHVnaW4ub25TY3JvbGxTdGlja3kpO1xuXHR9O1xuXG4gICAgLyoqXG4gICAgICogUmVsb2FkIHBvcnRsZXRcbiAgICAgKiBAcmV0dXJucyB7S1RQb3J0bGV0fVxuICAgICAqL1xuICAgIHRoZS5yZWxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5yZWxvYWQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHBvcnRsZXQgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtLVFBvcnRsZXR9XG4gICAgICovXG4gICAgdGhlLnNldENvbnRlbnQgPSBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uc2V0Q29udGVudChodG1sKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHBvcnRsZXRcbiAgICAgKiBAcmV0dXJucyB7S1RQb3J0bGV0fVxuICAgICAqL1xuICAgIHRoZS50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi50b2dnbGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgcG9ydGxldFxuICAgICAqIEByZXR1cm5zIHtLVFBvcnRsZXR9XG4gICAgICovXG4gICAgdGhlLmNvbGxhcHNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uY29sbGFwc2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhwYW5kIHBvcnRsZXRcbiAgICAgKiBAcmV0dXJucyB7S1RQb3J0bGV0fVxuICAgICAqL1xuICAgIHRoZS5leHBhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5leHBhbmQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVsbHNjcmVlbiBwb3J0bGV0XG4gICAgICogQHJldHVybnMge01Qb3J0bGV0fVxuICAgICAqL1xuICAgIHRoZS5mdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uZnVsbHNjcmVlbignb24nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVsbHNjcmVlbiBwb3J0bGV0XG4gICAgICogQHJldHVybnMge01Qb3J0bGV0fVxuICAgICAqL1xuICAgIHRoZS51bkZ1bGxzY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5mdWxsc2NyZWVuKCdvZmYnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHBvcnRsZXRib2R5XG4gICAgICogQHJldHVybnMge2pRdWVyeX1cbiAgICAgKi9cbiAgICB0aGUuZ2V0Qm9keSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmdldEJvZHkoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHBvcnRsZXRib2R5XG4gICAgICogQHJldHVybnMge2pRdWVyeX1cbiAgICAgKi9cbiAgICB0aGUuZ2V0U2VsZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmdldFNlbGYoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50XG4gICAgICovXG4gICAgdGhlLm9uID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmFkZEV2ZW50KG5hbWUsIGhhbmRsZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnQgdGhhdCB3aWxsIGJlIGZpcmVkIG9uY2VcbiAgICAgKi9cbiAgICB0aGUub25lID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmFkZEV2ZW50KG5hbWUsIGhhbmRsZXIsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBDb25zdHJ1Y3QgcGx1Z2luXG4gICAgUGx1Z2luLmNvbnN0cnVjdC5hcHBseSh0aGUsIFtvcHRpb25zXSk7XG5cbiAgICByZXR1cm4gdGhlO1xufTtcblxuLy8gd2VicGFjayBzdXBwb3J0XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gS1RQb3J0bGV0O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgS1RTY3JvbGx0b3AgPSBmdW5jdGlvbihlbGVtZW50SWQsIG9wdGlvbnMpIHtcbiAgICAvLyBNYWluIG9iamVjdFxuICAgIHZhciB0aGUgPSB0aGlzO1xuICAgIHZhciBpbml0ID0gZmFsc2U7XG5cbiAgICAvLyBHZXQgZWxlbWVudCBvYmplY3RcbiAgICB2YXIgZWxlbWVudCA9IEtUVXRpbC5nZXQoZWxlbWVudElkKTtcbiAgICB2YXIgYm9keSA9IEtUVXRpbC5nZXQoJ2JvZHknKTtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBvZmZzZXQ6IDMwMCxcbiAgICAgICAgc3BlZWQ6IDYwMCxcbiAgICAgICAgdG9nZ2xlQ2xhc3M6ICdzY3JvbGx0b3AtLW9uJ1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gKiogUHJpdmF0ZSBNZXRob2RzICAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBQbHVnaW4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW4gcGx1Z2luXG4gICAgICAgICAqIEByZXR1cm5zIHttc2Nyb2xsdG9wfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoS1RVdGlsLmRhdGEoZWxlbWVudCkuaGFzKCdzY3JvbGx0b3AnKSkge1xuICAgICAgICAgICAgICAgIHRoZSA9IEtUVXRpbC5kYXRhKGVsZW1lbnQpLmdldCgnc2Nyb2xsdG9wJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHNjcm9sbHRvcFxuICAgICAgICAgICAgICAgIFBsdWdpbi5pbml0KG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgc2Nyb2xsdG9wXG4gICAgICAgICAgICAgICAgUGx1Z2luLmJ1aWxkKCk7XG5cbiAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShlbGVtZW50KS5zZXQoJ3Njcm9sbHRvcCcsIHRoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgc3Vic2Nyb2xsdG9wIGNsaWNrIHRvZ2dsZVxuICAgICAgICAgKiBAcmV0dXJucyB7bXNjcm9sbHRvcH1cbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoZS5ldmVudHMgPSBbXTtcblxuICAgICAgICAgICAgLy8gbWVyZ2UgZGVmYXVsdCBhbmQgdXNlciBkZWZpbmVkIG9wdGlvbnNcbiAgICAgICAgICAgIHRoZS5vcHRpb25zID0gS1RVdGlsLmRlZXBFeHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgd2luZG93IHNjcm9sbFxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvaSkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luLmhhbmRsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi5oYW5kbGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi5oYW5kbGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBQbHVnaW4uaGFuZGxlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBidXR0b24gY2xpY2tcbiAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudChlbGVtZW50LCAnY2xpY2snLCBQbHVnaW4uc2Nyb2xsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBzY3JvbGx0b3AgY2xpY2sgc2Nyb2xsVG9wXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHdpbmRvdy5wYWdlWU9mZnNldDsgLy8gY3VycmVudCB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKHBvcyA+IHRoZS5vcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhib2R5LCB0aGUub3B0aW9ucy50b2dnbGVDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhib2R5LCB0aGUub3B0aW9ucy50b2dnbGVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgc2Nyb2xsdG9wIGNsaWNrIHNjcm9sbFRvcFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIEtUVXRpbC5zY3JvbGxUb3AoMCwgdGhlLm9wdGlvbnMuc3BlZWQpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IHRoZS5ldmVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQub25lID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5maXJlZCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZS5ldmVudHNbaV0uZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVyLmNhbGwodGhpcywgdGhlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZXIuY2FsbCh0aGlzLCB0aGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyLCBvbmUpIHtcbiAgICAgICAgICAgIHRoZS5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogb25lLFxuICAgICAgICAgICAgICAgIGZpcmVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyAqKiBQdWJsaWMgTWV0aG9kcyAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICovXG5cbiAgICB0aGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHN1YnNjcm9sbHRvcCBtb2RlXG4gICAgICovXG4gICAgdGhlLm9uID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmFkZEV2ZW50KG5hbWUsIGhhbmRsZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2Nyb2xsdG9wIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7bXNjcm9sbHRvcH1cbiAgICAgKi9cbiAgICB0aGUub25lID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGx1Z2luLmFkZEV2ZW50KG5hbWUsIGhhbmRsZXIsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gKiogUGx1Z2luIENvbnN0cnVjdGlvbiAqKiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8vIFJ1biBwbHVnaW5cbiAgICBQbHVnaW4uY29uc3RydWN0LmFwcGx5KHRoZSwgW29wdGlvbnNdKTtcblxuICAgIC8vIEluaXQgZG9uZVxuICAgIGluaXQgPSB0cnVlO1xuXG4gICAgLy8gUmV0dXJuIHBsdWdpbiBpbnN0YW5jZVxuICAgIHJldHVybiB0aGU7XG59O1xuXG4vLyB3ZWJwYWNrIHN1cHBvcnRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVFNjcm9sbHRvcDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gcGx1Z2luIHNldHVwXHJcbnZhciBLVFRvZ2dsZSA9IGZ1bmN0aW9uKGVsZW1lbnRJZCwgb3B0aW9ucykge1xyXG4gICAgLy8gTWFpbiBvYmplY3RcclxuICAgIHZhciB0aGUgPSB0aGlzO1xyXG4gICAgdmFyIGluaXQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBHZXQgZWxlbWVudCBvYmplY3RcclxuICAgIHZhciBlbGVtZW50ID0gS1RVdGlsLmdldChlbGVtZW50SWQpO1xyXG4gICAgdmFyIGJvZHkgPSBLVFV0aWwuZ2V0KCdib2R5Jyk7ICBcclxuXHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zXHJcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgdG9nZ2xlclN0YXRlOiAnJyxcclxuICAgICAgICB0YXJnZXRTdGF0ZTogJydcclxuICAgIH07ICAgIFxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vICoqIFByaXZhdGUgTWV0aG9kcyAgKiogLy9cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgICB2YXIgUGx1Z2luID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKEtUVXRpbC5kYXRhKGVsZW1lbnQpLmhhcygndG9nZ2xlJykpIHtcclxuICAgICAgICAgICAgICAgIHRoZSA9IEtUVXRpbC5kYXRhKGVsZW1lbnQpLmdldCgndG9nZ2xlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBtZW51XHJcbiAgICAgICAgICAgICAgICBQbHVnaW4uaW5pdChvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBidWlsZCBtZW51XHJcbiAgICAgICAgICAgICAgICBQbHVnaW4uYnVpbGQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShlbGVtZW50KS5zZXQoJ3RvZ2dsZScsIHRoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBzdWJ0b2dnbGUgY2xpY2sgdG9nZ2xlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGUuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoZS5ldmVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1lcmdlIGRlZmF1bHQgYW5kIHVzZXIgZGVmaW5lZCBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoZS5vcHRpb25zID0gS1RVdGlsLmRlZXBFeHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHRoZS50YXJnZXQgPSBLVFV0aWwuZ2V0KHRoZS5vcHRpb25zLnRhcmdldCk7XHJcbiAgICAgICAgICAgIHRoZS50YXJnZXRTdGF0ZSA9IHRoZS5vcHRpb25zLnRhcmdldFN0YXRlO1xyXG4gICAgICAgICAgICB0aGUudG9nZ2xlclN0YXRlID0gdGhlLm9wdGlvbnMudG9nZ2xlclN0YXRlO1xyXG5cclxuICAgICAgICAgICAgdGhlLnN0YXRlID0gS1RVdGlsLmhhc0NsYXNzZXModGhlLnRhcmdldCwgdGhlLnRhcmdldFN0YXRlKSA/ICdvbicgOiAnb2ZmJztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXR1cCB0b2dnbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBidWlsZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIEtUVXRpbC5hZGRFdmVudChlbGVtZW50LCAnbW91c2V1cCcsIFBsdWdpbi50b2dnbGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBvZmZjYW52YXMgY2xpY2sgdG9nZ2xlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ2JlZm9yZVRvZ2dsZScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoZS5zdGF0ZSA9PSAnb2ZmJykge1xyXG4gICAgICAgICAgICAgICAgUGx1Z2luLnRvZ2dsZU9uKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBQbHVnaW4udG9nZ2xlT2ZmKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ2FmdGVyVG9nZ2xlJyk7XHJcblxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgdG9nZ2xlIGNsaWNrIHRvZ2dsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvZ2dsZU9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcignYmVmb3JlT24nKTtcclxuXHJcbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyh0aGUudGFyZ2V0LCB0aGUudGFyZ2V0U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoZS50b2dnbGVyU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhlbGVtZW50LCB0aGUudG9nZ2xlclN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhlLnN0YXRlID0gJ29uJztcclxuXHJcbiAgICAgICAgICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ2FmdGVyT24nKTtcclxuXHJcbiAgICAgICAgICAgIFBsdWdpbi5ldmVudFRyaWdnZXIoJ3RvZ2dsZScpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIHRvZ2dsZSBjbGljayB0b2dnbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b2dnbGVPZmY6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdiZWZvcmVPZmYnKTtcclxuXHJcbiAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyh0aGUudGFyZ2V0LCB0aGUudGFyZ2V0U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoZS50b2dnbGVyU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhlbGVtZW50LCB0aGUudG9nZ2xlclN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhlLnN0YXRlID0gJ29mZic7XHJcblxyXG4gICAgICAgICAgICBQbHVnaW4uZXZlbnRUcmlnZ2VyKCdhZnRlck9mZicpO1xyXG5cclxuICAgICAgICAgICAgUGx1Z2luLmV2ZW50VHJpZ2dlcigndG9nZ2xlJyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhlLmV2ZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubmFtZSA9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9uZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5maXJlZCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlLmV2ZW50c1tpXS5maXJlZCA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZXIuY2FsbCh0aGlzLCB0aGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZXIuY2FsbCh0aGlzLCB0aGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyLCBvbmUpIHtcclxuICAgICAgICAgICAgdGhlLmV2ZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgb25lOiBvbmUsXHJcbiAgICAgICAgICAgICAgICBmaXJlZDogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vICoqIFB1YmxpYyBNZXRob2RzICoqIC8vXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRlZmF1bHQgb3B0aW9ucyBcclxuICAgICAqL1xyXG5cclxuICAgIHRoZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICBkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRvZ2dsZSBzdGF0ZSBcclxuICAgICAqL1xyXG4gICAgdGhlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoZS5zdGF0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGUgXHJcbiAgICAgKi9cclxuICAgIHRoZS50b2dnbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLnRvZ2dsZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZSBvbiBcclxuICAgICAqL1xyXG4gICAgdGhlLnRvZ2dsZU9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFBsdWdpbi50b2dnbGVPbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZSBvZmYgXHJcbiAgICAgKi9cclxuICAgIHRoZS50b2dnbGVPZmYgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLnRvZ2dsZU9mZigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaCBldmVudFxyXG4gICAgICogQHJldHVybnMge0tUVG9nZ2xlfVxyXG4gICAgICovXHJcbiAgICB0aGUub24gPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5hZGRFdmVudChuYW1lLCBoYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggZXZlbnQgdGhhdCB3aWxsIGJlIGZpcmVkIG9uY2VcclxuICAgICAqIEByZXR1cm5zIHtLVFRvZ2dsZX1cclxuICAgICAqL1xyXG4gICAgdGhlLm9uZSA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLmFkZEV2ZW50KG5hbWUsIGhhbmRsZXIsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgcGx1Z2luXHJcbiAgICBQbHVnaW4uY29uc3RydWN0LmFwcGx5KHRoZSwgW29wdGlvbnNdKTtcclxuXHJcbiAgICByZXR1cm4gdGhlO1xyXG59O1xyXG5cclxuLy8gd2VicGFjayBzdXBwb3J0XHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEtUVG9nZ2xlO1xyXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjbGFzcyBLVFV0aWwgIGJhc2UgdXRpbGl6ZSBjbGFzcyB0aGF0IHByaXZpZGVzIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuXG4vLyBQb2x5ZmlsbHNcbi8qKlxuICogRWxlbWVudC5tYXRjaGVzKCkgcG9seWZpbGwgKHNpbXBsZSB2ZXJzaW9uKVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlcyNQb2x5ZmlsbFxuICovXG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcblx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuLyoqXG4gKiBFbGVtZW50LmNsb3Nlc3QoKSBwb2x5ZmlsbFxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdCNQb2x5ZmlsbFxuICovXG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QpIHtcblx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG5cdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcblx0fVxuXHRFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKHMpIHtcblx0XHR2YXIgZWwgPSB0aGlzO1xuXHRcdHZhciBhbmNlc3RvciA9IHRoaXM7XG5cdFx0aWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSByZXR1cm4gbnVsbDtcblx0XHRkbyB7XG5cdFx0XHRpZiAoYW5jZXN0b3IubWF0Y2hlcyhzKSkgcmV0dXJuIGFuY2VzdG9yO1xuXHRcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnRFbGVtZW50O1xuXHRcdH0gd2hpbGUgKGFuY2VzdG9yICE9PSBudWxsKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcbn1cblxuLyoqXG4gKiBDaGlsZE5vZGUucmVtb3ZlKCkgcG9seWZpbGxcbiAqIGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbS9yZW1vdmluZy1hbi1lbGVtZW50LWZyb20tdGhlLWRvbS10aGUtZXM2LXdheS9cbiAqIEBhdXRob3IgQ2hyaXMgRmVyZGluYW5kaVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbihmdW5jdGlvbiAoZWxlbSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0ubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIXdpbmRvd1tlbGVtW2ldXSB8fCAncmVtb3ZlJyBpbiB3aW5kb3dbZWxlbVtpXV0ucHJvdG90eXBlKSBjb250aW51ZTtcblx0XHR3aW5kb3dbZWxlbVtpXV0ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcblx0XHR9O1xuXHR9XG59KShbJ0VsZW1lbnQnLCAnQ2hhcmFjdGVyRGF0YScsICdEb2N1bWVudFR5cGUnXSk7XG5cbi8vXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLlxuLy8gIFdpdGggZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuLy9cbi8vICBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuLy8gIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbi8vXG4vLyAgTUlUIGxpY2Vuc2Vcbi8vXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH07XG5cbiAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSlcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH07XG59KCkpO1xuXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2Vyei9qc19waWVjZS9ibG9iL21hc3Rlci9ET00vUGFyZW50Tm9kZS9wcmVwZW5kKCkvcHJlcGVuZCgpLm1kXG4oZnVuY3Rpb24oYXJyKSB7XG4gICAgYXJyLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eSgncHJlcGVuZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW0sICdwcmVwZW5kJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgICAgICBhcmdBcnIuZm9yRWFjaChmdW5jdGlvbihhcmdJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05vZGUgPSBhcmdJdGVtIGluc3RhbmNlb2YgTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZG9jRnJhZy5hcHBlbmRDaGlsZChpc05vZGUgPyBhcmdJdGVtIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGFyZ0l0ZW0pKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShkb2NGcmFnLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0pKFtFbGVtZW50LnByb3RvdHlwZSwgRG9jdW1lbnQucHJvdG90eXBlLCBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZV0pO1xuXG4vLyBHbG9iYWwgdmFyaWFibGVzXG53aW5kb3cuS1RVdGlsRWxlbWVudERhdGFTdG9yZSA9IHt9O1xud2luZG93LktUVXRpbEVsZW1lbnREYXRhU3RvcmVJRCA9IDA7XG53aW5kb3cuS1RVdGlsRGVsZWdhdGVkRXZlbnRIYW5kbGVycyA9IHt9O1xuXG52YXIgS1RVdGlsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc2l6ZUhhbmRsZXJzID0gW107XG5cbiAgICAvKiogQHR5cGUge29iamVjdH0gYnJlYWtwb2ludHMgVGhlIGRldmljZSB3aWR0aCBicmVha3BvaW50cyAqKi9cbiAgICB2YXIgYnJlYWtwb2ludHMgPSB7XG4gICAgICAgIHNtOiA1NDQsIC8vIFNtYWxsIHNjcmVlbiAvIHBob25lXG4gICAgICAgIG1kOiA3NjgsIC8vIE1lZGl1bSBzY3JlZW4gLyB0YWJsZXRcbiAgICAgICAgbGc6IDEwMjQsIC8vIExhcmdlIHNjcmVlbiAvIGRlc2t0b3BcbiAgICAgICAgeGw6IDEyMDAgLy8gRXh0cmEgbGFyZ2Ugc2NyZWVuIC8gd2lkZSBkZXNrdG9wXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aW5kb3cgcmVzaXplIGV2ZW50IHdpdGggc29tZVxuICAgICAqIGRlbGF5IHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyB1cG9uIHJlc2l6ZSBjb21wbGV0ZVxuICAgICAqL1xuICAgIHZhciBfd2luZG93UmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3J1blJlc2l6ZUhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZWluaXRpYWxpemUgb3RoZXIgc3Vic2NyaWJlZCBlbGVtZW50c1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNpemVIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlYWNoID0gcmVzaXplSGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgZWFjaC5jYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRpbWVvdXQgPSBmYWxzZTsgLy8gaG9sZGVyIGZvciB0aW1lb3V0IGlkXG4gICAgICAgIHZhciBkZWxheSA9IDI1MDsgLy8gZGVsYXkgYWZ0ZXIgZXZlbnQgaXMgXCJjb21wbGV0ZVwiIHRvIHJ1biBjYWxsYmFja1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9ydW5SZXNpemVIYW5kbGVycygpO1xuICAgICAgICAgICAgfSwgZGVsYXkpOyAvLyB3YWl0IDUwbXMgdW50aWwgd2luZG93IHJlc2l6ZSBmaW5pc2hlcy5cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGFzcyBtYWluIGluaXRpYWxpemVyLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5cbiAgICAgICAgICogQHJldHVybnMgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgLy9tYWluIGZ1bmN0aW9uIHRvIGluaXRpYXRlIHRoZSB0aGVtZVxuICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtwb2ludHMgPSBvcHRpb25zLmJyZWFrcG9pbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfd2luZG93UmVzaXplSGFuZGxlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHdpbmRvdyByZXNpemUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBhZGRSZXNpemVIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzaXplSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgd2luZG93IHJlc2l6ZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6ZUhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09PSByZXNpemVIYW5kbGVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzaXplSGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIHdpbmRvdyByZXNpemUgaGFuZGxlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBydW5SZXNpemVIYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfcnVuUmVzaXplSGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihFdmVudCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3Jlc2l6ZScpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIElFIGFuZCBvdGhlciBvbGQgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAvLyBjYXVzZXMgZGVwcmVjYXRpb24gd2FybmluZyBvbiBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB2YXIgZXZ0ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KCdVSUV2ZW50cycpO1xuICAgICAgICAgICAgICAgIGV2dC5pbml0VUlFdmVudCgncmVzaXplJywgdHJ1ZSwgZmFsc2UsIHdpbmRvdywgMCk7XG4gICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IEdFVCBwYXJhbWV0ZXIgdmFsdWUgZnJvbSBVUkwuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgUGFyYW1ldGVyIG5hbWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRVUkxQYXJhbTogZnVuY3Rpb24ocGFyYW1OYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoU3RyaW5nID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgaSwgdmFsLCBwYXJhbXMgPSBzZWFyY2hTdHJpbmcuc3BsaXQoXCImXCIpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gcGFyYW1zW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsWzBdID09IHBhcmFtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5lc2NhcGUodmFsWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBjdXJyZW50IGRldmljZSBpcyBtb2JpbGUgdG91Y2guXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNNb2JpbGVEZXZpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdldFZpZXdQb3J0KCkud2lkdGggPCB0aGlzLmdldEJyZWFrcG9pbnQoJ2xnJykgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBjdXJyZW50IGRldmljZSBpcyBkZXNrdG9wLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzRGVza3RvcERldmljZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gS1RVdGlsLmlzTW9iaWxlRGV2aWNlKCkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYnJvd3NlciB3aW5kb3cgdmlld3BvcnQgc2l6ZS4gUmVmOlxuICAgICAgICAgKiBodHRwOi8vYW5keWxhbmd0b24uY28udWsvYXJ0aWNsZXMvamF2YXNjcmlwdC9nZXQtdmlld3BvcnQtc2l6ZS1qYXZhc2NyaXB0L1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld1BvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB3aW5kb3csXG4gICAgICAgICAgICAgICAgYSA9ICdpbm5lcic7XG4gICAgICAgICAgICBpZiAoISgnaW5uZXJXaWR0aCcgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgICAgIGEgPSAnY2xpZW50JztcbiAgICAgICAgICAgICAgICBlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGVbYSArICdXaWR0aCddLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZVthICsgJ0hlaWdodCddXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBnaXZlbiBkZXZpY2UgbW9kZSBpcyBjdXJyZW50bHkgYWN0aXZhdGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSBSZXNwb25zaXZlIG1vZGUgbmFtZShlLmc6IGRlc2t0b3AsXG4gICAgICAgICAqICAgICBkZXNrdG9wLWFuZC10YWJsZXQsIHRhYmxldCwgdGFibGV0LWFuZC1tb2JpbGUsIG1vYmlsZSlcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0luUmVzcG9uc2l2ZVJhbmdlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICB2YXIgYnJlYWtwb2ludCA9IHRoaXMuZ2V0Vmlld1BvcnQoKS53aWR0aDtcblxuICAgICAgICAgICAgaWYgKG1vZGUgPT0gJ2dlbmVyYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ2Rlc2t0b3AnICYmIGJyZWFrcG9pbnQgPj0gKHRoaXMuZ2V0QnJlYWtwb2ludCgnbGcnKSArIDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ3RhYmxldCcgJiYgKGJyZWFrcG9pbnQgPj0gKHRoaXMuZ2V0QnJlYWtwb2ludCgnbWQnKSArIDEpICYmIGJyZWFrcG9pbnQgPCB0aGlzLmdldEJyZWFrcG9pbnQoJ2xnJykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ21vYmlsZScgJiYgYnJlYWtwb2ludCA8PSB0aGlzLmdldEJyZWFrcG9pbnQoJ21kJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnZGVza3RvcC1hbmQtdGFibGV0JyAmJiBicmVha3BvaW50ID49ICh0aGlzLmdldEJyZWFrcG9pbnQoJ21kJykgKyAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09ICd0YWJsZXQtYW5kLW1vYmlsZScgJiYgYnJlYWtwb2ludCA8PSB0aGlzLmdldEJyZWFrcG9pbnQoJ2xnJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnbWluaW1hbC1kZXNrdG9wLWFuZC1iZWxvdycgJiYgYnJlYWtwb2ludCA8PSB0aGlzLmdldEJyZWFrcG9pbnQoJ3hsJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgdW5pcXVlIElEIGZvciBnaXZlIHByZWZpeC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBQcmVmaXggZm9yIGdlbmVyYXRlZCBJRFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFVuaXF1ZUlEOiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB3aW5kb3cgd2lkdGggZm9yIGdpdmUgYnJlYWtwb2ludCBtb2RlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSBSZXNwb25zaXZlIG1vZGUgbmFtZShlLmc6IHhsLCBsZywgbWQsIHNtKVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QnJlYWtwb2ludDogZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRzW21vZGVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBvYmplY3QgaGFzIHByb3BlcnR5IG1hdGNocyBnaXZlbiBrZXkgcGF0aC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgY29udGFpbnMgdmFsdWVzIHBhaXJlZCB3aXRoIGdpdmVuIGtleSBwYXRoXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlzIEtleXMgcGF0aCBzZXBlcmF0ZWQgd2l0aCBkb3RzXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBpc3NldDogZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgICAgICAgICB2YXIgc3RvbmU7XG5cbiAgICAgICAgICAgIGtleXMgPSBrZXlzIHx8ICcnO1xuXG4gICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKCdbJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvYmplY3QgcGF0aCBub3RhdGlvbi4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5cyA9IGtleXMuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RvbmUgPSBrZXlzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShzdG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iaiA9IG9ialtzdG9uZV07XG5cbiAgICAgICAgICAgIH0gd2hpbGUgKGtleXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgaGlnaGVzdCB6LWluZGV4IG9mIHRoZSBnaXZlbiBlbGVtZW50IHBhcmVudHNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGVsIGpRdWVyeSBlbGVtZW50IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGlnaGVzdFppbmRleDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gS1RVdGlsLmdldChlbCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sIHZhbHVlO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWxlbSAmJiBlbGVtICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbiBjb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xuICAgICAgICAgICAgICAgIC8vIFdlYktpdCBhbHdheXMgcmV0dXJucyBhdXRvIGlmIHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IEtUVXRpbC5jc3MoZWxlbSwgJ3Bvc2l0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgcmV0dXJucyAwIHdoZW4gekluZGV4IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG4gICAgICAgICAgICAgICAgICAgIC8vIDxkaXYgc3R5bGU9XCJ6LWluZGV4OiAtMTA7XCI+PGRpdiBzdHlsZT1cInotaW5kZXg6IDA7XCI+PC9kaXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoS1RVdGlsLmNzcyhlbGVtLCAnei1pbmRleCcpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyBhbnkgcGFyZW50IHdpdGggZml4ZWQgcG9zaXRpb25mcmVnXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCBqUXVlcnkgZWxlbWVudCBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb247XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IEtUVXRpbC5jc3MoZWwsICdwb3NpdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbXVsYXRlcyBkZWxheVxuICAgICAgICAgKi9cbiAgICAgICAgc2xlZXA6IGZ1bmN0aW9uKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDFlNzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KSA+IG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgcmFuZG9tbHkgZ2VuZXJhdGVkIGludGVnZXIgdmFsdWUgd2l0aGluIGdpdmVuIG1pbiBhbmQgbWF4IHJhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gUmFuZ2Ugc3RhcnQgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBSYW5nZSBlbmQgdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhbmRvbUludDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBBbmd1bGFyIGxpYnJhcnkgaXMgaW5jbHVkZWRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0FuZ3VsYXJWZXJzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuWm9uZSAhPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGpRdWVyeSBXb3JrYXJvdW5kc1xuXG4gICAgICAgIC8vIERlZXAgZXh0ZW5kOiAgJC5leHRlbmQodHJ1ZSwge30sIG9iakEsIG9iakIpO1xuICAgICAgICBkZWVwRXh0ZW5kOiBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gS1RVdGlsLmRlZXBFeHRlbmQob3V0W2tleV0sIG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGV4dGVuZDogICQuZXh0ZW5kKHt9LCBvYmpBLCBvYmpCKTtcbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBlbDtcblxuICAgICAgICAgICAgaWYgKHF1ZXJ5ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEhKHF1ZXJ5ICYmIHF1ZXJ5Lm5vZGVUeXBlID09PSAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbFswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QnlJRDogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIGlmICghIShxdWVyeSAmJiBxdWVyeS5ub2RlVHlwZSA9PT0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChxdWVyeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QnlUYWc6IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgZWw7XG5cbiAgICAgICAgICAgIGlmIChlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QnlDbGFzczogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBlbDtcblxuICAgICAgICAgICAgaWYgKGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShxdWVyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgZ2l2ZW4gY2xhc3Nlc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZWwgalF1ZXJ5IGVsZW1lbnQgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBDbGFzc2VzIHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhc0NsYXNzZXM6IGZ1bmN0aW9uKGVsLCBjbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xhc3Nlc0FyciA9IGNsYXNzZXMuc3BsaXQoXCIgXCIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoS1RVdGlsLmhhc0NsYXNzKGVsLCBLVFV0aWwudHJpbShjbGFzc2VzQXJyW2ldKSkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QgPyBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSA6IG5ldyBSZWdFeHAoJ1xcXFxiJyArIGNsYXNzTmFtZSArICdcXFxcYicpLnRlc3QoZWwuY2xhc3NOYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFlbCB8fCB0eXBlb2YgY2xhc3NOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lc1tpXSAmJiBjbGFzc05hbWVzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoS1RVdGlsLnRyaW0oY2xhc3NOYW1lc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghS1RVdGlsLmhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjbGFzc05hbWVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBLVFV0aWwudHJpbShjbGFzc05hbWVzW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICBpZiAoIWVsIHx8IHR5cGVvZiBjbGFzc05hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoS1RVdGlsLnRyaW0oY2xhc3NOYW1lc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoS1RVdGlsLmhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjbGFzc05hbWVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxiJyArIEtUVXRpbC50cmltKGNsYXNzTmFtZXNbeF0pICsgJ1xcXFxiJywgJ2cnKSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmlnZ2VyQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKGVsLCBldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBldmVudDtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXJFdmVudDogZnVuY3Rpb24obm9kZSwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgdXNlIHRoZSBvd25lckRvY3VtZW50IGZyb20gdGhlIHByb3ZpZGVkIG5vZGUgdG8gYXZvaWQgY3Jvc3Mtd2luZG93IHByb2JsZW1zXG4gICAgICAgICAgICB2YXIgZG9jO1xuICAgICAgICAgICAgaWYgKG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG5vZGUgbWF5IGJlIHRoZSBkb2N1bWVudCBpdHNlbGYsIG5vZGVUeXBlIDkgPSBET0NVTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgZG9jID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub2RlIHBhc3NlZCB0byBmaXJlRXZlbnQ6IFwiICsgbm9kZS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBHZWNrby1zdHlsZSBhcHByb2FjaCAobm93IHRoZSBzdGFuZGFyZCkgdGFrZXMgbW9yZSB3b3JrXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50Q2xhc3MgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gRGlmZmVyZW50IGV2ZW50cyBoYXZlIGRpZmZlcmVudCBldmVudCBjbGFzc2VzLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgc3dpdGNoIHN0YXRlbWVudCBjYW4ndCBtYXAgYW4gZXZlbnROYW1lIHRvIGFuIGV2ZW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV2ZW50IGZpcmluZyBpcyBnb2luZyB0byBmYWlsLlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsaWNrXCI6IC8vIERpc3BhdGNoaW5nIG9mICdjbGljaycgYXBwZWFycyB0byBub3Qgd29yayBjb3JyZWN0bHkgaW4gU2FmYXJpLiBVc2UgJ21vdXNlZG93bicgb3IgJ21vdXNldXAnIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlZW50ZXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibW91c2VsZWF2ZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICAgICAgICAgICAgICBldmVudENsYXNzID0gXCJNb3VzZUV2ZW50c1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGFuZ2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbGFzcyA9IFwiSFRNTEV2ZW50c1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiZmlyZUV2ZW50OiBDb3VsZG4ndCBmaW5kIGFuIGV2ZW50IGNsYXNzIGZvciBldmVudCAnXCIgKyBldmVudE5hbWUgKyBcIicuXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnQoZXZlbnRDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYnViYmxlcyA9IGV2ZW50TmFtZSA9PSBcImNoYW5nZVwiID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudChldmVudE5hbWUsIGJ1YmJsZXMsIHRydWUpOyAvLyBBbGwgZXZlbnRzIGNyZWF0ZWQgYXMgYnViYmxpbmcgYW5kIGNhbmNlbGFibGUuXG5cbiAgICAgICAgICAgICAgICBldmVudC5zeW50aGV0aWMgPSB0cnVlOyAvLyBhbGxvdyBkZXRlY3Rpb24gb2Ygc3ludGhldGljIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIHNheXMgZ28gYWhlYWQgd2l0aCB0aGUgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmZpcmVFdmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElFLW9sZCBzY2hvb2wgc3R5bGVcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zeW50aGV0aWMgPSB0cnVlOyAvLyBhbGxvdyBkZXRlY3Rpb24gb2Ygc3ludGhldGljIGV2ZW50c1xuICAgICAgICAgICAgICAgIG5vZGUuZmlyZUV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiggZWxtICl7XG4gICAgICAgICAgICBlbG0gPSBLVFV0aWwuZ2V0KGVsbSk7XG4gICAgICAgICAgICB2YXIgYyA9IGVsbS5wYXJlbnROb2RlLmNoaWxkcmVuLCBpID0gMDtcbiAgICAgICAgICAgIGZvcig7IGkgPCBjLmxlbmd0aDsgaSsrIClcbiAgICAgICAgICAgICAgICBpZiggY1tpXSA9PSBlbG0gKSByZXR1cm4gaTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmltOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcudHJpbSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50VHJpZ2dlcmVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmRhdGFzZXQudHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5kYXRhc2V0LnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kOiBmdW5jdGlvbihwYXJlbnQsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBLVFV0aWwuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kQWxsOiBmdW5jdGlvbihwYXJlbnQsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBLVFV0aWwuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24oZWwsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbihlbGVtLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gRWxlbWVudC5tYXRjaGVzKCkgcG9seWZpbGxcbiAgICAgICAgICAgIGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPVxuICAgICAgICAgICAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdXAgYSBwYXJlbnQgYXJyYXlcbiAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICAgICAgICAgIC8vIFB1c2ggZWFjaCBwYXJlbnQgZWxlbWVudCB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIGZvciAoIDsgZWxlbSAmJiBlbGVtICE9PSBkb2N1bWVudDsgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gb3VyIHBhcmVudCBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uKGVsLCBzZWxlY3RvciwgbG9nKSB7XG4gICAgICAgICAgICBpZiAoIWVsIHx8ICFlbC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbCA9IGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgPT0gMSAmJiBLVFV0aWwubWF0Y2hlcyhlbC5jaGlsZE5vZGVzW2ldLCBzZWxlY3RvciwgbG9nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hpbGQ6IGZ1bmN0aW9uKGVsLCBzZWxlY3RvciwgbG9nKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBLVFV0aWwuY2hpbGRyZW4oZWwsIHNlbGVjdG9yLCBsb2cpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF0Y2hlczogZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCBsb2cpIHtcbiAgICAgICAgICAgIHZhciBwID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgZiA9IHAubWF0Y2hlcyB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW10uaW5kZXhPZi5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocyksIHRoaXMpICE9PSAtMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYuY2FsbChlbCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IEtUVXRpbC5nZXQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmN1c3RvbURhdGFUYWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LktUVXRpbEVsZW1lbnREYXRhU3RvcmVJRCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jdXN0b21EYXRhVGFnID0gd2luZG93LktUVXRpbEVsZW1lbnREYXRhU3RvcmVJRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuS1RVdGlsRWxlbWVudERhdGFTdG9yZVtlbGVtZW50LmN1c3RvbURhdGFUYWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5LVFV0aWxFbGVtZW50RGF0YVN0b3JlW2VsZW1lbnQuY3VzdG9tRGF0YVRhZ10gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5LVFV0aWxFbGVtZW50RGF0YVN0b3JlW2VsZW1lbnQuY3VzdG9tRGF0YVRhZ11bbmFtZV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY3VzdG9tRGF0YVRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHdpbmRvdy5LVFV0aWxFbGVtZW50RGF0YVN0b3JlW2VsZW1lbnQuY3VzdG9tRGF0YVRhZ11bbmFtZV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY3VzdG9tRGF0YVRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHdpbmRvdy5LVFV0aWxFbGVtZW50RGF0YVN0b3JlW2VsZW1lbnQuY3VzdG9tRGF0YVRhZ10gJiYgd2luZG93LktUVXRpbEVsZW1lbnREYXRhU3RvcmVbZWxlbWVudC5jdXN0b21EYXRhVGFnXVtuYW1lXSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5LVFV0aWxFbGVtZW50RGF0YVN0b3JlW2VsZW1lbnQuY3VzdG9tRGF0YVRhZ11bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG91dGVyV2lkdGg6IGZ1bmN0aW9uKGVsLCBtYXJnaW4pIHtcbiAgICAgICAgICAgIHZhciB3aWR0aDtcblxuICAgICAgICAgICAgaWYgKG1hcmdpbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VGbG9hdChlbC5vZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgICAgd2lkdGggKz0gcGFyc2VGbG9hdChLVFV0aWwuY3NzKGVsLCAnbWFyZ2luLWxlZnQnKSkgKyBwYXJzZUZsb2F0KEtUVXRpbC5jc3MoZWwsICdtYXJnaW4tcmlnaHQnKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh3aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VGbG9hdChlbC5vZmZzZXRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCwgd2luO1xuICAgICAgICAgICAgZWxlbSA9IEtUVXRpbC5nZXQoZWxlbSk7XG5cbiAgICAgICAgICAgIGlmICggIWVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuICAgICAgICAgICAgLy8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cbiAgICAgICAgICAgIGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1JcbiAgICAgICAgICAgIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgd2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhlaWdodDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBLVFV0aWwuY3NzKGVsLCAnaGVpZ2h0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhKGVsLm9mZnNldFdpZHRoID09PSAwICYmIGVsLm9mZnNldEhlaWdodCA9PT0gMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cjogZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBlbCA9IEtUVXRpbC5nZXQoZWwpO1xuXG4gICAgICAgICAgICBpZiAoZWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQXR0cjogZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICAgICAgICAgIGVsID0gS1RVdGlsLmdldChlbCk7XG5cbiAgICAgICAgICAgIGlmIChlbCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICAgICAgICAgIGVsID0gS1RVdGlsLmdldChlbCk7XG5cbiAgICAgICAgICAgIGlmIChlbCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbihmcm9tLCB0bywgZHVyYXRpb24sIHVwZGF0ZSwgZWFzaW5nLCBkb25lKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRpbnlBbmltYXRlLmVhc2luZ3NcbiAgICAgICAgICAgICAqICBBZGFwdGVkIGZyb20galF1ZXJ5IEVhc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZWFzaW5ncyA9IHt9O1xuICAgICAgICAgICAgdmFyIGVhc2luZztcblxuICAgICAgICAgICAgZWFzaW5ncy5saW5lYXIgPSBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiB0IC8gZCArIGI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlYXNpbmcgPSBlYXNpbmdzLmxpbmVhcjtcblxuICAgICAgICAgICAgLy8gRWFybHkgYmFpbCBvdXQgaWYgY2FsbGVkIGluY29ycmVjdGx5XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRvICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBkdXJhdGlvbiAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdXBkYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbW9jayBkb25lKCkgZnVuY3Rpb24gaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGljayBpbXBsZW1lbnRhdGlvbiAocmVxdWVzdEFuaW1hdGlvbkZyYW1lIHwgc2V0VGltZW91dClcbiAgICAgICAgICAgIHZhciByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA1MCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBBbmltYXRpb24gbG9vcFxuICAgICAgICAgICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gdG8gLSBmcm9tO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gKHRpbWVzdGFtcCB8fCArbmV3IERhdGUoKSkgLSBzdGFydDtcblxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKGVhc2luZyh0aW1lLCBmcm9tLCBjaGFuZ2UsIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IDAgJiYgdGltZSA+PSBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUodG8pO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgckFGKGxvb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlKGZyb20pO1xuXG4gICAgICAgICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiArbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgckFGKGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFjdHVhbENzczogZnVuY3Rpb24oZWwsIHByb3AsIGNhY2hlKSB7XG4gICAgICAgICAgICBlbCA9IEtUVXRpbC5nZXQoZWwpO1xuICAgICAgICAgICAgdmFyIGNzcyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZWwuZ2V0QXR0cmlidXRlKCdoaWRkZW4tJyArIHByb3ApIHx8IGNhY2hlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBzbzpcbiAgICAgICAgICAgICAgICAvLyBtYWtpbmcgdGhlIGVsIGJsb2NrIHNvIHdlIGNhbiBtZWFzc3VyZSBpdHMgaGVpZ2h0IGJ1dCBzdGlsbCBiZSBoaWRkZW5cbiAgICAgICAgICAgICAgICBjc3MgPSBlbC5zdHlsZS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB2aXNpYmlsaXR5OiBoaWRkZW47IGRpc3BsYXk6IGJsb2NrOyc7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PSAnd2lkdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBjc3M7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBpdCBpbiBjYWNoZVxuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaGlkZGVuLScgKyBwcm9wLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIGl0IGluIGNhY2hlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZWwuZ2V0QXR0cmlidXRlKCdoaWRkZW4tJyArIHByb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhY3R1YWxIZWlnaHQ6IGZ1bmN0aW9uKGVsLCBjYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIEtUVXRpbC5hY3R1YWxDc3MoZWwsICdoZWlnaHQnLCBjYWNoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWN0dWFsV2lkdGg6IGZ1bmN0aW9uKGVsLCBjYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIEtUVXRpbC5hY3R1YWxDc3MoZWwsICd3aWR0aCcsIGNhY2hlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTY3JvbGw6IGZ1bmN0aW9uKGVsZW1lbnQsIG1ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIHBhc3NlZCBpbiBgbWV0aG9kYCB2YWx1ZSBzaG91bGQgYmUgJ1RvcCcgb3IgJ0xlZnQnXG4gICAgICAgICAgICBtZXRob2QgPSAnc2Nyb2xsJyArIG1ldGhvZDtcbiAgICAgICAgICAgIHJldHVybiAoZWxlbWVudCA9PSB3aW5kb3cgfHwgZWxlbWVudCA9PSBkb2N1bWVudCkgPyAoXG4gICAgICAgICAgICAgICAgc2VsZlsobWV0aG9kID09ICdzY3JvbGxUb3AnKSA/ICdwYWdlWU9mZnNldCcgOiAncGFnZVhPZmZzZXQnXSB8fFxuICAgICAgICAgICAgICAgIChicm93c2VyU3VwcG9ydHNCb3hNb2RlbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbbWV0aG9kXSkgfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5W21ldGhvZF1cbiAgICAgICAgICAgICkgOiBlbGVtZW50W21ldGhvZF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3NzOiBmdW5jdGlvbihlbCwgc3R5bGVQcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgZWwgPSBLVFV0aWwuZ2V0KGVsKTtcblxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtzdHlsZVByb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VmlldyA9IChlbC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5kZWZhdWx0VmlldztcbiAgICAgICAgICAgICAgICAvLyBXM0Mgc3RhbmRhcmQgd2F5OlxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VmlldyAmJiBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIHByb3BlcnR5IG5hbWUgdG8gY3NzIG5vdGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIChoeXBoZW4gc2VwYXJhdGVkIHdvcmRzIGVnLiBmb250LVNpemUpXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcCA9IHN0eWxlUHJvcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHsgLy8gSUVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2FuaXRpemUgcHJvcGVydHkgbmFtZSB0byBjYW1lbENhc2VcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wID0gc3R5bGVQcm9wLnJlcGxhY2UoL1xcLShcXHcpL2csIGZ1bmN0aW9uKHN0ciwgbGV0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsLmN1cnJlbnRTdHlsZVtzdHlsZVByb3BdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IG90aGVyIHVuaXRzIHRvIHBpeGVscyBvbiBJRVxuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXGQrKGVtfHB0fCV8ZXgpPyQvaS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRMZWZ0ID0gZWwuc3R5bGUubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkUnNMZWZ0ID0gZWwucnVudGltZVN0eWxlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucnVudGltZVN0eWxlLmxlZnQgPSBlbC5jdXJyZW50U3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gdmFsdWUgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsLnN0eWxlLnBpeGVsTGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gb2xkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5ydW50aW1lU3R5bGUubGVmdCA9IG9sZFJzTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzbGlkZTogZnVuY3Rpb24oZWwsIGRpciwgc3BlZWQsIGNhbGxiYWNrLCByZWNhbGNNYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICghZWwgfHwgKGRpciA9PSAndXAnICYmIEtUVXRpbC52aXNpYmxlKGVsKSA9PT0gZmFsc2UpIHx8IChkaXIgPT0gJ2Rvd24nICYmIEtUVXRpbC52aXNpYmxlKGVsKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNwZWVkID0gKHNwZWVkID8gc3BlZWQgOiA2MDApO1xuICAgICAgICAgICAgdmFyIGNhbGNIZWlnaHQgPSBLVFV0aWwuYWN0dWFsSGVpZ2h0KGVsKTtcbiAgICAgICAgICAgIHZhciBjYWxjUGFkZGluZ1RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNhbGNQYWRkaW5nQm90dG9tID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChLVFV0aWwuY3NzKGVsLCAncGFkZGluZy10b3AnKSAmJiBLVFV0aWwuZGF0YShlbCkuaGFzKCdzbGlkZS1wYWRkaW5nLXRvcCcpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEoZWwpLnNldCgnc2xpZGUtcGFkZGluZy10b3AnLCBLVFV0aWwuY3NzKGVsLCAncGFkZGluZy10b3AnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChLVFV0aWwuY3NzKGVsLCAncGFkZGluZy1ib3R0b20nKSAmJiBLVFV0aWwuZGF0YShlbCkuaGFzKCdzbGlkZS1wYWRkaW5nLWJvdHRvbScpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmRhdGEoZWwpLnNldCgnc2xpZGUtcGFkZGluZy1ib3R0b20nLCBLVFV0aWwuY3NzKGVsLCAncGFkZGluZy1ib3R0b20nKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChLVFV0aWwuZGF0YShlbCkuaGFzKCdzbGlkZS1wYWRkaW5nLXRvcCcpKSB7XG4gICAgICAgICAgICAgICAgY2FsY1BhZGRpbmdUb3AgPSBwYXJzZUludChLVFV0aWwuZGF0YShlbCkuZ2V0KCdzbGlkZS1wYWRkaW5nLXRvcCcpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEtUVXRpbC5kYXRhKGVsKS5oYXMoJ3NsaWRlLXBhZGRpbmctYm90dG9tJykpIHtcbiAgICAgICAgICAgICAgICBjYWxjUGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KEtUVXRpbC5kYXRhKGVsKS5nZXQoJ3NsaWRlLXBhZGRpbmctYm90dG9tJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlyID09ICd1cCcpIHsgLy8gdXBcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6IGJsb2NrOyBvdmVyZmxvdzogaGlkZGVuOyc7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsY1BhZGRpbmdUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFuaW1hdGUoMCwgY2FsY1BhZGRpbmdUb3AsIHNwZWVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9IChjYWxjUGFkZGluZ1RvcCAtIHZhbHVlKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH0sICdsaW5lYXInKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsY1BhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFuaW1hdGUoMCwgY2FsY1BhZGRpbmdCb3R0b20sIHNwZWVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9IChjYWxjUGFkZGluZ0JvdHRvbSAtIHZhbHVlKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH0sICdsaW5lYXInKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBLVFV0aWwuYW5pbWF0ZSgwLCBjYWxjSGVpZ2h0LCBzcGVlZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gKGNhbGNIZWlnaHQgLSB2YWx1ZSkgKyAncHgnO1xuICAgICAgICAgICAgICAgIH0sICdsaW5lYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXIgPT0gJ2Rvd24nKSB7IC8vIGRvd25cbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6IGJsb2NrOyBvdmVyZmxvdzogaGlkZGVuOyc7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsY1BhZGRpbmdUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFuaW1hdGUoMCwgY2FsY1BhZGRpbmdUb3AsIHNwZWVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9IHZhbHVlICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfSwgJ2xpbmVhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsY1BhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFuaW1hdGUoMCwgY2FsY1BhZGRpbmdCb3R0b20sIHNwZWVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHZhbHVlICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfSwgJ2xpbmVhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBLVFV0aWwuYW5pbWF0ZSgwLCBjYWxjSGVpZ2h0LCBzcGVlZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgICAgIH0sICdsaW5lYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzbGlkZVVwOiBmdW5jdGlvbihlbCwgc3BlZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBLVFV0aWwuc2xpZGUoZWwsICd1cCcsIHNwZWVkLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2xpZGVEb3duOiBmdW5jdGlvbihlbCwgc3BlZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBLVFV0aWwuc2xpZGUoZWwsICdkb3duJywgc3BlZWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbihlbCwgZGlzcGxheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gKGRpc3BsYXkgPyBkaXNwbGF5IDogJ2Jsb2NrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRFdmVudDogZnVuY3Rpb24oZWwsIHR5cGUsIGhhbmRsZXIsIG9uZSkge1xuICAgICAgICAgICAgZWwgPSBLVFV0aWwuZ2V0KGVsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVFdmVudDogZnVuY3Rpb24oZWwsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVsID0gS1RVdGlsLmdldChlbCk7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uOiBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3RvciwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBldmVudElkID0gS1RVdGlsLmdldFVuaXF1ZUlEKCdldmVudCcpO1xuXG4gICAgICAgICAgICB3aW5kb3cuS1RVdGlsRGVsZWdhdGVkRXZlbnRIYW5kbGVyc1tldmVudElkXSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdGFyZ2V0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXQsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLVFV0aWwuYWRkRXZlbnQoZWxlbWVudCwgZXZlbnQsIHdpbmRvdy5LVFV0aWxEZWxlZ2F0ZWRFdmVudEhhbmRsZXJzW2V2ZW50SWRdKTtcblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgZXZlbnRJZCkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICF3aW5kb3cuS1RVdGlsRGVsZWdhdGVkRXZlbnRIYW5kbGVyc1tldmVudElkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS1RVdGlsLnJlbW92ZUV2ZW50KGVsZW1lbnQsIGV2ZW50LCB3aW5kb3cuS1RVdGlsRGVsZWdhdGVkRXZlbnRIYW5kbGVyc1tldmVudElkXSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuS1RVdGlsRGVsZWdhdGVkRXZlbnRIYW5kbGVyc1tldmVudElkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbmU6IGZ1bmN0aW9uIG9uZXRpbWUoZWwsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBlbCA9IEtUVXRpbC5nZXQoZWwpO1xuXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uIGNhbGxlZShlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLnR5cGUsIGNhbGxlZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzaDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IDAsXG4gICAgICAgICAgICAgICAgaSwgY2hyO1xuXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hyO1xuICAgICAgICAgICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFuaW1hdGVDbGFzczogZnVuY3Rpb24oZWwsIGFuaW1hdGlvbk5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAgICAgICAgICAgICBPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgICAgICAgICAgICAgTW96QW5pbWF0aW9uOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAgICAgICAgICAgICBXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICAgICAgICAgICAgIG1zQW5pbWF0aW9uOiAnbXNBbmltYXRpb25FbmQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgdCBpbiBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnN0eWxlW3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1t0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyhlbCwgJ2FuaW1hdGVkICcgKyBhbmltYXRpb25OYW1lKTtcblxuICAgICAgICAgICAgS1RVdGlsLm9uZShlbCwgYW5pbWF0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3MoZWwsICdhbmltYXRlZCAnICsgYW5pbWF0aW9uTmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLm9uZShlbCwgYW5pbWF0aW9uLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICAgICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICAgICAgICAgTW96VHJhbnNpdGlvbjogJ21velRyYW5zaXRpb25FbmQnLFxuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICAgICAgICBtc1RyYW5zaXRpb246ICdtc1RyYW5zaXRpb25FbmQnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciB0IGluIHRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnN0eWxlW3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zW3RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS1RVdGlsLm9uZShlbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFuaW1hdGlvbkVuZDogZnVuY3Rpb24oZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAgICAgICAgICAgICBPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgICAgICAgICAgICAgTW96QW5pbWF0aW9uOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAgICAgICAgICAgICBXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICAgICAgICAgICAgIG1zQW5pbWF0aW9uOiAnbXNBbmltYXRpb25FbmQnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciB0IGluIGFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuc3R5bGVbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24gPSBhbmltYXRpb25zW3RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS1RVdGlsLm9uZShlbCwgYW5pbWF0aW9uLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW5pbWF0ZURlbGF5OiBmdW5jdGlvbihlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQtJywgJ21vei0nLCAnbXMtJywgJ28tJywgJyddO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmNzcyhlbCwgdmVuZG9yc1tpXSArICdhbmltYXRpb24tZGVsYXknLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW5pbWF0ZUR1cmF0aW9uOiBmdW5jdGlvbihlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQtJywgJ21vei0nLCAnbXMtJywgJ28tJywgJyddO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgS1RVdGlsLmNzcyhlbCwgdmVuZG9yc1tpXSArICdhbmltYXRpb24tZHVyYXRpb24nLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Nyb2xsVG86IGZ1bmN0aW9uKHRhcmdldCwgb2Zmc2V0LCBkdXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gZHVyYXRpb24gPyBkdXJhdGlvbiA6IDUwMDtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBLVFV0aWwuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UG9zID0gdGFyZ2V0ID8gS1RVdGlsLm9mZnNldCh0YXJnZXQpLnRvcCA6IDA7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsUG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcbiAgICAgICAgICAgIHZhciBmcm9tLCB0bztcblxuICAgICAgICAgICAgaWYgKHRhcmdldFBvcyA+IHNjcm9sbFBvcykge1xuICAgICAgICAgICAgICAgIGZyb20gPSB0YXJnZXRQb3M7XG4gICAgICAgICAgICAgICAgdG8gPSBzY3JvbGxQb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb20gPSBzY3JvbGxQb3M7XG4gICAgICAgICAgICAgICAgdG8gPSB0YXJnZXRQb3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtUVXRpbC5hbmltYXRlKGZyb20sIHRvLCBkdXJhdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gdmFsdWU7XG4gICAgICAgICAgICB9KTsgLy8sIGVhc2luZywgZG9uZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjcm9sbFRvcDogZnVuY3Rpb24ob2Zmc2V0LCBkdXJhdGlvbikge1xuICAgICAgICAgICAgS1RVdGlsLnNjcm9sbFRvKG51bGwsIG9mZnNldCwgZHVyYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iaik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQgPyBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgOiBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbihuU3RyKSB7XG4gICAgICAgICAgICBuU3RyICs9ICcnO1xuICAgICAgICAgICAgdmFyIHggPSBuU3RyLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgeDEgPSB4WzBdO1xuICAgICAgICAgICAgdmFyIHgyID0geC5sZW5ndGggPiAxID8gJy4nICsgeFsxXSA6ICcnO1xuICAgICAgICAgICAgdmFyIHJneCA9IC8oXFxkKykoXFxkezN9KS87XG4gICAgICAgICAgICB3aGlsZSAocmd4LnRlc3QoeDEpKSB7XG4gICAgICAgICAgICAgICAgeDEgPSB4MS5yZXBsYWNlKHJneCwgJyQxJyArICcsJyArICckMicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgxICsgeDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0ZWN0SUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgdmFsdWVzOyBVbmNvbW1lbnQgdG8gY2hlY2sgcmVzdWx0IOKAplxuXG4gICAgICAgICAgICAvLyBJRSAxMFxuICAgICAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKGNvbXBhdGlibGU7IE1TSUUgMTAuMDsgV2luZG93cyBOVCA2LjI7IFRyaWRlbnQvNi4wKSc7XG5cbiAgICAgICAgICAgIC8vIElFIDExXG4gICAgICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztcblxuICAgICAgICAgICAgLy8gRWRnZSAxMiAoU3BhcnRhbilcbiAgICAgICAgICAgIC8vIHVhID0gJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdPVzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzkuMC4yMTcxLjcxIFNhZmFyaS81MzcuMzYgRWRnZS8xMi4wJztcblxuICAgICAgICAgICAgLy8gRWRnZSAxM1xuICAgICAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzQ2LjAuMjQ4Ni4wIFNhZmFyaS81MzcuMzYgRWRnZS8xMy4xMDU4Nic7XG5cbiAgICAgICAgICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignTVNJRSAnKTtcbiAgICAgICAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoJy4nLCBtc2llKSksIDEwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyaWRlbnQgPSB1YS5pbmRleE9mKCdUcmlkZW50LycpO1xuICAgICAgICAgICAgaWYgKHRyaWRlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gdWEuaW5kZXhPZigncnY6Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhydiArIDMsIHVhLmluZGV4T2YoJy4nLCBydikpLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gdWEuaW5kZXhPZignRWRnZS8nKTtcbiAgICAgICAgICAgIGlmIChlZGdlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhlZGdlICsgNSwgdWEuaW5kZXhPZignLicsIGVkZ2UpKSwgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlciBicm93c2VyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNSVEw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChLVFV0aWwuYXR0cihLVFV0aWwuZ2V0KCdodG1sJyksICdkaXJlY3Rpb24nKSA9PSAncnRsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9cblxuICAgICAgICAvLyBTY3JvbGxlclxuICAgICAgICBzY3JvbGxJbml0OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZighZWxlbWVudCkgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRGVmaW5lIGluaXQgZnVuY3Rpb25cbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBzO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChvcHRpb25zLmhlaWdodC5jYWxsKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KG9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHNjcm9sbCBvbiB0YWJsZSBhbmQgbW9iaWxlIG1vZGVzXG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb25zLm1vYmlsZU5hdGl2ZVNjcm9sbCB8fCBvcHRpb25zLmRpc2FibGVGb3JNb2JpbGUpICYmIEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCd0YWJsZXQtYW5kLW1vYmlsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBzID0gS1RVdGlsLmRhdGEoZWxlbWVudCkuZ2V0KCdwcycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlc2V0SGVpZ2h0T25EZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmNzcyhlbGVtZW50LCAnaGVpZ2h0JywgJ2F1dG8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmNzcyhlbGVtZW50LCAnb3ZlcmZsb3cnLCAnYXV0bycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtUVXRpbC5jc3MoZWxlbWVudCwgJ2hlaWdodCcsIGhlaWdodCArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcHMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHMgPSBLVFV0aWwuZGF0YShlbGVtZW50KS5yZW1vdmUoJ3BzJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsZW1lbnQsICdvdmVyZmxvdycsICdhdXRvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsZW1lbnQsICdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuY3NzKGVsZW1lbnQsICdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZXNrdG9wTmF0aXZlU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5jc3MoZWxlbWVudCwgJ292ZXJmbG93JywgJ2F1dG8nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEluaXQgc2Nyb2xsXG4gICAgICAgICAgICAgICAgS1RVdGlsLmNzcyhlbGVtZW50LCAnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XG5cbiAgICAgICAgICAgICAgICBwcyA9IEtUVXRpbC5kYXRhKGVsZW1lbnQpLmdldCgncHMnKTtcbiAgICAgICAgICAgICAgICBpZiAocHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKGVsZW1lbnQsICdzY3JvbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgcHMgPSBuZXcgUGVyZmVjdFNjcm9sbGJhcihlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbFNwZWVkOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZUVhc2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsUHJvcGFnYXRpb246IChvcHRpb25zLndpbmRvd1Njcm9sbCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluU2Nyb2xsYmFyTGVuZ3RoOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFNjcm9sbGJhckxlbmd0aDogMzAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcHJlc3NTY3JvbGxYOiBLVFV0aWwuYXR0cihlbGVtZW50LCAnZGF0YS1zY3JvbGwteCcpICE9ICd0cnVlJyA/IHRydWUgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuZGF0YShlbGVtZW50KS5zZXQoJ3BzJywgcHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHNjcm9sbCBwb3NpdGlvbiBpbiBjb29raWVcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gS1RVdGlsLmF0dHIoZWxlbWVudCwgJ2lkJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZW1lbWJlclBvc2l0aW9uID09PSB0cnVlICYmIENvb2tpZXMgJiYgdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb29raWVzLmdldCh1aWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQoQ29va2llcy5nZXQodWlkKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BzLXNjcm9sbC15JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb29raWVzLnNldCh1aWQsIGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbml0XG4gICAgICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB3aW5kb3cgcmVzaXplXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuYWRkUmVzaXplSGFuZGxlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjcm9sbFVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHBzID0gS1RVdGlsLmRhdGEoZWxlbWVudCkuZ2V0KCdwcycpO1xuICAgICAgICAgICAgaWYgKHBzKSB7XG4gICAgICAgICAgICAgICAgcHMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Nyb2xsVXBkYXRlQWxsOiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlcnMgPSBLVFV0aWwuZmluZEFsbChwYXJlbnQsICcucHMnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzY3JvbGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuc2Nyb2xsZXJVcGRhdGUoc2Nyb2xsZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzY3JvbGxEZXN0cm95OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcHMgPSBLVFV0aWwuZGF0YShlbGVtZW50KS5nZXQoJ3BzJyk7XG4gICAgICAgICAgICBpZiAocHMpIHtcbiAgICAgICAgICAgICAgICBwcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcHMgPSBLVFV0aWwuZGF0YShlbGVtZW50KS5yZW1vdmUoJ3BzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SFRNTDogZnVuY3Rpb24oZWwsIGh0bWwpIHtcbiAgICAgICAgICAgIGlmIChLVFV0aWwuZ2V0KGVsKSkge1xuICAgICAgICAgICAgICAgIEtUVXRpbC5nZXQoZWwpLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SFRNTDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmIChLVFV0aWwuZ2V0KGVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBLVFV0aWwuZ2V0KGVsKS5pbm5lckhUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RG9jdW1lbnRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCggYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkub2Zmc2V0SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwub2Zmc2V0SGVpZ2h0ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAgKGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICB9XG59KCk7XG5cbi8vIHdlYnBhY2sgc3VwcG9ydFxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEtUVXRpbDtcbn1cblxuLy8gSW5pdGlhbGl6ZSBLVFV0aWwgY2xhc3Mgb24gZG9jdW1lbnQgcmVhZHlcbktUVXRpbC5yZWFkeShmdW5jdGlvbigpIHtcbiAgICBLVFV0aWwuaW5pdCgpO1xufSk7XG5cbi8vIENTUzMgVHJhbnNpdGlvbnMgb25seSBhZnRlciBwYWdlIGxvYWQoLnBhZ2UtbG9hZGluZyBjbGFzcyBhZGRlZCB0byBib2R5IHRhZyBhbmQgcmVtb3ZlIHdpdGggSlMgb24gcGFnZSBsb2FkKVxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhLVFV0aWwuZ2V0KCdib2R5JyksICdwYWdlLS1sb2FkaW5nJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBLVExheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5O1xuXG4gICAgdmFyIGFzaWRlO1xuICAgIHZhciBhc2lkZU1lbnU7XG4gICAgdmFyIGFzaWRlTWVudU9mZmNhbnZhcztcblxuICAgIHZhciBzY3JvbGxUb3A7XG5cbiAgICB2YXIgcGFnZVN0aWNreVBvcnRsZXQ7XG5cbiAgICAvLyBBc2lkZVxuICAgIHZhciBpbml0QXNpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYXNpZGUgPSBLVFV0aWwuZ2V0KCdhc2lkZScpO1xuXG4gICAgICAgIC8vIEluaXQgb2ZmY2FudmFzIGxheW91dCBmb3IgbW9iaWxlXG4gICAgICAgIGFzaWRlTWVudU9mZmNhbnZhcyA9IG5ldyBLVE9mZmNhbnZhcygnYXNpZGUnLCB7XG4gICAgICAgICAgICBiYXNlQ2xhc3M6ICdhc2lkZScsXG4gICAgICAgICAgICBvdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgY2xvc2VCeTogJ2FzaWRlX2Nsb3NlX2J0bicsXG4gICAgICAgICAgICB0b2dnbGVCeToge1xuICAgICAgICAgICAgICAgIHRhcmdldDogJ2FzaWRlX21vYmlsZV90b2dnbGVyJyxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2hlYWRlci1tb2JpbGVfX3Rvb2xiYXItdG9nZ2xlci0tYWN0aXZlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0IGFzaWRlIG1lbnVcbiAgICAgICAgdmFyIG1lbnUgPSBLVFV0aWwuZ2V0KCdhc2lkZV9tZW51Jyk7XG4gICAgICAgIHZhciBtZW51ID0gS1RVdGlsLmdldEJ5SUQoJ2FzaWRlX21lbnUnKTtcbiAgICAgICAgdmFyIG1lbnVEZXNrdG9wTW9kZSA9IChLVFV0aWwuYXR0cihtZW51LCAnZGF0YS1rdG1lbnUtZHJvcGRvd24nKSA9PT0gJzEnID8gJ2Ryb3Bkb3duJyA6ICdhY2NvcmRpb24nKTtcblxuICAgICAgICAvLyBJbml0IHNjcm9sbGFibGUgbWVudSBjb250YWluZXJcbiAgICAgICAgdmFyIHNjcm9sbDtcbiAgICAgICAgaWYgKEtUVXRpbC5hdHRyKG1lbnUsICdkYXRhLWt0bWVudS1zY3JvbGwnKSA9PT0gJzEnKSB7XG4gICAgICAgICAgICBzY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgcmVtZW1iZXJQb3NpdGlvbjogdHJ1ZSwgLy8gcmVtZW1iZXIgcG9zaXRpb24gb24gcGFnZSByZWxvYWRcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGZ1bmN0aW9uKCkgeyAgLy8gY2FsY3VsYXRlIGF2YWlsYWJsZSBzY3JvbGxhYmxlIGFyZWEgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZWQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2luZG93IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93SGVpZ2h0ID0gcGFyc2VJbnQoS1RVdGlsLmdldFZpZXdQb3J0KCkuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzZWNvbmRhcnlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZGFyeSA9IEtUVXRpbC5maW5kKGFzaWRlLCAnLmFzaWRlX19zZWNvbmRhcnknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZGFyeVBhZGRpbmdUb3AgPSBwYXJzZUludChLVFV0aWwuY3NzKHNlY29uZGFyeSwgJ3BhZGRpbmctdG9wJykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kYXJ5UGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KEtUVXRpbC5jc3Moc2Vjb25kYXJ5LCAncGFkZGluZy1ib3R0b20nKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG9wIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gS1RVdGlsLmZpbmQoYXNpZGUsICcuYXNpZGVfX3NlY29uZGFyeS10b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcEhlaWdodCA9IHBhcnNlSW50KEtUVXRpbC5oZWlnaHQodG9wKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBLVFV0aWwuZmluZChhc2lkZSwgJy5hc2lkZV9fc2Vjb25kYXJ5LWJvdHRvbScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tUGFkZGluZ1RvcCA9IHBhcnNlSW50KEtUVXRpbC5jc3MoYm90dG9tLCAncGFkZGluZy10b3AnKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21QYWRkaW5nQm90dG9uID0gcGFyc2VJbnQoS1RVdGlsLmNzcyhib3R0b20sICdwYWRkaW5nLWJvdHRvbScpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpbmRvd0hlaWdodCAtIHRvcEhlaWdodCAtIGJvdHRvbVBhZGRpbmdUb3AgLSBib3R0b21QYWRkaW5nQm90dG9uIC0gc2Vjb25kYXJ5UGFkZGluZ1RvcCAtIHNlY29uZGFyeVBhZGRpbmdCb3R0b207XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdCBhc2lkZSBtZW51XG4gICAgICAgIGFzaWRlTWVudSA9IG5ldyBLVE1lbnUoJ2FzaWRlX21lbnUnLCB7XG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCBzY3JvbGxcbiAgICAgICAgICAgIHNjcm9sbDogc2Nyb2xsLFxuXG4gICAgICAgICAgICAvLyBzdWJtZW51IHNldHVwXG4gICAgICAgICAgICBzdWJtZW51OiB7XG4gICAgICAgICAgICAgICAgZGVza3RvcDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IHRoZSBtZW51IG1vZGUgc2V0IHRvIGFjY29yZGlvbiBpbiBkZXNrdG9wIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogbWVudURlc2t0b3BNb2RlLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuZXZlciBib2R5IGhhcyB0aGlzIGNsYXNzIHN3aXRjaCB0aGUgbWVudSBtb2RlIHRvIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAnYXNpZGUtLW1pbmltaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdkcm9wZG93bidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGFibGV0OiAnYWNjb3JkaW9uJywgLy8gbWVudSBzZXQgdG8gYWNjb3JkaW9uIGluIHRhYmxldCBtb2RlXG4gICAgICAgICAgICAgICAgbW9iaWxlOiAnYWNjb3JkaW9uJyAvLyBtZW51IHNldCB0byBhY2NvcmRpb24gaW4gbW9iaWxlIG1vZGVcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vYWNjb3JkaW9uIHNldHVwXG4gICAgICAgICAgICBhY2NvcmRpb246IHtcbiAgICAgICAgICAgICAgICBleHBhbmRBbGw6IGZhbHNlIC8vIGFsbG93IGhhdmluZyBtdWx0aXBsZSBleHBhbmRlZCBhY2NvcmRpb25zIGluIHRoZSBtZW51XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNjcm9sbHRvcFxuICAgIHZhciBpbml0U2Nyb2xsdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY3JvbGx0b3AgPSBuZXcgS1RTY3JvbGx0b3AoJ3Njcm9sbHRvcCcsIHtcbiAgICAgICAgICAgIG9mZnNldDogMzAwLFxuICAgICAgICAgICAgc3BlZWQ6IDYwMFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJbml0IHBhZ2Ugc3RpY2t5IHBvcnRsZXRcbiAgICB2YXIgaW5pdFBhZ2VTdGlja3lQb3J0bGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhc2lkZVByaW1hcnlXaWR0aCA9IDcwO1xuICAgICAgICB2YXIgYXNpZGVTZWNvbmRhcnlXaWR0aCA9IDI1MDtcblxuICAgICAgICByZXR1cm4gbmV3IEtUUG9ydGxldCgncGFnZV9wb3J0bGV0Jywge1xuICAgICAgICAgICAgc3RpY2t5OiB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiA4MCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDkwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEtUVXRpbC5pc0luUmVzcG9uc2l2ZVJhbmdlKCdkZXNrdG9wJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoS1RVdGlsLmhhc0NsYXNzKGJvZHksICdzdWJoZWFkZXItLWZpeGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zICsgcGFyc2VJbnQoS1RVdGlsLmNzcyggS1RVdGlsLmdldCgnc3ViaGVhZGVyJyksICdoZWlnaHQnKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEtUVXRpbC5oYXNDbGFzcyhib2R5LCAnaGVhZGVyLW1vYmlsZS0tZml4ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MgKyBwYXJzZUludChLVFV0aWwuY3NzKCBLVFV0aWwuZ2V0KCdoZWFkZXJfbW9iaWxlJyksICdoZWlnaHQnKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZnVuY3Rpb24ocG9ydGxldCkge1xuXHRcdFx0XHRcdFx0dmFyIHBvcmxldEVsID0gcG9ydGxldC5nZXRTZWxmKCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiBLVFV0aWwub2Zmc2V0KHBvcmxldEVsKS5sZWZ0O1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmlnaHQ6IGZ1bmN0aW9uKHBvcnRsZXQpIHtcblx0XHRcdFx0XHRcdHZhciBwb3JsZXRFbCA9IHBvcnRsZXQuZ2V0U2VsZigpO1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9ydGxldFdpZHRoID0gcGFyc2VJbnQoS1RVdGlsLmNzcyhwb3JsZXRFbCwgJ3dpZHRoJykpO1xuXHRcdFx0XHRcdFx0dmFyIGJvZHlXaWR0aCA9IHBhcnNlSW50KEtUVXRpbC5jc3MoS1RVdGlsLmdldCgnYm9keScpLCAnd2lkdGgnKSk7XG5cdFx0XHRcdFx0XHR2YXIgcG9ydGxldE9mZnNldExlZnQgPSBLVFV0aWwub2Zmc2V0KHBvcmxldEVsKS5sZWZ0O1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gYm9keVdpZHRoIC0gcG9ydGxldFdpZHRoIC0gcG9ydGxldE9mZnNldExlZnQ7XG5cdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBib2R5ID0gS1RVdGlsLmdldEJ5VGFnKCdib2R5Jyk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdEFzaWRlKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRTY3JvbGx0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFBhZ2VTdGlja3lQb3J0bGV0KCk7XG5cbiAgICAgICAgICAgIC8vIE5vbiBmdW5jdGlvbmFsIGxpbmtzIG5vdGljZShjYW4gYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uKVxuICAgICAgICAgICAgJCgnI2FzaWRlX21lbnUsICNoZWFkZXJfbWVudScpLm9uKCdjbGljaycsICcubWVudV9fbGlua1tocmVmPVwiI1wiXTpub3QoLm1lbnVfX3RvZ2dsZSknLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc3dhbChcIlwiLCBcIllvdSBoYXZlIGNsaWNrZWQgb24gYSBub24tZnVuY3Rpb25hbCBkdW1teSBsaW5rIVwiKTtcblxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRBc2lkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0QXNpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0U2Nyb2xsdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRTY3JvbGx0b3AoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0UGFnZVN0aWNreVBvcnRsZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFLVFV0aWwuZ2V0KCdwYWdlX3BvcnRsZXQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFnZVN0aWNreVBvcnRsZXQgPSBpbml0UGFnZVN0aWNreVBvcnRsZXQoKTtcbiAgICAgICAgICAgIHBhZ2VTdGlja3lQb3J0bGV0LmluaXRTdGlja3koKTtcblxuICAgICAgICAgICAgS1RVdGlsLmFkZFJlc2l6ZUhhbmRsZXIoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBwYWdlU3RpY2t5UG9ydGxldC51cGRhdGVTdGlja3koKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbml0UGFnZVN0aWNreVBvcnRsZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBc2lkZU1lbnU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzaWRlTWVudTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZU1vYmlsZUFzaWRlTWVudU9mZmNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoS1RVdGlsLmlzTW9iaWxlRGV2aWNlKCkpIHtcbiAgICAgICAgICAgICAgICBhc2lkZU1lbnVPZmZjYW52YXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlTW9iaWxlSGVhZGVyTWVudU9mZmNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoS1RVdGlsLmlzTW9iaWxlRGV2aWNlKCkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJNZW51T2ZmY2FudmFzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KCk7XG5cbi8vIHdlYnBhY2sgc3VwcG9ydFxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLVExheW91dDtcbn1cblxuLy8gSW5pdCBvbiBwYWdlIGxvYWQgY29tcGxldGVkXG5LVFV0aWwucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgS1RMYXlvdXQuaW5pdCgpO1xufSk7XG4iLCIvLyBDbGFzcyBkZWZpbml0aW9uXG52YXIgS1RMaWIgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGluaXRNaW5pQ2hhcnQ6IGZ1bmN0aW9uKHNyYywgZGF0YSwgY29sb3IsIGJvcmRlciwgZmlsbCwgdG9vbHRpcCkge1xuICAgICAgICAgICAgaWYgKHNyYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgZmlsbCA9ICh0eXBlb2YgZmlsbCAhPT0gJ3VuZGVmaW5lZCcpID8gZmlsbCA6IGZhbHNlO1xuICAgICAgICAgICAgdG9vbHRpcCA9ICh0eXBlb2YgdG9vbHRpcCAhPT0gJ3VuZGVmaW5lZCcpID8gdG9vbHRpcCA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiBib3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEhvdmVyUmFkaXVzOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRIb3ZlckJvcmRlcldpZHRoOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCYWNrZ3JvdW5kQ29sb3I6IENoYXJ0LmhlbHBlcnMuY29sb3IoJyMwMDAwMDAnKS5hbHBoYSgwKS5yZ2JTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50Qm9yZGVyQ29sb3I6IENoYXJ0LmhlbHBlcnMuY29sb3IoJyMwMDAwMDAnKS5hbHBoYSgwKS5yZ2JTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3I6IEtUQXBwLmdldFN0YXRlQ29sb3IoJ2JyYW5kJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEhvdmVyQm9yZGVyQ29sb3I6IENoYXJ0LmhlbHBlcnMuY29sb3IoJyMwMDAwMDAnKS5hbHBoYSgwLjEpLnJnYlN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBzOiAodG9vbHRpcCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ25lYXJlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVNwYWNpbmc6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5UGFkZGluZzogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICB4UGFkZGluZzogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Q29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogS1RBcHAuZ2V0U3RhdGVDb2xvcignYnJhbmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlRm9udENvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXM6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb290ZXJTcGFjaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVTcGFjaW5nOiAwXG4gICAgICAgICAgICAgICAgICAgIH0gOiBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VQb2ludFN0eWxlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbmRleCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4QXhlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkTGluZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnTW9udGgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5QXhlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkTGluZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnTW9udGgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNpb246IDAuNVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNoYXJ0ID0gbmV3IENoYXJ0KHNyYywgY29uZmlnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0TWVkaXVtQ2hhcnQ6IGZ1bmN0aW9uKHNyYywgZGF0YSwgbWF4LCBjb2xvciwgYm9yZGVyKSB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNyYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBib3JkZXIgPSBib3JkZXIgPyBib3JkZXIgOiAyO1xuXG4gICAgICAgICAgICAvLyBNYWluIGNoYXJ0XG4gICAgICAgICAgICB2YXIgY3R4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3JjKS5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAxMDApO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIENoYXJ0LmhlbHBlcnMuY29sb3IoY29sb3IpLmFscGhhKDAuMykucmdiU3RyaW5nKCkpO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIENoYXJ0LmhlbHBlcnMuY29sb3IoY29sb3IpLmFscGhhKDApLnJnYlN0cmluZygpKTtcblxuICAgICAgICAgICAgdmFyIG1haW5Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ09yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogYm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBncmFkaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50QmFja2dyb3VuZENvbG9yOiBLVEFwcC5nZXRTdGF0ZUNvbG9yKCdicmFuZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdTdGFja2VkIEFyZWEnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlTcGFjaW5nOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgeVBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeFBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IEtUQXBwLmdldFN0YXRlQ29sb3IoJ2JyYW5kJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZUZvbnRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyU3BhY2luZzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlU3BhY2luZzogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlUG9pbnRTdHlsZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbmRleCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4QXhlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFN0cmluZzogJ01vbnRoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdWYWx1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRMaW5lczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNlZWYyZjknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3Qm9yZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0R3JpZExpbmVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyQm9yZGVyV2lkdGg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCBtYWluQ29uZmlnKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IG9uIHdpbmRvdyByZXNpemVcbiAgICAgICAgICAgIEtUVXRpbC5hZGRSZXNpemVIYW5kbGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSgpO1xuXG4vLyB3ZWJwYWNrIHN1cHBvcnRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gS1RMaWI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEtUT2ZmY2FudmFzUGFuZWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm90aWZpY2F0aW9uUGFuZWwgPSBLVFV0aWwuZ2V0KCdvZmZjYW52YXNfdG9vbGJhcl9ub3RpZmljYXRpb25zJyk7XG4gICAgdmFyIHF1aWNrQWN0aW9uc1BhbmVsID0gS1RVdGlsLmdldCgnb2ZmY2FudmFzX3Rvb2xiYXJfcXVpY2tfYWN0aW9ucycpO1xuICAgIHZhciBwcm9maWxlUGFuZWwgPSBLVFV0aWwuZ2V0KCdvZmZjYW52YXNfdG9vbGJhcl9wcm9maWxlJyk7XG4gICAgdmFyIHNlYXJjaFBhbmVsID0gS1RVdGlsLmdldCgnb2ZmY2FudmFzX3Rvb2xiYXJfc2VhcmNoJyk7XG5cbiAgICB2YXIgaW5pdE5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWQgPSBLVFV0aWwuZmluZChub3RpZmljYXRpb25QYW5lbCwgJy5vZmZjYW52YXMtcGFuZWxfX2hlYWQnKTtcbiAgICAgICAgdmFyIGJvZHkgPSBLVFV0aWwuZmluZChub3RpZmljYXRpb25QYW5lbCwgJy5vZmZjYW52YXMtcGFuZWxfX2JvZHknKTtcblxuICAgICAgICB2YXIgb2ZmY2FudmFzID0gbmV3IEtUT2ZmY2FudmFzKG5vdGlmaWNhdGlvblBhbmVsLCB7XG4gICAgICAgICAgICBvdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgYmFzZUNsYXNzOiAnb2ZmY2FudmFzLXBhbmVsJyxcbiAgICAgICAgICAgIGNsb3NlQnk6ICdvZmZjYW52YXNfdG9vbGJhcl9ub3RpZmljYXRpb25zX2Nsb3NlJyxcbiAgICAgICAgICAgIHRvZ2dsZUJ5OiAnb2ZmY2FudmFzX3Rvb2xiYXJfbm90aWZpY2F0aW9uc190b2dnbGVyX2J0bidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgS1RVdGlsLnNjcm9sbEluaXQoYm9keSwge1xuICAgICAgICAgICAgZGlzYWJsZUZvck1vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc2V0SGVpZ2h0T25EZXN0cm95OiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgaGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQoS1RVdGlsLmdldFZpZXdQb3J0KCkuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHBhcnNlSW50KEtUVXRpbC5hY3R1YWxIZWlnaHQoaGVhZCkpO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChLVFV0aWwuY3NzKGhlYWQsICdtYXJnaW5Cb3R0b20nKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmNzcyhub3RpZmljYXRpb25QYW5lbCwgJ3BhZGRpbmdUb3AnKSk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmNzcyhub3RpZmljYXRpb25QYW5lbCwgJ3BhZGRpbmdCb3R0b20nKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdFF1Y2lrQWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZCA9IEtUVXRpbC5maW5kKHF1aWNrQWN0aW9uc1BhbmVsLCAnLm9mZmNhbnZhcy1wYW5lbF9faGVhZCcpO1xuICAgICAgICB2YXIgYm9keSA9IEtUVXRpbC5maW5kKHF1aWNrQWN0aW9uc1BhbmVsLCAnLm9mZmNhbnZhcy1wYW5lbF9fYm9keScpO1xuXG4gICAgICAgIHZhciBvZmZjYW52YXMgPSBuZXcgS1RPZmZjYW52YXMocXVpY2tBY3Rpb25zUGFuZWwsIHtcbiAgICAgICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICBiYXNlQ2xhc3M6ICdvZmZjYW52YXMtcGFuZWwnLFxuICAgICAgICAgICAgY2xvc2VCeTogJ29mZmNhbnZhc190b29sYmFyX3F1aWNrX2FjdGlvbnNfY2xvc2UnLFxuICAgICAgICAgICAgdG9nZ2xlQnk6ICdvZmZjYW52YXNfdG9vbGJhcl9xdWlja19hY3Rpb25zX3RvZ2dsZXJfYnRuJ1xuICAgICAgICB9KTtcblxuICAgICAgICBLVFV0aWwuc2Nyb2xsSW5pdChib2R5LCB7XG4gICAgICAgICAgICBkaXNhYmxlRm9yTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgcmVzZXRIZWlnaHRPbkRlc3Ryb3k6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXG4gICAgICAgICAgICBoZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUludChLVFV0aWwuZ2V0Vmlld1BvcnQoKS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmFjdHVhbEhlaWdodChoZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHBhcnNlSW50KEtUVXRpbC5jc3MoaGVhZCwgJ21hcmdpbkJvdHRvbScpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChLVFV0aWwuY3NzKHF1aWNrQWN0aW9uc1BhbmVsLCAncGFkZGluZ1RvcCcpKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChLVFV0aWwuY3NzKHF1aWNrQWN0aW9uc1BhbmVsLCAncGFkZGluZ0JvdHRvbScpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbml0UHJvZmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZCA9IEtUVXRpbC5maW5kKHByb2ZpbGVQYW5lbCwgJy5vZmZjYW52YXMtcGFuZWxfX2hlYWQnKTtcbiAgICAgICAgdmFyIGJvZHkgPSBLVFV0aWwuZmluZChwcm9maWxlUGFuZWwsICcub2ZmY2FudmFzLXBhbmVsX19ib2R5Jyk7XG5cbiAgICAgICAgdmFyIG9mZmNhbnZhcyA9IG5ldyBLVE9mZmNhbnZhcyhwcm9maWxlUGFuZWwsIHtcbiAgICAgICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICBiYXNlQ2xhc3M6ICdvZmZjYW52YXMtcGFuZWwnLFxuICAgICAgICAgICAgY2xvc2VCeTogJ29mZmNhbnZhc190b29sYmFyX3Byb2ZpbGVfY2xvc2UnLFxuICAgICAgICAgICAgdG9nZ2xlQnk6ICdvZmZjYW52YXNfdG9vbGJhcl9wcm9maWxlX3RvZ2dsZXJfYnRuJ1xuICAgICAgICB9KTtcblxuICAgICAgICBLVFV0aWwuc2Nyb2xsSW5pdChib2R5LCB7XG4gICAgICAgICAgICBkaXNhYmxlRm9yTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgcmVzZXRIZWlnaHRPbkRlc3Ryb3k6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXG4gICAgICAgICAgICBoZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUludChLVFV0aWwuZ2V0Vmlld1BvcnQoKS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmFjdHVhbEhlaWdodChoZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHBhcnNlSW50KEtUVXRpbC5jc3MoaGVhZCwgJ21hcmdpbkJvdHRvbScpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChLVFV0aWwuY3NzKHByb2ZpbGVQYW5lbCwgJ3BhZGRpbmdUb3AnKSk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmNzcyhwcm9maWxlUGFuZWwsICdwYWRkaW5nQm90dG9tJykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRTZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWQgPSBLVFV0aWwuZmluZChzZWFyY2hQYW5lbCwgJy5vZmZjYW52YXMtcGFuZWxfX2hlYWQnKTtcbiAgICAgICAgdmFyIGJvZHkgPSBLVFV0aWwuZmluZChzZWFyY2hQYW5lbCwgJy5vZmZjYW52YXMtcGFuZWxfX2JvZHknKTtcbiAgICAgICAgdmFyIHNlYXJjaCA9IEtUVXRpbC5nZXQoJ3F1aWNrX3NlYXJjaF9vZmZjYW52YXMnKTtcbiAgICAgICAgdmFyIGZvcm0gPSBLVFV0aWwuZmluZChzZWFyY2gsICcucXVpY2stc2VhcmNoX19mb3JtJyk7XG4gICAgICAgIHZhciB3cmFwcGVyID0gS1RVdGlsLmZpbmQoc2VhcmNoLCAnLnF1aWNrLXNlYXJjaF9fd3JhcHBlcicpO1xuXG4gICAgICAgIHZhciBvZmZjYW52YXMgPSBuZXcgS1RPZmZjYW52YXMoc2VhcmNoUGFuZWwsIHtcbiAgICAgICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICBiYXNlQ2xhc3M6ICdvZmZjYW52YXMtcGFuZWwnLFxuICAgICAgICAgICAgY2xvc2VCeTogJ29mZmNhbnZhc190b29sYmFyX3NlYXJjaF9jbG9zZScsXG4gICAgICAgICAgICB0b2dnbGVCeTogJ29mZmNhbnZhc190b29sYmFyX3NlYXJjaF90b2dnbGVyX2J0bidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgS1RVdGlsLnNjcm9sbEluaXQod3JhcHBlciwge1xuICAgICAgICAgICAgZGlzYWJsZUZvck1vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc2V0SGVpZ2h0T25EZXN0cm95OiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgaGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQoS1RVdGlsLmdldFZpZXdQb3J0KCkuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHBhcnNlSW50KEtUVXRpbC5hY3R1YWxIZWlnaHQoZm9ybSkpO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHBhcnNlSW50KEtUVXRpbC5jc3MoZm9ybSwgJ21hcmdpbkJvdHRvbScpKTtcblxuICAgICAgICAgICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHBhcnNlSW50KEtUVXRpbC5hY3R1YWxIZWlnaHQoaGVhZCkpO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChLVFV0aWwuY3NzKGhlYWQsICdtYXJnaW5Cb3R0b20nKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmNzcyhzZWFyY2hQYW5lbCwgJ3BhZGRpbmdUb3AnKSk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoS1RVdGlsLmNzcyhzZWFyY2hQYW5lbCwgJ3BhZGRpbmdCb3R0b20nKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXROb3RpZmljYXRpb25zKCk7XG4gICAgICAgICAgICBpbml0UXVjaWtBY3Rpb25zKCk7XG4gICAgICAgICAgICBpbml0UHJvZmlsZSgpO1xuICAgICAgICAgICAgaW5pdFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbn0oKTtcblxuLy8gSW5pdCBvbiBwYWdlIGxvYWQgY29tcGxldGVkXG5LVFV0aWwucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgS1RPZmZjYW52YXNQYW5lbC5pbml0KCk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgS1RRdWlja1BhbmVsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhbmVsID0gS1RVdGlsLmdldCgncXVpY2tfcGFuZWwnKTtcbiAgICB2YXIgbm90aWZpY2F0aW9uUGFuZWwgPSBLVFV0aWwuZ2V0KCdxdWlja19wYW5lbF90YWJfbm90aWZpY2F0aW9ucycpO1xuICAgIHZhciBhY3Rpb25zUGFuZWwgPSBLVFV0aWwuZ2V0KCdxdWlja19wYW5lbF90YWJfYWN0aW9ucycpO1xuICAgIHZhciBzZXR0aW5nc1BhbmVsID0gS1RVdGlsLmdldCgncXVpY2tfcGFuZWxfdGFiX3NldHRpbmdzJyk7XG5cbiAgICB2YXIgZ2V0Q29udGVudEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICB2YXIgbmF2ID0gS1RVdGlsLmZpbmQocGFuZWwsICcub2ZmY2FudmFzLXBhbmVsX19uYXYnKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBLVFV0aWwuZmluZChwYW5lbCwgJy5vZmZjYW52YXMtcGFuZWxfX2JvZHknKTtcblxuICAgICAgICBoZWlnaHQgPSBwYXJzZUludChLVFV0aWwuZ2V0Vmlld1BvcnQoKS5oZWlnaHQpIC1cbiAgICAgICAgICAgICAgICAgcGFyc2VJbnQoS1RVdGlsLmFjdHVhbEhlaWdodChuYXYpKSAtXG4gICAgICAgICAgICAgICAgIHBhcnNlSW50KEtUVXRpbC5jc3MobmF2LCAnbWFyZ2luLWJvdHRvbScpKSAtXG4gICAgICAgICAgICAgICAgICgyICogcGFyc2VJbnQoS1RVdGlsLmNzcyhuYXYsICdwYWRkaW5nLXRvcCcpKSkgLVxuICAgICAgICAgICAgICAgICAxMDtcblxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBpbml0T2ZmY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZjYW52YXMgPSBuZXcgS1RPZmZjYW52YXMocGFuZWwsIHtcbiAgICAgICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICBiYXNlQ2xhc3M6ICdvZmZjYW52YXMtcGFuZWwnLFxuICAgICAgICAgICAgY2xvc2VCeTogJ3F1aWNrX3BhbmVsX2Nsb3NlX2J0bicsXG4gICAgICAgICAgICB0b2dnbGVCeTogJ3F1aWNrX3BhbmVsX3RvZ2dsZXJfYnRuJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdE5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgS1RVdGlsLnNjcm9sbEluaXQobm90aWZpY2F0aW9uUGFuZWwsIHtcbiAgICAgICAgICAgIGRpc2FibGVGb3JNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICByZXNldEhlaWdodE9uRGVzdHJveTogdHJ1ZSxcbiAgICAgICAgICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgIGhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbnRlbnRIZWlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRBY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIEtUVXRpbC5zY3JvbGxJbml0KGFjdGlvbnNQYW5lbCwge1xuICAgICAgICAgICAgZGlzYWJsZUZvck1vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc2V0SGVpZ2h0T25EZXN0cm95OiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgaGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29udGVudEhlaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdFNldHRpbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIEtUVXRpbC5zY3JvbGxJbml0KHNldHRpbmdzUGFuZWwsIHtcbiAgICAgICAgICAgIGRpc2FibGVGb3JNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICByZXNldEhlaWdodE9uRGVzdHJveTogdHJ1ZSxcbiAgICAgICAgICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgIGhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbnRlbnRIZWlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZVBlcmZlY3RTY3JvbGxiYXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICQocGFuZWwpLmZpbmQoJ2FbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5vbignc2hvd24uYnMudGFiJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEtUVXRpbC5zY3JvbGxVcGRhdGUobm90aWZpY2F0aW9uUGFuZWwpO1xuICAgICAgICAgICAgS1RVdGlsLnNjcm9sbFVwZGF0ZShhY3Rpb25zUGFuZWwpO1xuICAgICAgICAgICAgS1RVdGlsLnNjcm9sbFVwZGF0ZShzZXR0aW5nc1BhbmVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0T2ZmY2FudmFzKCk7XG4gICAgICAgICAgICBpbml0Tm90aWZpY2F0aW9ucygpO1xuICAgICAgICAgICAgaW5pdEFjdGlvbnMoKTtcbiAgICAgICAgICAgIGluaXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgdXBkYXRlUGVyZmVjdFNjcm9sbGJhcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG59KCk7XG5cbi8vIEluaXQgb24gcGFnZSBsb2FkIGNvbXBsZXRlZFxuS1RVdGlsLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgIEtUUXVpY2tQYW5lbC5pbml0KCk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgS1RRdWlja1NlYXJjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQ7XG4gICAgdmFyIGZvcm07XG4gICAgdmFyIGlucHV0O1xuICAgIHZhciBjbG9zZUljb247XG4gICAgdmFyIHJlc3VsdFdyYXBwZXI7XG4gICAgdmFyIHJlc3VsdERyb3Bkb3duO1xuICAgIHZhciByZXN1bHREcm9wZG93blRvZ2dsZTtcbiAgICB2YXIgaW5wdXRHcm91cDtcbiAgICB2YXIgcXVlcnkgPSAnJztcblxuICAgIHZhciBoYXNSZXN1bHQgPSBmYWxzZTtcbiAgICB2YXIgdGltZW91dCA9IGZhbHNlO1xuICAgIHZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpbWVvdXQgPSAyMDA7IC8vIGFqYXggcmVxdWVzdCBmaXJlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgdmFyIHNwaW5uZXJDbGFzcyA9ICdzcGlubmVyIHNwaW5uZXItLWlucHV0IHNwaW5uZXItLXNtIHNwaW5uZXItLWJyYW5kIHNwaW5uZXItLXJpZ2h0JztcbiAgICB2YXIgcmVzdWx0Q2xhc3MgPSAncXVpY2stc2VhcmNoLS1oYXMtcmVzdWx0JztcbiAgICB2YXIgbWluTGVuZ3RoID0gMjtcblxuICAgIHZhciBzaG93UHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgS1RVdGlsLmFkZENsYXNzKGlucHV0R3JvdXAsIHNwaW5uZXJDbGFzcyk7XG5cbiAgICAgICAgaWYgKGNsb3NlSWNvbikge1xuICAgICAgICAgICAgS1RVdGlsLmhpZGUoY2xvc2VJY29uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoaWRlUHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIEtUVXRpbC5yZW1vdmVDbGFzcyhpbnB1dEdyb3VwLCBzcGlubmVyQ2xhc3MpO1xuXG4gICAgICAgIGlmIChjbG9zZUljb24pIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZS5sZW5ndGggPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuaGlkZShjbG9zZUljb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBLVFV0aWwuc2hvdyhjbG9zZUljb24sICdmbGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvd0Ryb3Bkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXN1bHREcm9wZG93blRvZ2dsZSAmJiAhS1RVdGlsLmhhc0NsYXNzKHJlc3VsdERyb3Bkb3duLCAnc2hvdycpKSB7XG4gICAgICAgICAgICAkKHJlc3VsdERyb3Bkb3duVG9nZ2xlKS5kcm9wZG93bigndG9nZ2xlJyk7XG4gICAgICAgICAgICAkKHJlc3VsdERyb3Bkb3duVG9nZ2xlKS5kcm9wZG93bigndXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGlkZURyb3Bkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXN1bHREcm9wZG93blRvZ2dsZSAmJiBLVFV0aWwuaGFzQ2xhc3MocmVzdWx0RHJvcGRvd24sICdzaG93JykpIHtcbiAgICAgICAgICAgICQocmVzdWx0RHJvcGRvd25Ub2dnbGUpLmRyb3Bkb3duKCd0b2dnbGUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9jZXNzU2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChoYXNSZXN1bHQgJiYgcXVlcnkgPT09IGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICBoaWRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIEtUVXRpbC5hZGRDbGFzcyh0YXJnZXQsIHJlc3VsdENsYXNzKTtcbiAgICAgICAgICAgIHNob3dEcm9wZG93bigpO1xuICAgICAgICAgICAgS1RVdGlsLnNjcm9sbFVwZGF0ZShyZXN1bHRXcmFwcGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVlcnkgPSBpbnB1dC52YWx1ZTtcblxuICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3ModGFyZ2V0LCByZXN1bHRDbGFzcyk7XG4gICAgICAgIHNob3dQcm9ncmVzcygpO1xuICAgICAgICBoaWRlRHJvcGRvd24oKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2tlZW50aGVtZXMuY29tL2tlZW4vdG9vbHMvcHJldmlldy9pbmMvYXBpL3F1aWNrX3NlYXJjaC5waHAnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBoYXNSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBoaWRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLmFkZENsYXNzKHRhcmdldCwgcmVzdWx0Q2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuc2V0SFRNTChyZXN1bHRXcmFwcGVyLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICBzaG93RHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgS1RVdGlsLnNjcm9sbFVwZGF0ZShyZXN1bHRXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhpZGVQcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgICAgICBLVFV0aWwuYWRkQ2xhc3ModGFyZ2V0LCByZXN1bHRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5zZXRIVE1MKHJlc3VsdFdyYXBwZXIsICc8c3BhbiBjbGFzcz1cInF1aWNrLXNlYXJjaF9fbWVzc2FnZVwiPkNvbm5lY3Rpb24gZXJyb3IuIFBsZWFlIHRyeSBhZ2FpbiBsYXRlci48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0Ryb3Bkb3duKCk7XG4gICAgICAgICAgICAgICAgICAgIEtUVXRpbC5zY3JvbGxVcGRhdGUocmVzdWx0V3JhcHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVDYW5jZWwgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgIHF1ZXJ5ID0gJyc7XG4gICAgICAgIGhhc1Jlc3VsdCA9IGZhbHNlO1xuICAgICAgICBLVFV0aWwuaGlkZShjbG9zZUljb24pO1xuICAgICAgICBLVFV0aWwucmVtb3ZlQ2xhc3ModGFyZ2V0LCByZXN1bHRDbGFzcyk7XG4gICAgICAgIGhpZGVEcm9wZG93bigpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVTZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgaGlkZVByb2dyZXNzKCk7XG4gICAgICAgICAgICBoaWRlRHJvcGRvd24oKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJvY2Vzc2luZyA9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwcm9jZXNzU2VhcmNoKCk7XG4gICAgICAgIH0sIHJlcXVlc3RUaW1lb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJbml0XG4gICAgICAgICAgICB0YXJnZXQgPSBlbGVtZW50O1xuICAgICAgICAgICAgZm9ybSA9IEtUVXRpbC5maW5kKHRhcmdldCwgJy5xdWljay1zZWFyY2hfX2Zvcm0nKTtcbiAgICAgICAgICAgIGlucHV0ID0gS1RVdGlsLmZpbmQodGFyZ2V0LCAnLnF1aWNrLXNlYXJjaF9faW5wdXQnKTtcbiAgICAgICAgICAgIGNsb3NlSWNvbiA9IEtUVXRpbC5maW5kKHRhcmdldCwgJy5xdWljay1zZWFyY2hfX2Nsb3NlJyk7XG4gICAgICAgICAgICByZXN1bHRXcmFwcGVyID0gS1RVdGlsLmZpbmQodGFyZ2V0LCAnLnF1aWNrLXNlYXJjaF9fd3JhcHBlcicpO1xuICAgICAgICAgICAgcmVzdWx0RHJvcGRvd24gPSBLVFV0aWwuZmluZCh0YXJnZXQsICcuZHJvcGRvd24tbWVudScpO1xuICAgICAgICAgICAgcmVzdWx0RHJvcGRvd25Ub2dnbGUgPSBLVFV0aWwuZmluZCh0YXJnZXQsICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScpO1xuICAgICAgICAgICAgaW5wdXRHcm91cCA9IEtUVXRpbC5maW5kKHRhcmdldCwgJy5pbnB1dC1ncm91cCcpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggaW5wdXQga2V5dXAgaGFuZGxlclxuICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KGlucHV0LCAna2V5dXAnLCBoYW5kbGVTZWFyY2gpO1xuICAgICAgICAgICAgS1RVdGlsLmFkZEV2ZW50KGlucHV0LCAnZm9jdXMnLCBoYW5kbGVTZWFyY2gpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGVudGVyIGNsaWNrXG4gICAgICAgICAgICBmb3JtLm9ua2V5cHJlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSAxMykge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLVFV0aWwuYWRkRXZlbnQoY2xvc2VJY29uLCAnY2xpY2snLCBoYW5kbGVDYW5jZWwpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBLVFF1aWNrU2VhcmNoTW9iaWxlID0gS1RRdWlja1NlYXJjaDtcblxuLy8gSW5pdCBvbiBwYWdlIGxvYWQgY29tcGxldGVkXG5LVFV0aWwucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgaWYgKEtUVXRpbC5nZXQoJ3F1aWNrX3NlYXJjaF9kcm9wZG93bicpKSB7XG4gICAgICAgIEtUUXVpY2tTZWFyY2goKS5pbml0KEtUVXRpbC5nZXQoJ3F1aWNrX3NlYXJjaF9kcm9wZG93bicpKTtcbiAgICB9XG5cbiAgICBpZiAoS1RVdGlsLmdldCgncXVpY2tfc2VhcmNoX2lubGluZScpKSB7XG4gICAgICAgIEtUUXVpY2tTZWFyY2hNb2JpbGUoKS5pbml0KEtUVXRpbC5nZXQoJ3F1aWNrX3NlYXJjaF9pbmxpbmUnKSk7XG4gICAgfVxuXG4gICAgaWYgKEtUVXRpbC5nZXQoJ3F1aWNrX3NlYXJjaF9vZmZjYW52YXMnKSkge1xuICAgICAgICBLVFF1aWNrU2VhcmNoTW9iaWxlKCkuaW5pdChLVFV0aWwuZ2V0KCdxdWlja19zZWFyY2hfb2ZmY2FudmFzJykpO1xuICAgIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUb29sdGlwIGZyb20gXCJ0b29sdGlwLmpzXCI7XG5cbi8qKlxuICogRGVmaW5lIHRoZSBvdXRwdXQgb2YgdGhpcyBmaWxlLiBUaGUgb3V0cHV0IG9mIENTUyBhbmQgSlMgZmlsZSB3aWxsIGJlIGF1dG8gZGV0ZWN0ZWQuXG4gKlxuICogQG91dHB1dCBqcy90ZW1wbGF0ZVxuICovXG5cbi8vIEdsb2JhbCBMaWJyYWlyZVxucmVxdWlyZShcInBlcmZlY3Qtc2Nyb2xsYmFyL2Nzcy9wZXJmZWN0LXNjcm9sbGJhci5jc3NcIik7XG5cbndpbmRvdy53TnVtYiA9IHJlcXVpcmUoXCJ3bnVtYlwiKTtcbndpbmRvdy5TdGlja3kgPSByZXF1aXJlKFwic3RpY2t5LWpzXCIpO1xud2luZG93LlBlcmZlY3RTY3JvbGxiYXIgPSByZXF1aXJlKFwicGVyZmVjdC1zY3JvbGxiYXIvZGlzdC9wZXJmZWN0LXNjcm9sbGJhclwiKTtcbndpbmRvdy5Db29raWVzID0gcmVxdWlyZShcImpzLWNvb2tpZVwiKTtcbndpbmRvdy5Ub29sdGlwID0gVG9vbHRpcDtcblxuLy8gU2hvcHBlclwicyBwbHVnaW5zXG53aW5kb3cuS1RVdGlsID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9iYXNlL3V0aWxcIik7XG53aW5kb3cuS1RBcHAgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2Jhc2UvYXBwXCIpO1xud2luZG93LktUQXZhdGFyID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9iYXNlL2F2YXRhclwiKTtcbndpbmRvdy5LVERpYWxvZyA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvYmFzZS9kaWFsb2dcIik7XG53aW5kb3cuS1RIZWFkZXIgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2Jhc2UvaGVhZGVyXCIpO1xud2luZG93LktUTWVudSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvYmFzZS9tZW51XCIpO1xud2luZG93LktUT2ZmY2FudmFzID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9iYXNlL29mZmNhbnZhc1wiKTtcbndpbmRvdy5LVFBvcnRsZXQgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2Jhc2UvcG9ydGxldFwiKTtcbndpbmRvdy5LVFNjcm9sbHRvcCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvYmFzZS9zY3JvbGx0b3BcIik7XG53aW5kb3cuS1RUb2dnbGUgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2Jhc2UvdG9nZ2xlXCIpO1xuXG4vLyBMYXlvdXQgc2NyaXB0c1xud2luZG93LktUTGF5b3V0ID0gcmVxdWlyZShcIi4vbGF5b3V0L2xheW91dFwiKTtcbndpbmRvdy5LVExpYiA9IHJlcXVpcmUoXCIuL2xheW91dC9saWJcIik7XG5yZXF1aXJlKFwiLi9sYXlvdXQvb2ZmY2FudmFzLXBhbmVsXCIpO1xucmVxdWlyZShcIi4vbGF5b3V0L3F1aWNrLXBhbmVsXCIpO1xucmVxdWlyZShcIi4vbGF5b3V0L3F1aWNrLXNlYXJjaFwiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=